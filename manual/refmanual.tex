\documentclass{article}
\setlength{\parindent}{0cm}
\usepackage{fullpage}
\usepackage{hyperref}
\usepackage{color}
\usepackage[usenames,dvipsnames,table]{xcolor}
\usepackage{textcomp}
\usepackage[lighttt]{lmodern}

\definecolor{tableHeaderColor}{gray}{0.7}
\definecolor{tableRowColor1}{gray}{0.9}
\definecolor{tableRowColor2}{gray}{1.0}

\usepackage[utf8]{inputenc}
\usepackage{pmboxdraw}
\usepackage{fancyvrb}
\makeatletter
\renewcommand{\l@subsection}{\@dottedtocline{2}{2.0em}{3.0em}}
\makeatother

% inline semantic markup:
\RecustomVerbatimEnvironment
  {Verbatim}{Verbatim}
  {frame=single, commandchars=\\\{\}, fontsize=\small}
\newcommand{\typed}[1]{\textcolor{TealBlue}{#1}}
\newcommand{\comment}[1]{\textcolor{Orange}{#1}}
\newcommand{\metasyn}[1]{\texttt{\textbf{#1}}}

% cross-indexing macros:
\newcommand{\primdefu}[3]{\subsection{\texttt{#1} - #2}\label{prim:#3}}
\newcommand{\primu}[2]{\hyperref[prim:#2]{\textbf{\texttt{#1}}}}
\newcommand{\primdef}[2]{\primdefu{#1}{#2}{#1}}
\newcommand{\prim}[1]{\primu{#1}{#1}}
\newcommand{\combdef}[2]{\primdefu{#1}{#2}{#1}}
\newcommand{\comb}[1]{\primu{#1}{#1}}
\newcommand{\ffidef}[3]{\subsubsection{\texttt{#1} - #2}\label{ffi:#3}}
\newcommand{\ffi}[2]{\hyperref[ffi:#2]{\textbf{\texttt{#1}}}}
\newcommand{\constdef}[3]{\subsubsection{\texttt{#1} - #2}\label{const:#3}}
\newcommand{\const}[2]{\hyperref[const:#2]{\textbf{\texttt{#1}}}}

\begin{document}
\begin{titlepage}
	\centering
	{\scshape\LARGE The Kerf Programming Language \par}
	\vspace{1cm}
	{\Large\itshape John Earnest\par}
	\vspace{1.5cm}
	%{\Large\color{red} (Work In Progress)\par}
	\vfill
	This manual is a reference guide to Kerf, a concise multi-paradigm language with an emphasis on high-performance data processing. For the latest information and licensing inquiries, please consult:
	\begin{center}
		\url{kerf.concerns@gmail.com}
	\end{center}
	\vfill
	{\large \today\par}
\end{titlepage}

\tableofcontents
\newpage

\section{Introduction}
Kerf is a programming language built on pragmatism, borrowing ideas from many popular tools. The syntax of Kerf will be familiar enough to anyone who has programmed in C, Python or VBA. Data is described using syntax from JSON (JavaScript Object Notation), a text-based data interchange format. Queries to search, sort and aggregate data can be performed using SQL syntax. Kerf's built-in commands have aliases which allow programmers to use names and terms they are already used to.

\vspace{0.5cm}

Beneath this friendly syntax, Kerf exposes powerful ideas inspired by the language APL and its descendants. APL has a well-earned reputation for extreme concision, and with practice you will find that Kerf similarly permits you to say a great deal with a few short words. Coming from other programming languages, you may be surprised by how much you can accomplish without writing loops, using conditional statements or declaring variables. Kerf provides a fluid interface between your intentions and your data.

\subsection{Background}
The Kerf team was first introduced to array languages in 2006 by Dennis Shasha at NYU. This led to work with Arthur Whitney's \& Kx System's kdb+ family of languages at the investment banks Cantor Fitzgerald and Merrill Lynch. A precursor language to Kerf called Kona was started around 2009. Kona was open-sourced in Summer 2010 and improved upon with the community for the following four years. Lessons from Kona would inspire Kerf.

\vspace{0.5cm}

The first lines of code for Kerf were written in Summer 2014. Kerf officially launched as a product in Spring 2015. Kerf is the team's third major programming language release, and arguably a fifth generation language and database system. It draws on lessons from over twenty years of programming. It is mature technology.

\vspace{0.5cm}

The name ``Kerf'' comes from a term in woodworking- the cut made by a saw. It springs from the Old English ``cyrf'', the action of cutting. It's short, strong, and simple.

\subsection{Conventions}
Throughout this manual, the names of functions and commands will be shown in a \texttt{monospaced font}. Transcripts of terminal sessions will be shown with sections typed by the user in \typed{blue}:
\begin{Verbatim}
KeRF> \typed{range 6}
  [0, 1, 2, 3, 4, 5]
KeRF> \typed{sum(5, range 6)}
  20
\end{Verbatim}

Sometimes examples will contain comments, colored \comment{orange} to help set them apart from code:
\begin{Verbatim}
2+3;   \comment{// kerf uses c-style line comments}
\end{Verbatim}

\pagebreak
\subsection{Using the REPL}
A Read-Evaluate-Print Loop (REPL) is an interactive console session that allows you to type code and see results. The REPL is the main way you will be interacting with Kerf. If Kerf is in the current directory, you can start the REPL by typing \texttt{./kerf} and pressing return, and if if you have installed Kerf in your path, you can simply type \texttt{kerf}. The rest of this discussion will assume the latter case. To exit the REPL use the key combination Ctrl+d.

\subsubsection{Command-Line Arguments and Scripting}
Kerf accepts several command-line flags to control its behavior. Throughout this manual we will be using the \texttt{-q} flag for some examples to avoid showing the Kerf startup logo for the sake of brevity.

\begin{table}[h]
	\centering
	\rowcolors{1}{tableRowColor1}{tableRowColor2}
	\begin{tabular}{| l | l | l |}
		\hline
		\cellcolor{tableHeaderColor} Flag &
		\cellcolor{tableHeaderColor} Arguments &
		\cellcolor{tableHeaderColor} Behavior \\
		-q & -                 & Suppress the startup banner. \\
		-l & -                 & Enable debug logging. \\
		-e & String Expression & Execute an expression. \\
		-x & String Expression & Evaluate an expression and print the result. \\
		-p & Port Number       & Specify a listening port for starting an IPC server. \\
		-P & Port Number       & Specify a listening port for starting an HTTP server. \\
		-V & Number of Bytes   & Cap virtual memory used for disk-backed storage. \\
		-R & Number of Bytes   & Cap physical workspace RAM reserved by Kerf. \\
		\hline
	\end{tabular}
	\\ \bigskip Summary of Command-Line Flags
\end{table}

The \texttt{-e} and \texttt{-x} flags differ by whether or not they display the result of a calculation. Either will exit the interpreter when complete:

\begin{Verbatim}
> \typed{kerf -x "2+3"}
5
> \typed{kerf -e "2+3"}
>
\end{Verbatim}

If you provide a filenames as command-line arguments, the contents of those files will be executed before opening the REPL. You may wish to conclude scripts with \prim{exit}\texttt{(0)} so that they execute and then self-terminate:

\begin{Verbatim}
> \typed{cat example.kerf}
display join unfold range(10)
exit(0)
> \typed{kerf example.kerf}
[0, 
[0, 1], 
[0, 1, 2], 
[0, 1, 2, 3], 
[0, 1, 2, 3, 4], 
[0, 1, 2, 3, 4, 5], 
[0, 1, 2, 3, 4, 5, 6], 
[0, 1, 2, 3, 4, 5, 6, 7], 
[0, 1, 2, 3, 4, 5, 6, 7, 8], 
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]
>
\end{Verbatim}

\pagebreak
You could also accomplish the same by using \texttt{-x} and \prim{load}:
\begin{Verbatim}
> \typed{kerf -x "load \textquotesingle{}example.kerf\textquotesingle{}"}
\end{Verbatim}

The flags \texttt{-V} and \texttt{-R} permit configuring how Kerf uses system memory. By default, there is no cap for workspace ram usage, and virtual memory for disk-backed tables is also \emph{effectively} uncapped. We can easily observe the behavior of limiting usable workspace RAM:
\begin{Verbatim}
> \typed{./kerf -q -R 10000}
KeRF> \typed{range(1, 500)}
  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,
   27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, ...]
KeRF> \typed{range(1, 20000)}
User-set memory bound prevented further memory allocation.

  range(1, 20000)
  ^
 Virtual memory error
KeRF>
\end{Verbatim}

Note that this limit applies only to Kerf's reference-counted internal pools; external libraries and IPC code can allocate additional memory. Enforcing harder limits will require operating-system-specific tools.

\subsubsection{The REPL}
The REPL always begins with the \texttt{KeRF>} prompt. Type an expression, press return and the result will be printed, followed by an empty line. If an expression returns null, it will appear as an empty line. Trailing whitespace will generally be elided from REPL transcripts in this manual.

\begin{Verbatim}
KeRF> \typed{1+3 5 7}
  [4, 6, 8]

KeRF> \typed{null}
  
KeRF>
\end{Verbatim}

If you type several expressions separated by semicolons (\texttt{;}), each will be executed left to right and the value returned by the final expression will be printed. An empty expression returns null, so if you end a statement with a semicolon it will effectively suppress printing the result. Transcripts in this manual will often use this technique for the sake of brevity.
\begin{Verbatim}
KeRF> \typed{one: 1; two: 2}
  2
KeRF> \typed{one}
  1
KeRF> \typed{a: 3 5 7;}
KeRF>
\end{Verbatim}

If you type an expression with an unbalanced number of \texttt{[}, \texttt{(} or \texttt{\{}, the REPL will prompt you with \texttt{>} to complete the expression on the next line. Remember, newlines and semicolons are always equivalent:
\begin{Verbatim}
KeRF> \typed{[1 2 3}
> \typed{4 5 6]}
  [[1, 2, 3], 
   [4, 5, 6]]
\end{Verbatim}

The up and down cursor keys can be used to cycle through recently entered commands, saving repetitive typing. For your convenience, this history information is stored in \texttt{\$HOME/.kerf\_history} across sessions.

\vspace{0.5cm}

The key combination Control-d will cause Kerf to exit by sending an EOF to the shell. For many this is the preferred way to exit the REPL.

\vspace{0.5cm}

If your program enters an infinite loop or otherwise seems to have locked up, Pressing Control-c will interrupt execution, allowing you to make corrections. Control-z is a stronger epithet which will stop execution of the Kerf process and move it to the background of the shell. Note that backgrounded processes are still alive and still consume memory. For more information regarding stopped processes, refer to Unix documentation for the \texttt{jobs}, \texttt{fg} and \texttt{kill} commands. 

\begin{Verbatim}
KeRF> \typed{for(i: 0; i < 10; i: i-1) \{\}} \comment{// whoops.}
\typed{^C}
  for(i: 0; i < 10; i: i-1) {}
                     ^
 Caught interrupt signal
\end{Verbatim}

\pagebreak
During a session you can use \prim{reset} to clear the workspace and close all open resources. When you're done using Kerf, the \prim{exit} function will exit the REPL and return you to your shell. You may also use the key combination Control-D to exit Kerf.
\begin{Verbatim}
KeRF> \typed{exit()}
>
\end{Verbatim}

Kerf also special-cases a number of common commands to save you typing:

\begin{itemize}
\item \texttt{exit} - equivalent to calling \texttt{\prim{exit}(0)}. Ends the session and stops the Kerf process.

\item \texttt{reset} - equivalent to calling \texttt{\prim{reset}()}. Resets the interpreter and workspace, preserving command line flags to the original Kerf process.

\item \texttt{clear} - equivalent to calling \texttt{\prim{system}('clear')}. Clear the terminal output.

\item \texttt{help} - equivalent to calling \texttt{\prim{help}()}. Display the top-level index for the built-in Kerf command reference.
\end{itemize}

\vspace{0.5cm}

\begin{Verbatim}
KeRF> \typed{help}

Help Menu. Try: help('list').
Press return to see the next part of the table.

┌──────────┐
│subject   │
├──────────┤
│      list│
│   strings│
│     table│
│ aggregate│
│      math│
│combinator│
│       sql│
│      misc│
│       ...│
└──────────┘

KeRF> 
\end{Verbatim}

\pagebreak
\subsection{Examples}
Let's look at a few short Kerf snippets to get a taste of the language:

\vspace{0.5cm}

Are two strings anagrams?
\begin{Verbatim}
def are_anagrams(a, b) \{
	return (sort a) match (sort b)
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{are_anagrams("baton", "stick")}
  0
KeRF> \typed{are_anagrams("setecastronomy","toomanysecrets")}
  1
\end{Verbatim}

\vspace{0.5cm}

Gather simple statistics for random data using SQL syntax:
\begin{Verbatim}
KeRF> \typed{data: \{\{a: rand(100, 5)\}\};}
KeRF> \typed{SELECT count(a) AS items, avg(a) AS average FROM data}
┌─────┬───────┐
│items│average│
├─────┼───────┤
│  100│   1.82│
└─────┴───────┘
\end{Verbatim}

\vspace{0.5cm}

Load a text file and interactively query it:
\begin{Verbatim}
KeRF> \typed{characters: tolower flatten lines "flour.txt"}
  "flour is a powder made by grinding uncooked cereal grains or other seeds or roots (like
   cassava). it is the main ingredient of bread, which is a staple food for many cultures,
   making the availability o..."
KeRF> \typed{sum characters in "aeiou"}
  182
KeRF> \typed{count characters}
  540
KeRF> \typed{5 take \textasciigrave" " explode characters}
  ["flour", "is", "a", "powder", "made"]
\end{Verbatim}

\vspace{0.5cm}

Iteratively calculate terms of the Fibonacci sequence without using explicit loops:
\begin{Verbatim}
KeRF> \typed{6 \{[x] last(x) join sum x\} deconverge 1 1}
  [[1, 1], [1, 2], [2, 3], [3, 5], [5, 8], [8, 13], [13, 21]]
KeRF> \typed{first mapdown 10 \{[x] last(x) join sum x\} deconverge 1 1}
  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
\end{Verbatim}

\pagebreak
\section {Installation}
Pre-compiled evaluation copies of Kerf for 64-bit Linux and OSX can be obtained by request:

\begin{center}
	\texttt{kerf.concerns@gmail.com}
\end{center}

\subsection{Installing (Binary)}
Kerf binaries are statically linked and include all library dependencies. Installation is as simple as placing the binary in a desired directory. Let's place it in a directory called \texttt{/opt/kerf} so that it is accessible by all users. It will be necessary to use the \texttt{sudo} command when creating this directory, as the base directory is owned by \texttt{root}:

\begin{Verbatim}
/Users/john/Desktop> \typed{sudo mkdir /opt/kerf}
Password:
/Users/john/Desktop> \typed{sudo cp KerfREPL/osx/kerf /opt/kerf/}
/Users/john/Desktop> \typed{cd /opt/kerf}
/opt/kerf> \typed{ls}
kerf
\end{Verbatim}

You can then invoke it from the command line. The \texttt{-q} option (\emph{quiet}) suppresses the Kerf logo at startup, for the purposes of brevity in these transcripts.

\begin{Verbatim}
/libf> \typed{./kerf -q}
KeRF> \typed{2+3}
  5
KeRF> \typed{exit(0)}
/opt/kerf> 
\end{Verbatim}

\subsection{Installing (License Files)}

Commercial installations of Kerf typically use a licensing file \texttt{kerf-license.dat}. It is recommended that this license file be placed in \texttt{$\sim$/.kerf/kerf-license.dat}, where \texttt{$\sim$/.kerf} is the hidden \texttt{.kerf} directory under the users's home directory. 

\vspace{0.5cm}

If Kerf does not find the license file in \texttt{$\sim$/.kerf} it will look in the current working directory (\texttt{cwd}) as a fallback. This is usually less convenient.

\vspace{0.5cm}

When the time has expired on the license file it will need to be replaced. If you have an active link to the license server where a license file can be downloaded, you can download a new license file to replace the old one, and the expiration period will refresh.

\begin{Verbatim}
/home/john > \typed{cd \$HOME}              \comment{#change to your home directory}
/home/john > \typed{mkdir -p \$HOME/.kerf}  \comment{#create the directory if it does not exist}
/home/john > \typed{cp kerf-license.dat \$HOME/.kerf/kerf-license.dat}  \comment{#copy the license file}
\end{Verbatim}


\pagebreak
\subsection{Installing (Building from Source)}
If you have been granted access to the Kerf source code, you can build your own binaries. From the base source directory, invoke \texttt{make clean} to remove any temporary or compiled files and then \texttt{make} to build a fresh set of binaries for your OS:

\begin{Verbatim}
/Users/john/Desktop/kerf-source> \typed{make clean}
find manual/ -type f -not -name '*.tex' | xargs rm
rm -f -r kerf kerf_test .//obj/*.o 
/Users/john/Desktop/kerf-source> \typed{make}
clang  -rdynamic -m64 -w -Os -c alter.c -o obj/alter.o

...

/Users/john/Desktop/kerf-source>
\end{Verbatim}

This process will produce a \texttt{kerf} executable in the source directory. You can then follow the steps described in the above section to place this in a directory accessible by other users or simply run it in place. Compiling from source will also produce a binary named \texttt{kerf\_test} which executes self-tests at startup and executes in debug mode, printing extra information when errors are encountered. The debug mode binary is particularly helpful when debugging dynamic libraries, as it can detect many types of memory leak at shutdown.

\subsection{Adding Kerf to your Path}

You may wish to add the Kerf binary to your PATH so that it can be accessed more easily. If you've placed the binary in the directory \texttt{/opt/kerf/}, edit \texttt{\textasciitilde/.profile} and add a line to initialize this setting.

\vspace{0.5cm}

If you're using \texttt{bash} (The default shell on OSX):
\begin{Verbatim}
export PATH=/opt/kerf/:\$PATH
\end{Verbatim}

If you're using \texttt{tcsh} or \texttt{csh} (The default shell in some Linux distros):
\begin{Verbatim}
set path = (\$path /opt/kerf)
\end{Verbatim}

Open a fresh terminal or type \texttt{source \textasciitilde/.profile} and you should now be able to invoke the \texttt{kerf} command from any directory.

\pagebreak
\subsection{Startup Scripts}

While working with Kerf, you may find yourself writing reusable utility routines. For example, here's a simple predicate which returns true if a timestamp falls on the current day, and then a function which filters lists based on this predicate:

\begin{Verbatim}
def today(s) \{
	t: ["year","month","day"]
	return match(now()[t], s[t])
\}

def on_today(v) \{
	return today filter v
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{on_today 2016.01.11 2016.01.12 2016.01.13}
  [2016.01.12]
\end{Verbatim}

If you use these routines often, you might want them to be automatically loaded when you open the Kerf REPL. Kerf will search for a file named \texttt{startup.kerf}, first in a directory given by the environment variable \texttt{KERF\_HOME}, then in a \texttt{.kerf} directory in the user's \texttt{HOME} directory, and finally in the current directory. Your startup script can in turn execute additional files by using \prim{load}.

\begin{Verbatim}
> \typed{cat ~/kerf_home/startup.kerf}

def calendar() \{
	out "\textbackslash{}n" implode shell "cal"
\}

out "Loaded custom startup script.\textbackslash{}n"

> \typed{export KERF_HOME=\$HOME/kerf_home/}
> \typed{echo \$KERF_HOME}
/Users/john/kerf_home/

> \typed{kerf -q}
Loaded custom startup script.

KeRF> \typed{calendar()}
    January 2016
Su Mo Tu We Th Fr Sa
                1  2
 3  4  5  6  7  8  9
10 11 12 13 14 15 16
17 18 19 20 21 22 23
24 25 26 27 28 29 30
31  
KeRF>
\end{Verbatim}
To set \texttt{KERF\_HOME} persistently, add an appropriate line to \texttt{.profile}, just as you did to add the \texttt{kerf} executable to your \texttt{PATH}.

\pagebreak
\section {Terminology}
Kerf uses terminology from databases, statistics and array-oriented programming languages like APL. This section will serve as a primer for concepts which may seem unfamiliar.

\subsection{Atomicity}
Atomicity describes the manner in which values are \emph{conformed} by particular functions.

\vspace{0.5cm}

A function which is not atomic will simply be applied to its arguments, behaving the same whether they are lists or atoms. \prim{enlist} is not atomic:
\begin{Verbatim}
KeRF> \typed{enlist 4}
  [4]
KeRF> \typed{enlist [1, 9, 8]}
  [[1, 9, 8]]
\end{Verbatim}

A unary function which is \emph{atomic} will completely decompose any nested lists in the argument, operate on each atom separately, and then reassemble these results to match the shape of the original argument. Another way to think of this is that atomic functions ``penetrate'' to the atoms of their arguments. \prim{not} is atomic:
\begin{Verbatim}
KeRF> \typed{not 1}
  0
KeRF> \typed{not [1, 0, 0, 1, 0]}
  [0, 1, 1, 0, 1]
KeRF> \typed{not [1, 0, [1, 0], [0, 1], 0]}
  [0, 1, [0, 1], [1, 0], 1]
\end{Verbatim}

Things get more interesting when dealing with \emph{fully atomic} binary functions. The shapes of the arguments do not have to be identical, but they must recursively \emph{conform}. Atoms conform with atoms. Lists conform with atoms and vice versa. Lists only conform with other lists if their lengths match and each successive pairing of their elements conforms. \prim{add} is fully atomic:

\begin{Verbatim}
KeRF> \typed{add(1, 2)}
  3
KeRF> \typed{add(1 3 5, 10)}
  [11, 13, 15]
KeRF> \typed{add(1 2 3, 4 5 6)}
  [5, 7, 9]

KeRF> \typed{add(1 2 3, 4 5)}
  add(1 2 3, 4 5)
  ^
 Length error
\end{Verbatim}

\pagebreak
\subsection{Combinators}
In the context of Kerf, a \emph{combinator} is an operator which controls how a \emph{function} is applied to \emph{values}. Combinators express abstract patterns which recur frequently in programming. For example, consider the following loop:

\begin{Verbatim}
function mysum(a) \{
	s: 0
	for(i: 0; i < len(a); i: i+1) \{ s: add(s, a[i]) \}
	return s
\}
\end{Verbatim}

We're iterating over the indices of the list \texttt{x} from left to right, accumulating a result into the variable \texttt{s}. On each iteration, we take the previous \texttt{s} and combine it with the current element of \texttt{a} via the function \prim{add}. This pattern is captured by the combinator \comb{fold}, which takes a function as a left argument and a list as a right argument:

\begin{Verbatim}
KeRF> \typed{add fold 37 15 4 8}
  64
\end{Verbatim}

Think of \comb{fold} as applying its function argument between the elements of its list argument:
\begin{Verbatim}
KeRF> \typed{(((37 add 15) add 4) add 8)}
  64
\end{Verbatim}

In this particular case we could have simply used the built-in function \prim{sum}, but \comb{fold} can be applied to any function- including functions you define yourself. Combinators are generally much more concise than writing explicit loops, and by virtue of having fewer ``moving parts'' avoid many classes of potential mistake entirely. If you use \comb{fold} it isn't possible to have an ``off-by-one'' index error accessing elements of the list argument and several useful base cases are handled automatically. Familiarize yourself with all of Kerf's combinators- with practice, you may find you hardly ever need to use \texttt{for}, \texttt{do} and \texttt{while} loops at all!

\vspace{0.5cm}

Kerf understands the patterns combinators express and can sometimes perform dramatic optimizations when they are used in particular combinations with built-in functions or data with specific properties:
\begin{Verbatim}
KeRF> \typed{timing(1);}
KeRF> \typed{max fold range 50000}
  49999
    0 ms
KeRF> \typed{\{[a,b] max(a, b)\} fold range 50000}
  49999
    3.2 s
\end{Verbatim}
The former example allows Kerf to recognize the opportunity for short-circuiting \prim{max} \comb{fold} because the result of \prim{range} is sorted. When \comb{fold}ing a user-declared lambda, it must construct and then reduce the entire list.

\pagebreak
\subsection{Matrix}
A \emph{matrix} is a \emph{vector} of \emph{vector}s of uniform length and type. For example, the following is a matrix:
\begin{Verbatim}
 [[1, 2, 3], 
  [4, 5, 6], 
  [7, 8, 9]]
\end{Verbatim}

But this is not a matrix, because the rows are not of uniform length:
\begin{Verbatim}
  [[1, 2], 
   [3, 4, 5, 6], 
   [7, 8, 9]]
\end{Verbatim}

\subsection{Truthy}
Kerf does not have a special ``boolean'' type for representing the values \emph{true} and \emph{false}. By convention, the values 1 and 0 are used in most cases- this is particularly helpful in combination with the \prim{which} operator:
\begin{Verbatim}
KeRF> \typed{[true, false, true, true]}
  [1, 0, 1, 1]
KeRF> \typed{which 1 0 1 1}
  [0, 2, 3]
\end{Verbatim}

In some situations, Kerf permits a broader range of values to behave like \texttt{true}, or \emph{truthy}. Values which behave like \texttt{false} are naturally \emph{falsey}. Any numeric zero or null is falsey, and any other value is considered truthy.
\begin{Verbatim}
KeRF> \typed{if (-5) \{ display "yep" \}}
"yep"
KeRF> \typed{if ([]) \{ display "yep" \}}
"yep"
KeRF> \typed{if (\{\}) \{ display "yep" \}}
"yep"
KeRF> \typed{if (NaN) \{ display "yep" \}}
"yep"
KeRF> \typed{if (0) \{ display "nope" \}}
KeRF> \typed{if (0.0) \{ display "nope" \}}
KeRF> \typed{if (null) \{ display "nope" \}}
\end{Verbatim}

Heavy reliance on truthiness can lead to very confusing code. Prefer 1 and 0, or the literals \texttt{true} and \texttt{false}, whenever possible.

\subsection{Valence}
A function's \emph{valence} is the number of arguments it takes. For example, \prim{add} is a \emph{binary function} which takes two arguments and thus has a valence of 2. \prim{not}, on the other hand, is a \emph{unary function} which takes a single argument and thus has a valence of 1. The term draws an analogy to linguistics and in turn chemistry, describing the way words and molecules form compounds.

\subsection{Vector}
A \emph{vector} is a list of elements with a uniform type. If a list contains more than one type of element it is sometimes referred to as a \emph{mixed-type list}. Vectors can store data more densely than mixed-type lists and as a result are often more efficient.

\pagebreak
\section {Datatypes}

\subsection{Numbers}
Kerf has two numeric types: \emph{integers} (or ``ints'') and \emph{floating-point numbers} (or ``floats''). The results of numeric operations between ints and floats will coerce to floats, and some operators always yield floating-point results.

\vspace{0.5cm}

Integers consist of a sequence of digits, optionally preceded by \texttt{+} or \texttt{-}. They are internally represented as 64-bit signed integers and thus have a range of $-(2^{63})$ to $2^{63}-1$.
\begin{Verbatim}
42
010
+976
-9000
\end{Verbatim}
Integers can additionally be one of the special values \texttt{INF}, \texttt{-INF} or \texttt{NAN}, used for capturing arithmetic overflow and invalid elements of an integer vector:
\begin{Verbatim}
KeRF> \typed{b: 10000000000000000000000000000000000000000}
  INF
KeRF> \typed{kerf_type_name b}
  "integer"
KeRF> \typed{1 2 3[-5]}
  NAN
\end{Verbatim}

\vspace{0.5cm}

Floats consist of a sequence of digits with an optional sign, decimal part and exponent. They are based on IEEE-754 double-precision 64-bit floats, and thus have a range of roughly $1.7*10^{\pm308}$.
\begin{Verbatim}
1.0
-379.8
-.2
.117e43
\end{Verbatim}
Floats can additionally be one of the special values \texttt{nan}, \texttt{-nan}, \texttt{inf} or \texttt{-inf}. \texttt{nan} has unusual properties in Kerf compared to most other languages. The behavior is intended to permit invalid results to propagate across calculations without disrupting other valid calculations:
\begin{Verbatim}
KeRF> \typed{nan == nan}
  1
KeRF> \typed{nan == -nan}
  1
KeRF> \typed{5/0}
  inf
KeRF> \typed{0/0}
  nan
KeRF> \typed{-1/0}
  -inf
\end{Verbatim}

Numeric values may be cast to integers or floats by using the built-in functions \prim{int} and \prim{float}, respectively. Strings can be parsed as numbers by the functions \primu{parse\_int}{parseInt} and \primu{parse\_float}{parseFloat}, or in other cases by simply using \prim{eval}.

\pagebreak
\subsection{Lists and Vectors}
Lists are ordered containers of heterogenous elements. Lists have several literal forms. A sequence of numbers separated by whitespace is a valid list. This is an ``APL-style'' literal:
\begin{Verbatim}
1 2 3 4
47 49
\end{Verbatim}
Alternatively, separate elements with commas (\texttt{,}) or semicolons (\texttt{;}) and enclose the list in square brackets for a more explicit ``JSON-style'' literal:
\begin{Verbatim}
[1, 2, 3]
[4;5;6]
[42]
\end{Verbatim}
This manual will use both styles throughout the examples. Naturally, these styles can be nested together. The following examples are equivalent:
\begin{Verbatim}
[1 2,3 4,5,6]
[[1, 2], [3, 4], 5, 6]
[[1;2], [3;4], 5, 6]
\end{Verbatim}

\vspace{0.5cm}

If a list consists entirely of items of the same type, it is a \emph{vector}. Vectors can be represented more compactly than mixed-type lists and thus are more cache-friendly and provide better performance. Kerf has special optimizations for vectors of timestamps, characters, floats and integers.

\vspace{0.5cm}

Vector and list types each have their own special symbol for emptiness:
\begin{Verbatim}
KeRF> \typed{0 take 1 2 3}
  INT[]
KeRF> \typed{0 take 1.0 2 3}
  FLOAT[]
KeRF> \typed{0 take "ABC"}
  ""
KeRF> \typed{0 take [now(),now()]}
  STAMP[]
KeRF> \typed{0 take [1,"A"]}
  []
\end{Verbatim}

\pagebreak
\subsection{Strings and Characters}
Kerf character literals begin with a backtick (\texttt{\`}) followed by double-quotes (\texttt{"}) or single-quotes (\texttt{\textquotesingle}) surrounding the character. Character literals which do not contain escape sequences may omit the quotation marks.
\begin{Verbatim}
\textasciigrave{}A
\textasciigrave{}\textquotesingle{}B\textquotesingle{}
\textasciigrave{}"C"
\end{Verbatim}
Kerf supports all JSON string escape sequences, and additionally an escape for single-quotes:
\begin{Verbatim}
\textasciigrave{}"\textbackslash{}""       \comment{// double quote}
\textasciigrave{}\textquotesingle{}\textbackslash{}\textquotesingle{}\textquotesingle{}       \comment{// single quote}
\textasciigrave{}"\textbackslash{}\textbackslash{}"       \comment{// reverse solidus}
\textasciigrave{}"\textbackslash{}/"       \comment{// solidus}
\textasciigrave{}"\textbackslash{}b"       \comment{// backspace}
\textasciigrave{}"\textbackslash{}f"       \comment{// formfeed}
\textasciigrave{}"\textbackslash{}n"       \comment{// newline}
\textasciigrave{}"\textbackslash{}r"       \comment{// carriage return}
\textasciigrave{}"\textbackslash{}t"       \comment{// horizontal tab}
\textasciigrave{}"\textbackslash{}u0043"   \comment{// 4-digit unicode literal}
\end{Verbatim}
The function \prim{char} can convert a number into an equivalent character, and \prim{int} will convert characters into numeric character codes:
\begin{Verbatim}
KeRF> \typed{char 65 66 67}
  "ABC"
KeRF> \typed{int "Text"}
  [84, 101, 120, 116]
\end{Verbatim}

Strings are lists of characters, and qualify as vectors. Strings are simply enclosed in double-quotes (\texttt{"}) or single-quotes (\texttt{\textquotesingle}).
\begin{Verbatim}
"Hello, World!"
\textquotesingle{}goodbye,\textbackslash{}ncruel world...\textquotesingle{}
\end{Verbatim}

Note that a single character in quotation marks is a \emph{string}, not a character literal:
\begin{Verbatim}
KeRF> \typed{kerf_type_name "A"}
  "character vector"
KeRF> \typed{"A" match \textasciigrave{}"A"}
  0
KeRF> \typed{first "A"}
  \textasciigrave{}"A"
\end{Verbatim}

When dealing with characters, spaces are considered null values:
\begin{Verbatim}
KeRF> \typed{isnull \textasciigrave{}" "}
  1
KeRF> \typed{(not isnull) filter "Text with  whitespace! "}
  "Textwithwhitespace!"
\end{Verbatim}

To assemble strings from other assorted datatypes, see \prim{format}.

\pagebreak
\subsection{Timestamps}
Timestamps, or simply ``stamps'', are a flexible datatype which can represent dates, times, or a complete date-time. Times are internally represented in UTC at \textbf{nanosecond granularity}.
\begin{Verbatim}
1997.07.16                \comment{// date only}
19:20:30                  \comment{// time only}
19:20:30.123              \comment{// time with milliseconds}
1997.07.16T19:20:30       \comment{// datetime}
1997.07.16T19:20:30.123   \comment{// datetime with milliseconds}
\end{Verbatim}
Timestamps can be compared using the same operators as numeric types. The function \primu{stamp\_diff}{stampDiff} should be used for calculating the interval between timestamps:
\begin{Verbatim}
KeRF> \typed{2015.04.02 < 2015.05.01}
  1
KeRF> \typed{stamp_diff(2015.05.03, 2015.05.01)}
  172800000000000
\end{Verbatim}

Kerf provides special literals for relative date-times:
\begin{Verbatim}
1y         \comment{// years}
10m        \comment{// months}
3d         \comment{// days}
1h         \comment{// hours}
2i         \comment{// minutes}
1s         \comment{// seconds}
\end{Verbatim}
These can also be combined as a single unit. For example,
\begin{Verbatim}
KeRF> \typed{2015.01.01 + 2m + 1d}
  2015.03.02
KeRF> \typed{2015.01.01 + 2m1d}
  2015.03.02
KeRF> \typed{2015.01.01 - 1h1i1s}
  2014.12.31T22:58:59.000
\end{Verbatim}
Indexing is overloaded for timestamps to permit easy extraction of fields. The \texttt{date} and \texttt{time} fields produce a stamp and other fields produce an integer:
\begin{Verbatim}
KeRF> \typed{d: now();}
KeRF> \typed{d["date"]}
  2016.01.06
KeRF> \typed{d[["date", "time"]]}
  [2016.01.06, 16:54:52.021]
KeRF> \typed{d[["year", "month", "week", "day", "hour", "minute", "second", "millisecond", "nanosecond"]]}
  [2016, 1, 2, 6, 16, 54, 52, 21, 21124000]
\end{Verbatim}

Strings can be converted to stamps by using \prim{eval}, and \prim{rep} or \prim{string} can reverse the process:
\begin{Verbatim}
KeRF> \typed{eval "2001.10.10"}
  2001.10.10
KeRF> \typed{rep 2001.10.10}
  "2001.10.10"
KeRF> \typed{string 2001.10.10}
  "2001.10.10T00:00:00.000"
\end{Verbatim}

It is also possible to use the \prim{stamp} function:
\begin{Verbatim}
KeRF> \typed{stamp ["2001.02.03", "1985.08.17"]}
  [2001.02.03, 1985.08.17]
\end{Verbatim}

For more flexibility, see \primu{parse\_stamp}{parseStamp} and \primu{format\_stamp}{formatStamp}. These functions support a superset of the parsing and formatting capabilities of the standard C \texttt{strftime()} and \texttt{strptime()} functions which can handle milliseconds or nanoseconds:
\begin{Verbatim}
KeRF> \typed{parse_stamp("\%S:\%M:\%H", "56:34:12")}
  12:34:56.000
KeRF> \typed{format_stamp("\%H:\%M:\%S.\%q", now())}
  "00:43:54.152979000"
\end{Verbatim}

Timestamps are currently valid through 2262.04.11, at which point we'll already have transitioned to 128-bit operating systems. Be sure to download the latest Kerf release when nearing the ``Year 2.262k Problem''.

\pagebreak
\subsection{Maps, Tables and Atlases}
A \emph{Map} is an associative data structure which binds \emph{keys} to \emph{values}. Kerf maps are a generalization of JSON objects. Map literals are enclosed in a pair of curly braces (\texttt{\{} and \texttt{\}}), and contain a series of comma delimited key-value pairs separated by a colon (\texttt{:}). JSON object syntax requires keys to be enclosed in double-quotes, but Kerf maps permit using single-quotes or bare identifiers. In any of these cases, the keys of the resulting map will be strings.
\begin{Verbatim}
\{"a": 10, "b": 20\}     \comment{// JSON style}
\{\textquotesingle{}a\textquotesingle{}: 10, \textquotesingle{}b\textquotesingle{}: 20\}     \comment{// optional single-quotes}
\{a: 10, b: 20\}         \comment{// bare identifiers}
\end{Verbatim}

\vspace{0.5cm}

A \emph{Table} is a map in which each value is a list of equal length. Tables are enclosed in two pairs of curly braces (\texttt{\{\{} and \texttt{\}\}}) and otherwise syntactically resemble maps. If non-list values are provided, they will be wrapped in lists. Values can also be omitted entirely to produce a table with empty columns.
\begin{Verbatim}
\{\{a: 1 2, b: 3 4\}\}     \comment{// columns contain [1,2] and [3,4]}
\{\{a: 1, b: 2\}\}         \comment{// columns contain [1] and [2]}
\{\{a, b\}\}               \comment{// columns contain [] and []}
\end{Verbatim}

If tables are serialized to JSON, Kerf will insert a key \texttt{is\_json\_table}- this permits tables to survive round-trip conversion:
\begin{Verbatim}
KeRF> \typed{json_from_kerf \{\{a: 1 2, b: 3 4\}\}}
  "\{\textbackslash{}"a\textbackslash{}":[1,2],\textbackslash{}"b\textbackslash{}":[3,4],\textbackslash{}"is_json_table\textbackslash{}":[1]\}"
\end{Verbatim}

The builtins \prim{xkeys} and \prim{xvals} can be used to extract a list of keys or values from a map or table. The builtin \prim{map} produces a map from a list of keys and a list of values, and \prim{table} works similarly for a list of column names and a rectangular array of values.
\begin{Verbatim}
KeRF> \typed{xkeys \{a: 10 11 12, b: 20 21\}}
  ["a", "b"]
KeRF> \typed{xvals \{\{a:1, b:2\}\}}
  [[1], [2]]
KeRF> \typed{map(["a","b"], [37, 99])}
  \{a:37, b:99\}
KeRF> \typed{table(["first","second"],[1 2, 3 4])}
┌─────┬──────┐
│first│second│
├─────┼──────┤
│    1│     3│
│    2│     4│
└─────┴──────┘
\end{Verbatim}

\primu{delete\_keys}{deleteKeys} can remove entries from maps or tables:
\begin{Verbatim}
KeRF> \typed{delete_keys(\{a:1, b:2, c:3\}, ["c"])}
  \{a:1, b:2\}
KeRF> \typed{delete_keys(\{\{a:1, b:2, c:3\}\}, ["b","a","b","x"])}
┌─┐
│c│
├─┤
│3│
└─┘
\end{Verbatim}

Many primitive operations penetrate to the values of maps and tables:
\begin{Verbatim}
KeRF> \typed{3 + \{a: 10, b: 20\}}
  {a:13, b:23}
KeRF> \typed{3 + \{\{a: 10, b: 20\}\}}
┌──┬──┐
│a │b │
├──┼──┤
│13│23│
└──┴──┘
\end{Verbatim}

Note that maps are treated by some built-in functions as atoms. For example, \prim{len} considers a map with any number of key-value associations to be of length 1. To obtain the number of associations in a map, use \prim{len} \prim{xvals} or \prim{len} \prim{xkeys}. If you're really desperate to save keystrokes you can use \texttt{|\^} (\prim{len} \prim{enumerate}).
\begin{Verbatim}
KeRF> \typed{len \{\}}
  1
KeRF> \typed{len \{a:2, quux:"a string"\}}
  1
KeRF> \typed{len xkeys \{\}}
  0
KeRF> \typed{len xkeys \{a:2, quux:"a string"\}}
  2
KeRF> \typed{|^\{a:1, b:2\}}
  2
\end{Verbatim}

If this behavior for maps is confusing, consider that with a table \prim{len} indicates the number of rows, rather than the number of columns. A map is behaving just like a table with a single row:
\begin{Verbatim}
KeRF> \typed{len \{\{a:0 1 2 3, b:4 5 6 7\}\}}
  4
KeRF> \typed{len \{\{a:0, b:4\}\}}
  1
\end{Verbatim}

\vspace{0.5cm}

An \emph{Atlas} behaves somewhat like a table with varying keys, for unstructured or semi-structured data. Atlases are sets of maps enclosed in one set curly braces with a square brace (\texttt{\{[} and \texttt{]\}}). Atlases can also be constructed from lists of maps using the atlas\(\) function. The Atlas type is to be used for unstructured or semi-structured data, for example, financial forms with varying columns. 

\begin{Verbatim}
KeRF> \typed{\{[\{a: 1, b: 3\},\{a: 3, c: 2\}]\}} \comment{// simple atlas}

KeRF> \typed{atlas([\{a:1,b:3\},\{a:3,c:2\}])}    \comment{// same atlas using atlas constructor}
     
KeRF> \typed{\{[\{a: 1, b: 2\},\{a:2,d:\{z:1,e:7\}\}]\}} \comment{// nested atlas}

\end{Verbatim}

\pagebreak

Atlases, unlike simple key-value stores, can be queried and aggregated in ways similar to tables, despite not having consistent columns. Aggregates or selected keys always return a table. Otherwise, an atlas is returned.

\begin{Verbatim}
KeRF> \typed{atla: atlas([\{a:1,b:2\},\{b:4,c:5\},\{a:3,b:3,d:9\}]);select avg(a) from atla}
┌───┐
│a  │
├───┤
│2.0│
└───┘

KeRF> \typed{select avg(b) from atla}
┌───┐
│b  │
├───┤
│3.0│
└───┘

KeRF> \typed{select from atla where b=4}
  atlas[\{b:4, c:5\}]

KeRF> \typed{select a,b from atla where b>2}
┌───┬─┐
│a  │b│
├───┼─┤
│NAN│4│
│  3│3│
└───┴─┘

\end{Verbatim}

Nested keys can also be accessed.

\begin{Verbatim}
KeRF> \typed{atla: \{[ \{a:1,b:2\}, \{b:4,c:5\}, \{b:\{d:6,e:7\}\} ]\} }
KeRF> \typed{select b.e from atla where b.d=6}
┌───┐
│b.e│
├───┤
│  7│
└───┘
\end{Verbatim}

Finally, group by is also supported

\begin{Verbatim}
KeRF> \typed{atla: \{[ \{c:10,b:4,a:1\}, \{b:4,c:10,a:2\}, \{c:11, b:5,a:3\} ]\}}
KeRF> \typed{select sum(a) from atla group by c where a>=2}
┌──┬─┐
│c │a│
├──┼─┤
│10│2│
│11│3│
└──┴─┘
\end{Verbatim}

\pagebreak
\subsection{Special Identifiers}
Kerf uses reserved words to identify a number of special values.

\vspace{0.5cm}

The words \texttt{true} and \texttt{false} are boolean literals, equivalent to 1 and 0, respectively:
\begin{Verbatim}
KeRF> \typed{true}
  1
KeRF> \typed{false}
  0
\end{Verbatim}

Inside a function, the words \texttt{self} or \texttt{this} may be used to refer to the current function. This is particularly useful for performing recursive calls in anonymous ``lambda'' functions:
\begin{Verbatim}
KeRF> \typed{def foo(x) \{ return [this, self, x] \}}
  \{[x] return [this, self, x]\}
KeRF> \typed{foo(9)}
  [\{[x] return [this, self, x]\}, \{[x] return [this, self, x]\}, 9]
\end{Verbatim}

The words \texttt{nil} or \texttt{null} may be used interchangeably to refer to a null value:
\begin{Verbatim}
KeRF> \typed{nil}
  
KeRF> \typed{null}

KeRF> \typed{kerf_type_name nil}
  "null"
KeRF> \typed{kerf_type_name null}
  "null"
\end{Verbatim}

The word \texttt{root} is a reference to Kerf's global scope. It contains all the variables which have been defined or referenced:
\begin{Verbatim}
KeRF> \typed{root}
  \{\}
KeRF> \typed{a: 24}
  24
KeRF> \typed{b}
 Undefined token error
KeRF> \typed{root}
  \{a:24\}
\end{Verbatim}

\pagebreak
\subsection{Index, Enum and Zip}
Indexes, Enumerations and Zips are special lists which perform internal bookkeeping to improve the performance of certain operations.

\vspace{0.5cm}

An \emph{Enumeration} performs \emph{interning}. It keeps only one reference to each object and stores appearances as fixed-width indices. It is useful for storing repetitions of strings and lists, which cannot otherwise efficiently be stored as vectors. In all other respects an Enumeration appears to be a list. To create an Enumeration, use \prim{hashed} or the unary \texttt{\#} operator:
\begin{Verbatim}
KeRF> \typed{a: hashed ["cherry", "peach", "cherry"]}
  #["cherry", "peach", "cherry"]
KeRF> \typed{kerf_type_name a}
  "enum"
\end{Verbatim}
Not only do Enumerations reduce the memory footprint of lists with a large number of repeated elements, they permit dramatically faster sorting. There is no benefit to making an Enumeration out of a vector of integers or floats.
\begin{Verbatim}
KeRF> \typed{samples: \{[x] rand(x, ["cherry", "peach", "zucchini"])\};}
KeRF> \typed{s1: samples(1000);}
KeRF> \typed{s2: samples(10000);}
KeRF> \typed{s3: samples(100000);}
KeRF> \typed{timing 1}
  1
KeRF> \typed{sort s1;}
    2 ms
KeRF> \typed{sort s2;}
    15 ms
KeRF> \typed{sort s3;}
    134 ms
KeRF> \typed{sort hashed s1;}
    0 ms
KeRF> \typed{sort hashed s2;}
    4 ms
KeRF> \typed{sort hashed s3;}
    28 ms
\end{Verbatim}

\vspace{0.5cm}

An \emph{Index} is a list augmented with a B-Tree. This permits more efficient lookups and range queries. Do not use an index for data that will always be sorted in ascending order- Kerf tracks sorted lists internally. To create an Index, use \prim{indexed} or the unary \texttt{=} operator:
\begin{Verbatim}
KeRF> \typed{b: indexed 3 9 0 7}
  =[3, 9, 0, 7]
KeRF> \typed{kerf_type_name b}
  "btree sort"
\end{Verbatim}

A \emph{Zip} is a list which is stored in memory in a compressed form, making it easier to work with large datasets. There are a number of specialized compressed list subtypes- see the discussion in \prim{compressed}.

\pagebreak
\subsection{Type Coercion}
Some operators can be applied to arguments of several distinct types. For example, \prim{add} accepts both integers and floats, and will work if given one of each as arguments:
\begin{Verbatim}
KeRF> \typed{1 add 2.5}
  3.5
\end{Verbatim}
In situations like these, the Kerf interpreter follows simple rules to \emph{coerce} arguments to different types and determine the appropriate return type.

\vspace{0.5cm}

In numeric operations, integer values will be converted to floats. For very large values this can lose some precision; 64-bit floats represent \emph{fewer} distinct values than 64-bit integers, distributed over a larger range:
\begin{Verbatim}
KeRF> \typed{1.0 + 100000000000000002}
  100000000000000000.0
\end{Verbatim}

Similarly, a float vector combined with an integer vector will promote the integer vector to a float vector and yield a float vector as a result:
\begin{Verbatim}
KeRF> \typed{kerf_type_name a:2.1 3.0 4.0}
  "float vector"
KeRF> \typed{kerf_type_name b:3 5 7}
  "integer vector"
KeRF> \typed{a+b}
  [5.1, 8, 11.0]
KeRF> \typed{kerf_type_name a+b}
  "float vector"
\end{Verbatim}

If you append an integer to a float vector, it remains a float vector. Appending a float to an integer vector promotes the result to a float vector:
\begin{Verbatim}
KeRF> \typed{kerf_type_name join(0.5 0.6, 3)}
  "float vector"
KeRF> \typed{kerf_type_name join(0.2, 5 6)}
  "float vector"
\end{Verbatim}

An empty list combined with a vector or vectorizable type (integers, floats, timestamps or characters) will always produce a vector:
\begin{Verbatim}
KeRF> \typed{kerf_type_name []}
  "list"
KeRF> \typed{kerf_type_name join([], 2)}
  "integer vector"
KeRF> \typed{kerf_type_name join([], 3.5 3.6)}
  "float vector"
\end{Verbatim}

\pagebreak

Lists \emph{may} automatically become vectors when modified to contain items of a uniform vectorizable type. The behavior of specific operators in this manner is an optimization, and may change with future revisions of Kerf. Try not to depend on this behavior, and avoid using mixed-type lists when you want the performance benefits of vectors:
\begin{Verbatim}
KeRF> \typed{kerf_type_name a: ["foo", 12, 3.5]}
  "list"
KeRF> \typed{a: drop(1, a)}
  [12, 3.5]
KeRF> \typed{kerf_type_name a}
  "float vector"
\end{Verbatim}

If you have a list which is known to only contain numeric values, you can \emph{explicitly} convert it to a vector by using the built-in functions \prim{int} or \prim{float}:
\begin{Verbatim}
KeRF> \typed{kerf_type_name a: xvals \{a:0.4, b:4\}}
  "list"
KeRF> \typed{int a}
  [0, 4]
KeRF> \typed{kerf_type_name int a}
  "integer vector"
KeRF> \typed{float a}
  [0.4, 4.0]
KeRF> \typed{kerf_type_name float a}
  "float vector"
\end{Verbatim}

When combining lists or vectors with indexes or enumerations, the properties of the left argument will be preserved. Kerf will never spontaneously promote vectors or lists to indexes or enumerations.
\begin{Verbatim}
KeRF> \typed{join(#["foo","bar"], ["quux"])}
  #["foo", "bar", "quux"]
KeRF> \typed{join(["quux"], #["foo", "bar"])}
  ["quux", "foo", "bar"]
KeRF> \typed{join(=[3,7,2,1], 4)}
  =[3, 7, 2, 1, 4]
KeRF> \typed{join(4, =[3,7,2,1])}
  [4, 3, 7, 2, 1]
\end{Verbatim}

\pagebreak
\section {Syntax}

\subsection{Expressions}
Calling (or \emph{applying}) a function in Kerf resembles most conventional languages- use the name of the function followed by a parenthesized, comma-separated list of arguments:
\begin{Verbatim}
KeRF> \typed{add(1, 2)}
  3
\end{Verbatim}

If a function takes exactly one argument, the parentheses are optional. We call this style ``prefix'' function application:
\begin{Verbatim}
KeRF> \typed{negate(3)}
  -3
KeRF> \typed{negate 3}
  -3
\end{Verbatim}

This syntax makes it easy to ``chain'' together a series of unary functions:
\begin{Verbatim}
KeRF> \typed{last sort unique "ALPHABETICAL"}
  \textasciigrave"T"
KeRF> \typed{last(sort(unique("ALPHABETICAL")))}
  \textasciigrave"T"
\end{Verbatim}

If a function takes no arguments, you must remember to include parentheses- otherwise the function will be returned as a value instead of called:
\begin{Verbatim}
KeRF> \typed{exit}
  exit
KeRF> \typed{exit()}
>
\end{Verbatim}

If a function takes exactly two arguments, it can be placed between the first and second argument as an ``infix'' operator:
\begin{Verbatim}
KeRF> \typed{1 add 2}
  3
\end{Verbatim}

Many of the most frequently used functions have symbolic aliases. For example, \texttt{+} can be used instead of \prim{add} and \texttt{*} can be used instead of \prim{times}. There is no functional difference between the spelled-out names for these functions and the symbols.
\begin{Verbatim}
KeRF> \typed{3 * 5}
  15
KeRF> \typed{times(3, 5)}
  15
KeRF> \typed{3 + 5}
  8
KeRF> \typed{3 plus 5}
  8
KeRF> \typed{plus(3, 5)}
  8
\end{Verbatim}

That said, note that the symbolic operators do not bind with parentheses in the same way as the textual operators. Here the parenthetical expression is \emph{not} evaluated as an argument, and so returns merely the last item in the expression, which is then operated on by the symbolic operator.
\begin{Verbatim}
KeRF> \typed{-(3, 5)}
  -5
\end{Verbatim}

Operators have uniform precedence in Kerf. Expressions are evaluated strictly from right to left unless explicitly grouped with parentheses:
\begin{Verbatim}
KeRF> \typed{3 * 4 + 1}
  15
KeRF> \typed{4 + 1 * 3}
  7
KeRF> \typed{(4 + 1) * 3}
  15
\end{Verbatim}

Kerf's flexible syntax often provides many alternatives for writing the same expression. Select the arrangement that you feel is most clear. Adding parentheses to confusing-seeming expressions never hurts!
\begin{Verbatim}
KeRF> \typed{0.5 * 3**2}
  4.5
KeRF> \typed{times(1/2, 3**2)}
  4.5
KeRF> \typed{divide(1, 2) * exp(3, 2)}
  4.5
KeRF> \typed{((1 / 2) * (3 ** 2))}
  4.5
\end{Verbatim}

\pagebreak
\begin{table}[h]
	\centering
	\rowcolors{1}{tableRowColor1}{tableRowColor2}
	\begin{tabular}{| c | l | l |}
		\hline
		\cellcolor{tableHeaderColor} Symbol &
		\cellcolor{tableHeaderColor} Unary Function &
		\cellcolor{tableHeaderColor} Binary Function \\
		
		\texttt{-}  & \prim{negate}           & \prim{minus}             \\
		\texttt{+}  & \prim{transpose}        & \prim{add}               \\
		\texttt{*}  & \prim{first}            & \prim{times}             \\
		\texttt{/}  & \prim{reverse}          & \prim{divide}            \\
		\texttt{|}  & \prim{len} (length)     & \prim{maxes}/\prim{or}   \\
		\texttt{\^} & \prim{enumerate}        & \prim{take}              \\
		\texttt{\%} & \prim{distinct}         & \prim{mod} (modulus)     \\
		\texttt{\&} & \prim{part} (partition) & \prim{mins}/\prim{and}   \\
		\texttt{?}  & \prim{which}            & \prim{rand} (random)     \\
		\texttt{\#} & \prim{hashed}           & \prim{join}              \\
		\texttt{!}  & \prim{not}              & \prim{map} (make map)    \\
		\texttt{\~} & \prim{atom} (is atom?)  & \prim{match}             \\
		\texttt{=}  & \prim{indexed}          & \prim{equals}            \\
		\texttt{<}  & \prim{ascend}           & \prim{less}              \\
		\texttt{>}  & \prim{descend}          & \prim{greater}           \\
		\texttt{\textbackslash} &             & \prim{lsq}               \\
		\texttt{<=} &                         & \prim{lesseq}            \\
		\texttt{>=} &                         & \prim{greatereq}         \\
		\texttt{==} &                         & \prim{equals}            \\
		\texttt{!=} &                         & \prim{noteq}             \\
		\texttt{<>} &                         & \prim{noteq}             \\
		\texttt{**} &                         & \prim{exp}               \\
		\texttt{\_} & \prim{floor}            &                          \\
		\texttt{.}  & \prim{eval} (evaluate)  &                          \\
		\texttt{:}  & \prim{ident} (identity) &                          \\

		\hline
	\end{tabular}
	\\ \bigskip Symbolic Aliases of Built-in Functions
\end{table}

\pagebreak
\subsection{Indexing}
Kerf has a uniform syntax for accessing elements of lists, maps and tables. Use square brackets to the right of a variable name or expression with an index or key to look up:
\begin{Verbatim}
KeRF> \typed{3 7 15[1]}
  7
KeRF> \typed{\{a: 24, b: 29\}["a"]}
  24
\end{Verbatim}

If the provided index or key does not exist, indexing will return an appropriate type-specific null value, as provided by the \primu{type\_null}{typeNull} built-in function:
\begin{Verbatim}
KeRF> \typed{3 7 15[9]}
  NAN
KeRF> \typed{3 7 15[-1]}
  NAN
KeRF> \typed{"ABC"[9]}
  \textasciigrave" "
\end{Verbatim}

Floating-point indices to lists will be truncated, for convenience:
\begin{Verbatim}
KeRF> \typed{3 7 15[0.5]}
  3
KeRF> \typed{3 7 15[1.6]}
  7
\end{Verbatim}

Indexing is right-atomic. If the indices are a list, the indexing operation will accumulate a list of results:
\begin{Verbatim}
KeRF> \typed{"ABC"[2 1 0 0 2 3 0 0 1]}
  "CBAAC AAB"
KeRF> \typed{34 19 55 32[0 1 0 1 2 2]}
  [34, 19, 34, 19, 55, 55]
\end{Verbatim}

One application of this type of collective indexing is the basis of \prim{sort}:
\begin{Verbatim}
KeRF> \typed{a: 27 15 9 55 0}
  [27, 15, 9, 55, 0]
KeRF> \typed{a[ascend a]}
  [0, 9, 15, 27, 55]
\end{Verbatim}

The shape of the result of indexing will always match the shape of the indices. Consider this example, where we index a list with a 2x2 matrix and get back a 2x2 matrix:
\begin{Verbatim}
KeRF> \typed{11 22 33 44[[0 1, 2 3]]}
  [[11, 22], 
   [33, 44]]
\end{Verbatim}

Indexing a particular element from a multidimensional structure requires several indexing operations:
\begin{Verbatim}
KeRF> \typed{[11 22, 33 44][0][1]}
  22
\end{Verbatim}

\pagebreak
\subsection{Assignment}
Kerf uses the colon (\texttt{:}) as an assignment operator, unlike the convention of ``\texttt{=}'' from many other programming languages. SQL uses \texttt{=} as a comparison operator, JSON uses \texttt{:} as an assignment operator in map literals and Kerf syntax attempts to be a superset of both JSON and SQL.

\vspace{0.5cm}

Values may be assigned to variables with \texttt{:} and retrieved by using the variable name:
\begin{Verbatim}
KeRF> \typed{a: 3 7 19}
  [3, 7, 19]
KeRF> \typed{a}
  [3, 7, 19]
KeRF> \typed{a[1]}
  7
\end{Verbatim}

Assignment may be combined with indexing to assign to specific cells of a list or keys of a map:
\begin{Verbatim}
KeRF> \typed{a: range 4}
  [0, 1, 2, 3]
KeRF> \typed{a[1]: 99}
  [0, 99, 2, 3]
KeRF> \typed{a}
  [0, 99, 2, 3]
KeRF> \typed{b: \{bravo: 3, tango: 6\};}
KeRF> \typed{b["bravo"]: 99}
  \{bravo:99, tango:6\}
\end{Verbatim}

Note Kerf's copy-on-write semantics:
\begin{Verbatim}
KeRF> \typed{a: 0 1 2 3;}
KeRF> \typed{b: a}
  [0, 1, 2, 3]
KeRF> \typed{b[1]:99}
  [0, 99, 2, 3]
KeRF> \typed{a}
  [0, 1, 2, 3]
\end{Verbatim}

As with indexing, it is possible to perform collective ``spread'' assignment:
\begin{Verbatim}
KeRF> \typed{a: 8 take 0}
  [0, 0, 0, 0, 0, 0, 0, 0]
KeRF> \typed{a[1 2 5]:99}
  [0, 99, 99, 0, 0, 99, 0, 0]
KeRF> \typed{b: 8 take 0}
  [0, 0, 0, 0, 0, 0, 0, 0]
KeRF> \typed{b[1 2 5]:11 22 33}
  [0, 11, 22, 0, 0, 33, 0, 0]
\end{Verbatim}

\pagebreak
It is also possible to perform compound assignment, treating \texttt{:} like a combinator which takes a binary function as a left argument and applies the old value and the right argument to this function before performing the assignment:
\begin{Verbatim}
KeRF> \typed{a: 0 0 0}
  [0, 0, 0]
KeRF> \typed{a#: 99}
  [0, 0, 0, 99]
KeRF> \typed{a join: 47}
  [0, 0, 0, 99, 47]
\end{Verbatim}

Ordinarily, referencing an uninitialized variable is an error. In some situations, including compound assignment, the variable will instead act as though initialized with an empty map. Try to avoid depending on this behavior:
\begin{Verbatim}
KeRF> \typed{x}
 Undefined token error
KeRF> \typed{x#:2}
  [\{\}, 2]
\end{Verbatim}

Compound assignment can be combined with indexing. Be warned, this can get confusing fairly quickly:
\begin{Verbatim}
KeRF> \typed{a: 0 0 0}
  [0, 0, 0]
KeRF> \typed{a[1]+:4}
  [0, 4, 0]
KeRF> \typed{a[0 2]+:1}
  [1, 4, 1]
KeRF> \typed{a[0 2]#:55}
  [[1, 55], 4, [1, 55]]
KeRF> \typed{a[0 2]#:3 4}
  [[1, 55, 3], 4, [1, 55, 4]]
\end{Verbatim}

To modify an element of a multidimensional structure, use multiple indexing expressions:
\begin{Verbatim}
KeRF> \typed{a:[11 22, 33 44]}
  [[11, 22], 
   [33, 44]]
KeRF> \typed{a[0][1]:99}
  [[11, 99], 
   [33, 44]]
KeRF> \typed{a[0 1][0]#:0}
  [[[11, 0], 99], 
   [[33, 0], 44]]
\end{Verbatim}

\pagebreak
\subsection{Control Structures}
Kerf has a familiar, simple set of general-purpose control structures. Parentheses and curly braces are \emph{never} optional for control structures.

\subsubsection{Conditionals}
Kerf has a C-style \texttt{if} statement with optional \texttt{else if} and \texttt{else} clauses. Like the C ternary operator (\texttt{?:}), Kerf \texttt{if} statements can be used as part of an expression. Each curly-bracketed clause returns the value of its last expression.
\begin{Verbatim}
KeRF> \typed{if (2 < 3) \{ 25 \} else \{ 32 \}}
  25
KeRF> \typed{if (2 > 3) \{ 25 \} else \{ 32 \}}
  32
\end{Verbatim}

In Kerf, newlines are statement separators. Conditional statements spread across multiple lines must adhere to a specific, consistent indentation style:
\begin{Verbatim}
if (a <  b) \{
	c : 100
\} else if (a == b) \{
	c : 200
\} else \{
	c : 400
\}
\end{Verbatim}

Multiline conditionals \emph{must not} be written with a newline before \texttt{else if} or \texttt{else} clauses.\\
Implied (and undesirable) statement separators are shown in \textcolor{red}{red}:
\begin{Verbatim}
if (a <  b) \{
	c : 100
\}\textcolor{red}{;}
else if (a == b) \{
	c : 200
\}\textcolor{red}{;}
else \{
	c : 400
\}
\end{Verbatim}

Another incorrect indentation style:
\begin{Verbatim}
if      (a <  b) \{ c : 100 \}\textcolor{red}{;}
else if (a == b) \{ c : 200 \}\textcolor{red}{;}
else             \{ c : 400 \}\textcolor{red}{;}
\end{Verbatim}

\pagebreak
\subsubsection{Loops}
Kerf provides a C-style \texttt{for} loop. The header consists of an initialization expression, a predicate and an updating expression. Note that the \texttt{for} loop itself returns null:
\begin{Verbatim}
KeRF> \typed{for (i: 0; i < 4; i: i+1) \{ display 2*i \}}
0
2
4
6
  
KeRF> 
\end{Verbatim}

Kerf also provides a C-style \texttt{while} loop. Note how in this example the loop returns its final calculation:
\begin{Verbatim}
KeRF> \typed{t: 500; while(t > 32) \{ display t; t: floor t/2 \}}
500
250
125
62
  31
  
KeRF>
\end{Verbatim}

If you simply want to repeat an expression a fixed number of times, use \texttt{do}:
\begin{Verbatim}
KeRF> \typed{do (3) \{ display 42; 43 \}}
42
42
42
  43

KeRF>
\end{Verbatim}

If it is necessary to prematurely exit a loop, break the loop into its own function and use \texttt{return}.

\vspace{0.5cm}

Combinators and built-in functions can be substituted for loops in many situations:
\begin{Verbatim}
KeRF> \typed{display mapdown range(0, 8, 2);}
0
2
4
6

KeRF> \typed{\{[t] t>32 \} \{[t] display t; floor t/2 \} converge 500}
500
250
125
62
  31

KeRF> \typed{display mapdown take(3, 42);}
42
42
42
\end{Verbatim}

\subsubsection{Function Declarations}
Functions can be declared using the \texttt{function} or \texttt{def} keywords and providing a parenthesized argument list. The final statement in a function body will be implicitly returned, and at any point in a function body you can instead use the \texttt{return} keyword to explicitly return.
\begin{Verbatim}
function is_even(n) \{
	return (n \% 2) == 0
\}

def divisible(a, b) \{
	return (a \% b) == 0
\}
\end{Verbatim}

\vspace{0.5cm}

It is also possible to define anonymous functions as part of an expression. Some languages refer to these as \emph{lambdas}, in reference to the lambda calculus, a formal model of computation based on the manipulation of anonymous functions. Anonymous functions are enclosed in curly brackets and may provide a square-bracketed (\texttt{[} and \texttt{]}) argument list:
\begin{Verbatim}
KeRF> \typed{\{[a, b] 2*a+b \}(3, 5)}
  16
\end{Verbatim}

Storing a lambda in a variable is precisely equivalent to defining a function with \texttt{function} or \texttt{def}.
\begin{Verbatim}
KeRF> \typed{divisible: \{[a, b] (a \% b) == 0 \}}
  \{[a, b] (a \% b) == 0\}
KeRF> \typed{divisible(6, 3)}
  1
KeRF> \typed{divisible(7, 2)}
  0
\end{Verbatim}

\vspace{0.5cm}

Kerf uses \emph{lexical scope}. This means that when variables are referenced, the \emph{definition textually closest} to the reference will be used:
\begin{Verbatim}
x: 35
function outer_1() \{
	x: 25
	function inner() \{
		return x
	\}
	return inner;
\}
function outer_2() \{
	x: 15
	l: outer_1()
	x: 45
	return l()
\}
display outer_2()
\end{Verbatim}
This example will print \texttt{25}, because \texttt{inner} captures the definition of \texttt{x} in \texttt{outer\_1} when it is created. The definitions of \texttt{x} in \texttt{outer\_2} are not used when this function is evaluated, nor is the top-level definition of \texttt{x}.


\pagebreak
\section{SQL}

Kerf understands SQL (Structured Queried Language), a popular programmatic interface for relational databases. You can blend SQL-style queries with imperative statements and access the full range of Kerf predicates and logical operators while filtering and selecting results.

\vspace{0.5cm}

SQL keywords are not case-sensitive, but for clarity the following examples will use uppercase exclusively. When describing the syntax of SQL statements, sections which can contain table names, field names or other types of subexpressions will be shown in \metasyn{bold}. If a section is optional, it will be enclosed in bold square brackets (\metasyn{[} and \metasyn{]}). For example:

\begin{Verbatim}
SELECT \metasyn{fields} \metasyn{[} AS \metasyn{name} \metasyn{]} FROM \metasyn{table} ...
\end{Verbatim}

\subsection{Scoping}
When the target of a write like \texttt{INSERT} or \texttt{UPDATE} is a variable name, the variable is resolved as if it were in the global scope, even when the statement occurs inside of a function. This is done for convenience: database code is typically written like this, and this is the most common use case. To use \texttt{INSERT} or \texttt{UPDATE} as if they were functional methods, either parenthesize your variable or wrap it in the \texttt{ident} function, then save the result into another local variable.

\begin{Verbatim}
insert into t values {b:4,c:5}      \comment{//t is affected in the global scope. no save necessary } 
t: insert into (t) values {b:4,c:5} \comment{//a copy of the local t is modified and saved, functionally} 
\end{Verbatim}

\pagebreak

\subsection{INSERT}

\texttt{INSERT} is the simplest type of SQL statement. It is used for creating or appending to tables. \texttt{INSERT} can perform single or bulk insertions, the latter of which is much more efficient.
\begin{Verbatim}
INSERT INTO \metasyn{table} VALUES \metasyn{data}
\end{Verbatim}

The value \metasyn{table} can be an object such as table literal, or it can be the name of a variable containing a table. In the latter case, the table will be modified in-place. The value \metasyn{data} can be a list, matrix, map or table.

\vspace{0.5cm}

%A single insertion can take values from a comma-separated, parenthesized list- this is special SQL syntax. 
%
%\begin{Verbatim}
%KeRF> \typed{INSERT INTO \{\{name, email, level\}\} VALUES ("bob", "b@ob.com", 7)}
%┌────┬────────┬─────┐
%│name│email   │level│
%├────┼────────┼─────┤
%│ bob│b@ob.com│    7│
%└────┴────────┴─────┘
%\end{Verbatim}

To insert a row, use an ordinary square-bracketed Kerf list. You can also use a map, which more explicitly shows column names in the source data. For bulk inserts, you can insert a table.

\begin{Verbatim}

KeRF> \typed{INSERT INTO \{\{name, email, level\}\} VALUES ["bob", "b@ob.com", 7]}
┌────┬────────┬─────┐
│name│email   │level│
├────┼────────┼─────┤
│ bob│b@ob.com│    7│
└────┴────────┴─────┘
KeRF> \typed{INSERT INTO \{\{name, email, level\}\} VALUES \{name: "bob", level: 7, email: "b@ob.com"\}}
┌────┬────────┬─────┐
│name│email   │level│
├────┼────────┼─────┤
│ bob│b@ob.com│    7│
└────┴────────┴─────┘
KeRF> \typed{INSERT INTO \{\{\}\} VALUES \{\{name:["bob","jim"], level:7 8, email:["b@ob.com","j@im.com"]\}\}}
┌────┬────────┬─────┐
│name│email   │level│
├────┼────────┼─────┤
│ bob│b@ob.com│    7│
│ jim│j@im.com│    8│
└────┴────────┴─────┘
\end{Verbatim}

\pagebreak

Note that a map which is to be inserted must have \emph{exactly} the same key set as the destination table:
\begin{Verbatim}
KeRF> \typed{INSERT INTO \{\{name, email, level\}\} VALUES \{name: "bob", level: 7\}}

  INSERT INTO \{\{name, email...
  ^
 Length error
KeRF> \typed{INSERT INTO \{\{name, email, level\}\} VALUES \{name: "bob", level: 7, hobbies: "needlepoint"\}}

  INSERT INTO \{\{name, email...
  ^
 Column error

\end{Verbatim}

The examples above show INSERT for creating tables. The more common use case involves inserting into an already existing table. For clarity sake:

\begin{Verbatim}
KeRF> \typed{t:\{\{a:1 2,b:3 4,c:99.9 10\}\}}

┌─┬─┬────┐
│a│b│c   │
├─┼─┼────┤
│1│3│99.9│
│2│4│10.0│
└─┴─┴────┘
KeRF> \typed{INSERT INTO t VALUES \{a:99, b:-10, c:1.1\}}
┌──┬───┬────┐
│a │b  │c   │
├──┼───┼────┤
│ 1│  3│99.9│
│ 2│  4│10.0│
│99│-10│ 1.1│
└──┴───┴────┘

KeRF> \typed{INSERT INTO t VALUES [[8,9],[44, 55],[82.1, -8.8]] }
┌──┬───┬────┐
│a │b  │c   │
├──┼───┼────┤
│ 1│  3│99.9│
│ 2│  4│10.0│
│99│-10│ 1.1│
│ 8│ 44│82.1│
│ 9│ 55│-8.8│
└──┴───┴────┘

\end{Verbatim}
\pagebreak
%Because the parenthetical notation inherited from SQL conflicts with the usual parenthetical notation of Kerf, we recommend saving complex values in intermediate variables to avoid confusion.

%\begin{Verbatim}
%KeRF> \typed{temp_var: (select * from employees)}  \comment{// This avoids using parentheses below }
%KeRF> \typed{INSERT INTO \{\{name, email, level\}\} VALUES temp_var}
%┌────┬────────┬─────┐
%│name│email   │level│
%├────┼────────┼─────┤
%│ bob│b@ob.com│    7│
%└────┴────────┴─────┘
%\end{Verbatim}

Bulk insertions require either a matrix or a table:
\begin{Verbatim}
KeRF> \typed{employees: [["bob","alice","jerry"]}
      \typed{            ["b@ob.com", "alice@gmail.com", "jerry@zombo.com"]}
      \typed{            [7, 9, 43]];}
KeRF> \typed{INSERT INTO \{\{name, email, level\}\} VALUES employees}
┌─────┬───────────────┬─────┐
│name │email          │level│
├─────┼───────────────┼─────┤
│  bob│       b@ob.com│    7│
│alice│alice@gmail.com│    9│
│jerry│jerry@zombo.com│   43│
└─────┴───────────────┴─────┘
\end{Verbatim}

An empty table will accept an \texttt{INSERT} from any map or table. List or matrix elements will be assigned default column names:
\begin{Verbatim}
KeRF> \typed{INSERT INTO \{\{\}\} VALUES \{legume: "Black Bean", dish: "Casserole"\}}
┌──────────┬─────────┐
│legume    │dish     │
├──────────┼─────────┤
│Black Bean│Casserole│
└──────────┴─────────┘
KeRF> \typed{INSERT INTO \{\{\}\} VALUES employees}
┌─────┬───────────────┬────┐
│col  │col1           │col2│
├─────┼───────────────┼────┤
│  bob│       b@ob.com│   7│
│alice│alice@gmail.com│   9│
│jerry│jerry@zombo.com│  43│
└─────┴───────────────┴────┘
\end{Verbatim}

\vspace{0.5cm}

\pagebreak
\subsection{DELETE}
\texttt{DELETE} is used for removing rows from a table. Kerf's columnar representation of tables means that a \texttt{DELETE} runs in linear time with respect to the number of rows in the table. Keep this in mind, and avoid repeated \texttt{DELETE}s over large (on-disk) datasets.
\begin{Verbatim}
DELETE FROM \metasyn{table} \metasyn{[} WHERE \metasyn{condition} \metasyn{]}
\end{Verbatim}

\metasyn{table} can be a table literal or the name of a variable containing a table. In the latter case, the table will be modified in-place. \metasyn{condition} can be any Kerf expression, using the names of columns from \metasyn{table} as variables. For more information about \texttt{WHERE}, see the discussion of \texttt{SELECT}.

\vspace{0.5cm}

If provided a reference to a table stored in a variable, \texttt{DELETE} will return the name of that variable. Otherwise, it will return the modified table itself:
\begin{Verbatim}
KeRF> \typed{t: \{\{a:range(5000), b:rand(5000, 100.0)\}\}}
┌─┬───────┐
│a│b      │
├─┼───────┤
│0│16.4771│
│1│27.3974│
│2│28.3558│
│3│12.2126│
│4│45.1148│
│5│81.5326│
│6│ 95.726│
│7│38.1769│
│.│     ..│
└─┴───────┘
KeRF> \typed{count t}
  5000
KeRF> \typed{DELETE FROM t WHERE b between [0, 50]}
  "t"
KeRF> \typed{count t}
  2474
KeRF> \typed{DELETE FROM \{\{a:range(10), b:rand(10, 100.0)\}\} WHERE (a\%2) = 1}
┌─┬───────┐
│a│b      │
├─┼───────┤
│0│75.3017│
│2│   67.3│
│4│19.4571│
│6│66.3412│
│8│ 66.116│
└─┴───────┘
\end{Verbatim}

As you might expect, if you don't use a \texttt{WHERE} clause, \texttt{DELETE} will remove all the rows of a table:
\begin{Verbatim}
KeRF> \typed{DELETE FROM t}
  "t"
KeRF> \typed{t}
┌─┬─┐
│a│b│
├─┼─┤
└─┴─┘
\end{Verbatim}

\pagebreak
\subsection{SELECT}\label{sec:select}
\texttt{SELECT} performs queries. It can be used to extract, aggregate or transform the contents of tables, producing new tables.
\begin{Verbatim}
SELECT \metasyn{fields} \metasyn{[} AS \metasyn{name} \metasyn{]} FROM \metasyn{table}
	\metasyn{[} WHERE \metasyn{condition} \metasyn{]}
	\metasyn{[} GROUP BY \metasyn{aggregate} \metasyn{]}
\end{Verbatim}

In its simplest form, \texttt{SELECT} can be used to slice a desired set of columns out of a table:
\begin{Verbatim}
KeRF> \typed{people}
┌────────────────┬───┬──────┬────────────────────┐
│name            │age│gender│job                 │
├────────────────┼───┼──────┼────────────────────┤
│Hamilton Butters│ 37│     M│             Janitor│
│       Emma Peel│ 29│     F│        Secret Agent│
│ Jacques Maloney│ 48│     M│Private Investigator│
│   Renee Smithee│ 31│     F│          Programmer│
│   Karen Milgram│ 16│     F│             Student│
│   Chuck Manwich│ 29│     M│             Janitor│
│ Steak Manhattan│ 18│     M│        Secret Agent│
│ Tricia McMillen│ 29│     F│       Mathematician│
└────────────────┴───┴──────┴────────────────────┘
KeRF> \typed{SELECT name, gender FROM people}
┌────────────────┬──────┐
│name            │gender│
├────────────────┼──────┤
│Hamilton Butters│     M│
│       Emma Peel│     F│
│ Jacques Maloney│     M│
│   Renee Smithee│     F│
│   Karen Milgram│     F│
│   Chuck Manwich│     M│
│ Steak Manhattan│     M│
│ Tricia McMillen│     F│
└────────────────┴──────┘
\end{Verbatim}

Selected columns can be renamed by specifying an \texttt{AS} clause for each:
\begin{Verbatim}
KeRF> \typed{SELECT age AS person_age, gender AS sex FROM people}
┌──────────┬───┐
│person_age│sex│
├──────────┼───┤
│        37│  M│
│        29│  F│
│        48│  M│
│        31│  F│
│        16│  F│
│        29│  M│
│        18│  M│
│        29│  F│
└──────────┴───┘
\end{Verbatim}

\pagebreak
\texttt{SELECT} can also be used to reorder, duplicate, or add columns:
\begin{Verbatim}
KeRF> \typed{SELECT gender, age, age AS years FROM people}
┌──────┬───┬─────┐
│gender│age│years│
├──────┼───┼─────┤
│     M│ 37│   37│
│     F│ 29│   29│
│     M│ 48│   48│
│     F│ 31│   31│
│     F│ 16│   16│
│     M│ 29│   29│
│     M│ 18│   18│
│     F│ 29│   29│
└──────┴───┴─────┘

KeRF> \typed{other: \{\{ b: range len people \}\}}
┌─┐
│b│
├─┤
│0│
│1│
│2│
│3│
│4│
│5│
│6│
│7│
└─┘

KeRF> \typed{SELECT other.b AS id, * FROM people}
┌──┬────────────────┬───┬──────┬────────────────────┐
│id│name            │age│gender│job                 │
├──┼────────────────┼───┼──────┼────────────────────┤
│ 0│Hamilton Butters│ 37│     M│             Janitor│
│ 1│       Emma Peel│ 29│     F│        Secret Agent│
│ 2│ Jacques Maloney│ 48│     M│Private Investigator│
│ 3│   Renee Smithee│ 31│     F│          Programmer│
│ 4│   Karen Milgram│ 16│     F│             Student│
│ 5│   Chuck Manwich│ 29│     M│             Janitor│
│ 6│ Steak Manhattan│ 18│     M│        Secret Agent│
│ 7│ Tricia McMillen│ 29│     F│       Mathematician│
└──┴────────────────┴───┴──────┴────────────────────┘
\end{Verbatim}

\pagebreak
The wildcard \texttt{*} can be used to refer to all columns in a table. It is also possible to use a variety of collective functions like \prim{count} or \prim{avg} when selecting columns. When calculated columns are not given a name explicitly via \texttt{AS}, a default name will be supplied.
\begin{Verbatim}
KeRF> \typed{SELECT count(*), sum(age), avg(age) AS average_age FROM people}
┌───┬───┬───────────┐
│col│age│average_age│
├───┼───┼───────────┤
│  8│237│     29.625│
└───┴───┴───────────┘
\end{Verbatim}

It is possible to reference user-defined functions in a \texttt{SELECT}, but if they are not atomic you may need to explicitly apply them to elements of a column using combinators:
\begin{Verbatim}
KeRF> \typed{revname: \{[x] p:explode(\textasciigrave" ",x); implode(", ", reverse p)\};}
KeRF> \typed{from_dogyears: \{[x] if (x < 21) \{ x/10.5 \} else \{ x/4 \}\};}
KeRF> \typed{SELECT revname mapdown name, from_dogyears mapdown age AS dog_age FROM people}
┌─────────────────┬───────┐
│name             │dog_age│
├─────────────────┼───────┤
│Butters, Hamilton│   9.25│
│       Peel, Emma│   7.25│
│ Maloney, Jacques│   12.0│
│   Smithee, Renee│   7.75│
│   Milgram, Karen│1.52381│
│   Manwich, Chuck│   7.25│
│ Manhattan, Steak│1.71429│
│ McMillen, Tricia│   7.25│
└─────────────────┴───────┘
\end{Verbatim}

When working with the results of a \texttt{SELECT} query, sometimes you don't actually want a table- you just want a single result. You can destructure tables explicitly with the primitives \prim{xkeys} and \prim{xvals}. Alternatively, use the more convenient context-senstive function \prim{extract}, which turns single-column tables into an appropriate atom or list:
\begin{Verbatim}
KeRF> \typed{SELECT min(age) FROM people}
┌───┐
│age│
├───┤
│ 16│
└───┘
KeRF> \typed{extract SELECT min(age) FROM people}
  16
\end{Verbatim}

\pagebreak
\subsubsection{WHERE}
The \texttt{WHERE} clause permits filtering of results. Only rows which adhere to the contraints given as the \metasyn{condition} will be returned:
\begin{Verbatim}
KeRF> \typed{SELECT * FROM people WHERE age > 30}
┌────────────────┬───┬──────┬────────────────────┐
│name            │age│gender│job                 │
├────────────────┼───┼──────┼────────────────────┤
│Hamilton Butters│ 37│     M│             Janitor│
│ Jacques Maloney│ 48│     M│Private Investigator│
│   Renee Smithee│ 31│     F│          Programmer│
└────────────────┴───┴──────┴────────────────────┘
\end{Verbatim}

You can form a \emph{conjunction} with several conditions by separating them with commas. Given a conjunction, the result is only selected if all conditions are satisfied. This is equivalent to performing a logical $AND$:
\begin{Verbatim}
KeRF> \typed{SELECT * FROM people WHERE gender = "M", age > 30}
┌────────────────┬───┬──────┬────────────────────┐
│name            │age│gender│job                 │
├────────────────┼───┼──────┼────────────────────┤
│Hamilton Butters│ 37│     M│             Janitor│
│ Jacques Maloney│ 48│     M│Private Investigator│
└────────────────┴───┴──────┴────────────────────┘
\end{Verbatim}

You can also form a conjuction by using the Kerf \prim{and} operator, but in this case you \emph{must} parenthesize subexpressions. Remember: Kerf evaluates expressions right to left unless otherwise parenthesized, so \texttt{a = b and c > d} is equivalent to \texttt{a = (b and (c > d))}:
\begin{Verbatim}
KeRF> \typed{SELECT * FROM people WHERE gender = "M" and age > 30}

   gender = "M" and age > 30
                ^
 Type error

KeRF> \typed{SELECT * FROM people WHERE (gender = "M") and (age > 30)}
┌────────────────┬───┬──────┬────────────────────┐
│name            │age│gender│job                 │
├────────────────┼───┼──────┼────────────────────┤
│Hamilton Butters│ 37│     M│             Janitor│
│ Jacques Maloney│ 48│     M│Private Investigator│
└────────────────┴───┴──────┴────────────────────┘
\end{Verbatim}

\pagebreak
\subsubsection{GROUP BY}
The \texttt{GROUP BY} clause can be used to gather together sets of rows which match on a particular column. 

%TEMPORARILY COMMENT OUT
%
%In its simplest form, it behaves somewhat like the built-in function \prim{part}. Note that the grouped-by column is included in the results:
%\begin{Verbatim}
%KeRF> \typed{SELECT name, age FROM people GROUP BY job}
%┌────────────────────┬─────────────────────────────────┬────────┐
%│job                 │name                             │age     │
%├────────────────────┼─────────────────────────────────┼────────┤
%│             Janitor│[Hamilton Butters, Chuck Manwich]│[37, 29]│
%│        Secret Agent│     [Emma Peel, Steak Manhattan]│[29, 18]│
%│Private Investigator│                [Jacques Maloney]│    [48]│
%│          Programmer│                  [Renee Smithee]│    [31]│
%│             Student│                  [Karen Milgram]│    [16]│
%│       Mathematician│                [Tricia McMillen]│    [29]│
%└────────────────────┴─────────────────────────────────┴────────┘
%\end{Verbatim}

You may often want to use collective functions to reduce each list of results:
\begin{Verbatim}
KeRF> \typed{SELECT count(name) AS num, avg(age) FROM people GROUP BY job}
┌────────────────────┬───┬────┐
│job                 │num│age │
├────────────────────┼───┼────┤
│             Janitor│  2│33.0│
│        Secret Agent│  2│23.5│
│Private Investigator│  1│48.0│
│          Programmer│  1│31.0│
│             Student│  1│16.0│
│       Mathematician│  1│29.0│
└────────────────────┴───┴────┘
\end{Verbatim}

\pagebreak
\subsection{UPDATE}
\texttt{UPDATE} modifies a table in-place, altering the values of some or all columns of rows which match a query.
\begin{Verbatim}
UPDATE \metasyn{table} SET \metasyn{assignments}
	\metasyn{[} WHERE \metasyn{condition} \metasyn{]}
	\metasyn{[} GROUP BY \metasyn{aggregate} \metasyn{]}
\end{Verbatim}

In its simplest form, \texttt{UPDATE} transforms or reassigns one or more of the columns of the table. The right side of each clause of \metasyn{assignments} can be any Kerf expression. Note that the \texttt{SET} clause can use the symbols \texttt{=} or \texttt{:} to represent assignment, for compatibility with familiar SQL engines. In practice, favor using \texttt{:} to avoid ambiguity.
\begin{Verbatim}
KeRF> \typed{UPDATE \{\{a:10 20 30\}\} SET a=a*2}
┌──┐
│a │
├──┤
│20│
│40│
│60│
└──┘
KeRF> \typed{UPDATE \{\{a:10 20, b: 40 50\}\} SET a:11+a, b=5}
┌──┬─┐
│a │b│
├──┼─┤
│21│5│
│31│5│
└──┴─┘
KeRF> \typed{UPDATE \{\{a:0 1 2, b: 3 4 5\}\} SET b:5}
┌─┬─┐
│a│b│
├─┼─┤
│0│5│
│1│5│
│2│5│
└─┴─┘
\end{Verbatim}

Assignments are carried out left to right:
\begin{Verbatim}
KeRF> \typed{UPDATE \{\{a:"First", b:"Second"\}\} SET a=b, b=a}
┌──────┬──────┐
│a     │b     │
├──────┼──────┤
│Second│Second│
└──────┴──────┘
\end{Verbatim}

\pagebreak
\subsubsection{WHERE}
An \texttt{UPDATE} can be restricted to only modify a specific subset of rows by using a \texttt{WHERE} clause, as in \texttt{SELECT}:
\begin{Verbatim}
KeRF> \typed{UPDATE \{\{a:0 1 2, b:7 3 7\}\} SET b=99 WHERE b=7}
┌─┬──┐
│a│b │
├─┼──┤
│0│99│
│1│ 3│
│2│99│
└─┴──┘
\end{Verbatim}

\subsubsection{GROUP BY}
\texttt{UPDATE} also supports the \texttt{GROUP BY} clause, operating on sets of rows which match on a particular column:
\begin{Verbatim}
KeRF> \typed{t: \{\{a: 0 1 2 3 4 5, b: 0 1 1 0 2 3, c: 0 0 0 0 0 0\}\};}
KeRF> \typed{UPDATE t SET c=count(b);}
KeRF> \typed{t}
┌─┬─┬─┐
│a│b│c│
├─┼─┼─┤
│0│0│6│
│1│1│6│
│2│1│6│
│3│0│6│
│4│2│6│
│5│2│6│
└─┴─┴─┘
KeRF> \typed{UPDATE t SET c=count(b) GROUP BY b;}
KeRF> \typed{t}
┌─┬─┬─┐
│a│b│c│
├─┼─┼─┤
│0│0│2│
│1│1│2│
│2│1│2│
│3│0│2│
│4│2│1│
│5│3│1│
└─┴─┴─┘
KeRF> \typed{UPDATE t SET c=enlist(a) GROUP BY b;}
KeRF> \typed{t}
┌─┬─┬──────┐
│a│b│c     │
├─┼─┼──────┤
│0│0│[0, 3]│
│1│1│[1, 2]│
│2│1│[1, 2]│
│3│0│[0, 3]│
│4│2│   [4]│
│5│3│   [5]│
└─┴─┴──────┘
\end{Verbatim}

\pagebreak
\texttt{UPDATE...GROUP BY} can also modify columns in place:
\begin{Verbatim}
KeRF> \typed{t: \{\{a: 99 99 37 99 37 479\}\};}
KeRF> \typed{UPDATE t SET a=count(a) GROUP BY a;}
KeRF> \typed{t}
┌─┐
│a│
├─┤
│3│
│3│
│2│
│3│
│2│
│1│
└─┘
\end{Verbatim}

%\pagebreak
%\subsubsection{LIMIT}
%The \texttt{LIMIT} clause restricts the returned table to a maximum of the first \metasyn{rows} rows of the result.
%\subsubsection{ORDER}
%
%\subsection{UPSERT}
%\texttt{UPSERT} modifies a table in-place, performing an \texttt{UPDATE} of existing rows or \texttt{INSERT}ing rows that don't already exist.
%\begin{Verbatim}
%?
%\end{Verbatim}
%{\color{red} \texttt{UPSERT} is a planned feature but not presently implemented in Kerf.}

\subsection{Joins}\label{sec:joins}
Kerf provides built-in functions \primu{left\_join}{leftJoin} and \primu{asof\_join}{asofJoin} which can be used to align and combine tables:
\begin{Verbatim}
KeRF> \typed{livesin}
┌────────────────┬───────────┐
│name            │nationality│
├────────────────┼───────────┤
│Hamilton Butters│        USA│
│       Emma Peel│         UK│
│ Jacques Maloney│     France│
│   Renee Smithee│     France│
│   Karen Milgram│        USA│
│   Chuck Manwich│     Canada│
│ Tricia McMillen│         UK│
└────────────────┴───────────┘
KeRF> \typed{SELECT name, age, nationality FROM left_join(people, livesin, "name")}
┌────────────────┬───┬───────────┐
│name            │age│nationality│
├────────────────┼───┼───────────┤
│Hamilton Butters│ 37│        USA│
│       Emma Peel│ 29│         UK│
│ Jacques Maloney│ 48│     France│
│   Renee Smithee│ 31│     France│
│   Karen Milgram│ 16│        USA│
│   Chuck Manwich│ 29│     Canada│
│ Steak Manhattan│ 18│       null│
│ Tricia McMillen│ 29│         UK│
└────────────────┴───┴───────────┘
\end{Verbatim}

\pagebreak
\subsubsection{Left Join}
A left join includes every row of the left table (\texttt{x}), and adds any additional columns from the right table (\texttt{y}) by matching on some key column (\texttt{z}). Added columns where there is no match on \texttt{z} will be filled with type-appropriate null values as generated by \primu{type\_null}{typeNull}.

\begin{Verbatim}
KeRF> \typed{t: \{\{a:1 2 2 3, b:10 20 30 40\}\}}
┌─┬──┐
│a│b │
├─┼──┤
│1│10│
│2│20│
│2│30│
│3│40│
└─┴──┘
KeRF> \typed{u: \{\{a:2 3, c:1.5 3\}\}}
┌─┬───┐
│a│c  │
├─┼───┤
│2│1.5│
│3│3.0│
└─┴───┘
KeRF> \typed{left_join(t, u, "a")}
┌─┬──┬───┐
│a│b │c  │
├─┼──┼───┤
│1│10│nan│
│2│20│1.5│
│2│30│1.5│
│3│40│3.0│
└─┴──┴───┘
\end{Verbatim}

If \texttt{z} is a list, require a match on several columns:
\begin{Verbatim}
KeRF> \typed{u: \{\{a:2 3, b:30 40, c:1.5 3\}\};}
KeRF> \typed{left_join(t, u, ["a","b"])}
┌─┬──┬───┐
│a│b │c  │
├─┼──┼───┤
│1│10│nan│
│2│20│nan│
│2│30│1.5│
│3│40│3.0│
└─┴──┴───┘
\end{Verbatim}

\pagebreak
If \texttt{z} is a map, associate columns from \texttt{x} as keys with columns from \texttt{y} as values, permitting joins across tables whose column names differ.
\begin{Verbatim}
KeRF> \typed{u: \{\{z:2 3, c:1.5 3\}\};}
KeRF> \typed{left_join(t, u, \{'a':'z'\})}
┌─┬──┬───┐
│a│b │c  │
├─┼──┼───┤
│1│10│nan│
│2│20│1.5│
│2│30│1.5│
│3│40│3.0│
└─┴──┴───┘
\end{Verbatim}

\subsubsection{Asof Join}

Behaves as \primu{left\_join}{leftJoin} for the first three arguments. The fourth argument is a string, list or map indicating columns which will match if the values in \texttt{y} are less than or equal to \texttt{x}. Often this operation is applied to timestamp columns, but it works for any other comparable column type.

\begin{Verbatim}
KeRF> \typed{t: \{\{a: 1 2 2 3, b: 10 20 30 40\}\}}
┌─┬──┐
│a│b │
├─┼──┤
│1│10│
│2│20│
│2│30│
│3│40│
└─┴──┘
KeRF> \typed{u: \{\{b: 19 17 32 8, c: ["A","B","C","D"]\}\}}
┌──┬─┐
│b │c│
├──┼─┤
│19│A│
│17│B│
│32│C│
│ 8│D│
└──┴─┘
KeRF> \typed{asof_join(t, u, [], "b")}
┌─┬──┬─┐
│a│b │c│
├─┼──┼─┤
│1│10│D│
│2│20│A│
│2│30│A│
│3│40│C│
└─┴──┴─┘
\end{Verbatim}

\pagebreak
\subsection{Limiting}
If you wish to retrieve the first $n$ items of a query, as in a SQL \texttt{LIMIT} clause, you can use \prim{first}:
\begin{Verbatim}
KeRF> \typed{first(2, SELECT name, age FROM people WHERE gender = "F")}
┌─────────────┬───┐
│name         │age│
├─────────────┼───┤
│    Emma Peel│ 29│
│Renee Smithee│ 31│
└─────────────┴───┘
\end{Verbatim}

But beware- if the result has fewer than $n$ rows, this approach will replicate them:
\begin{Verbatim}
KeRF> \typed{first(2, SELECT name, age FROM people WHERE name = "Emma Peel")}
┌─────────┬───┐
│name     │age│
├─────────┼───┤
│Emma Peel│ 29│
│Emma Peel│ 29│
└─────────┴───┘
\end{Verbatim}

A better approach is to define a new function which takes the minimum of $n$ and the length of the result:
\begin{Verbatim}
KeRF> \typed{limit_rows: \{[n, t] first(min(count t, n), t)\};}
KeRF> \typed{limit_rows(2, SELECT name, age FROM people WHERE name = "Emma Peel")}
┌─────────┬───┐
│name     │age│
├─────────┼───┤
│Emma Peel│ 29│
└─────────┴───┘
\end{Verbatim}

\subsection{Ordering}
If you wish to sort tables along a column, as in a SQL \texttt{ORDER BY} clause, you can use the built-in functions \prim{ascend} or \prim{descend} along with indexing:
\begin{Verbatim}
KeRF> \typed{people[ascend SELECT job FROM people]}
┌────────────────┬───┬──────┬────────────────────┐
│name            │age│gender│job                 │
├────────────────┼───┼──────┼────────────────────┤
│Hamilton Butters│ 37│     M│             Janitor│
│   Chuck Manwich│ 29│     M│             Janitor│
│ Tricia McMillen│ 29│     F│       Mathematician│
│ Jacques Maloney│ 48│     M│Private Investigator│
│   Renee Smithee│ 31│     F│          Programmer│
│       Emma Peel│ 29│     F│        Secret Agent│
│ Steak Manhattan│ 18│     M│        Secret Agent│
│   Karen Milgram│ 16│     F│             Student│
└────────────────┴───┴──────┴────────────────────┘
\end{Verbatim}

\pagebreak
\subsection{Performance}
\texttt{WHERE} clauses have a special understanding of certain Kerf verbs and can achieve significant performance boosts in the right circumstances.
\begin{Verbatim}
KeRF> \typed{n: 200000;}
KeRF> \typed{i: range(n);}
KeRF> \typed{v: rand(n, 100.0);}
KeRF> \typed{iv: indexed v;}
KeRF> \typed{find: \{[x] SELECT count(*) FROM \{\{i:i, v:x\}\} WHERE v < 23.7\};}

KeRF> \typed{timing 1;}
KeRF> \typed{find v;}
    15 ms
KeRF> \typed{find iv;}
    6 ms
\end{Verbatim}

For best results, order \texttt{WHERE} conjunctions to perform the largest reduction of data first, or take advantage of \prim{indexed} or \prim{enum} columns as early as possible:
\begin{Verbatim}
KeRF> \typed{n: 200000;}
KeRF> \typed{t: \{\{a: range(n), b: rand(n, 100.0), c: rand(n, 6)\}\}}
┌─┬───────┬─┐
│a│b      │c│
├─┼───────┼─┤
│0│ 82.268│2│
│1│80.5227│0│
│2│13.5797│1│
│3│80.2291│3│
│4│61.5329│3│
│5│67.2546│1│
│6│64.5684│5│
│7│29.7027│2│
│.│     ..│.│
└─┴───────┴─┘

KeRF> \typed{timing 1;}
KeRF> \typed{SELECT * FROM t WHERE b > 50, c = 1;}
    25 ms
KeRF> \typed{SELECT * FROM t WHERE c = 1, b > 50;}
    13 ms
KeRF> \typed{SELECT * FROM t WHERE (c = 1) and (b > 50);}
    14 ms
\end{Verbatim}

\pagebreak
\section {Input/Output}
Kerf provides a rich set of built-in IO functions for displaying, serializing, importing and exporting data. Beyond the capabilities described here, Kerf provides a general purpose foreign-function interface- see \hyperref[sec:ffi]{\textbf{FFI}}.

\subsection{General I/O}\label{sec:genio}

The function \prim{out}\texttt{(x)} will print a string \texttt{x} to standard output. Non-string values are ignored:
\begin{Verbatim}
KeRF> \typed{out "foo"}
foo
KeRF> \typed{out 65}
KeRF>
\end{Verbatim}

The function \prim{display}\texttt{(x)} will print a display representation of data to standard output. A key difference between calling this function from the REPL and using the REPL's natural value printing is that \prim{display} will print the entire result:

\begin{Verbatim}
KeRF> \typed{range 50}
  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37,
38, 39, 40, ...]
KeRF> \typed{display range 50}
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37,
38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49]
\end{Verbatim}

The function \prim{shell}\texttt{(x)} will execute a string \texttt{x} containing a shell command as if from \texttt{/bin/sh -c x} and return the lines of the result:

\begin{Verbatim}
KeRF> \typed{out implode("\textbackslash{}n", shell("cal"))}
   November 2015
Su Mo Tu We Th Fr Sa
 1  2  3  4  5  6  7
 8  9 10 11 12 13 14
15 16 17 18 19 20 21
22 23 24 25 26 27 28
29 30
KeRF> \typed{shell("echo Hello, World!")}
  ["Hello, World!"]
\end{Verbatim}

\pagebreak
\subsection{File I/O}\label{sec:fileio}
The function \primu{dir\_ls}{dirLs} lists the files and directories at a path. It can optionally provide full path names:
\begin{Verbatim}
KeRF> \typed{dir_ls("/Users/john/Sites")}
  [".DS_Store", ".localized", "images", "index.html", "subforum.php"]
KeRF> \typed{dir_ls("/Users/john/Sites", 1)}
  ["\textbackslash/Users\textbackslash/john\textbackslash/Sites\textbackslash/.DS_Store"
   "\textbackslash/Users\textbackslash/john\textbackslash/Sites\textbackslash/.localized"
   "\textbackslash/Users\textbackslash/john\textbackslash/Sites\textbackslash/images"
   "\textbackslash/Users\textbackslash/john\textbackslash/Sites\textbackslash/index.html"
   "\textbackslash/Users\textbackslash/john\textbackslash/Sites\textbackslash/subforum.php"]
\end{Verbatim}

The function \prim{lines}\texttt{(filename, n)} loads lines from a plain text file into a list of strings. The argument \texttt{n} is optional, and specifies the maximum number of lines to read.

\begin{Verbatim}
KeRF> \typed{lines("example.txt")}
  ["First line", "Second line", "Third line"]
KeRF> \typed{lines("example.txt", 2)}
  ["First line", "Second line"]
\end{Verbatim}

The function \primu{write\_text}{writeText}\texttt{(filename, x)} writes a raw string to a file, returning the number of bytes written. If \texttt{x} is not already a string it will be converted to one as by \primu{json\_from\_kerf}{jsonFromKerf}. To perform the inverse of \prim{lines}, use \primu{write\_text}{writeText}\texttt{(filename, \prim{implode}("\textbackslash{}n", x))}.

\begin{Verbatim}
KeRF> \typed{write_text("example.txt", 5)}
  1
KeRF> \typed{write_text("example.txt", 99)}
  2
KeRF> \typed{shell("cat example.txt")}
  ["99"]
\end{Verbatim}

Kerf has a proprietary binary serialization format. The function \primu{write\_to\_path}{writeToPath}\texttt{(filename)} writes a Kerf object to a file, creating it if necessary, and returns 0 if the operation was successful. Objects can then be reconstituted from binary files by calling \primu{read\_from\_path}{readFromPath}\texttt{(filename)}.

\begin{Verbatim}
KeRF> \typed{write_to_path("example.bin", 23 24 25)}
  0
KeRF> \typed{shell("wc -c example.bin")}
  ["      64 example.bin"]
KeRF> \typed{out implode("\textbackslash{}n", shell("hexdump example.bin"))}
0000000 06 90 00 fe 01 00 00 00 03 00 00 00 00 00 00 00
0000010 17 00 00 00 00 00 00 00 18 00 00 00 00 00 00 00
0000020 19 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000040
KeRF> \typed{read_from_path("example.bin")}
  [23, 24, 25]
\end{Verbatim}

Kerf also has built-in functions which make it easy to read and write common tabular data formats. \primu{read\_table\_from\_delimited\_file}{readTableFromDelimitedFile} loads data, \primu{write\_delimited\_file\_from\_table}{writeDelimitedFileFromTable} writes data, and several wrapper functions are available which read and write CSV or TSV files using this functionality.

\vspace{0.5cm}

Kerf can load data from text files with fixed-width columns with \primu{read\_table\_from\_fixed\_file}{readTableFromFixedFile}. See the built-in function reference discussion of this function for additional details.

\pagebreak

\subsection{Striped Files}\label{sec:stripeio}
Kerf is also capable of working with ``striped'' files. This serialization format writes each nested component of an object (the items of a list, or the columns of a table, for example) as a separate file within a directory structure. Striped files are more space-efficient for sparse structures, and permit significantly faster appends.

\vspace{0.5cm}

To create a striped file from an object, use \primu{write\_striped\_to\_path}{writeStripedToPath}\texttt{(path, x)}:
\begin{Verbatim}
KeRF> \typed{write_striped_to_path("stripe_example", \{\{a: 1 2 3, b: 4 5 6\}\});}
KeRF> \typed{out "\textbackslash{}n" implode shell "tree stripe_example"}
stripe_example
├── 2
│   ├── 0
│   │   └── base.dat
│   ├── 1
│   │   └── base.dat
│   └── base.dat
└── base.dat

3 directories, 4 files 
\end{Verbatim}

To load a striped file, use \primu{read\_striped\_from\_path}{readStripedFromPath}\texttt{(path)}:
\begin{Verbatim}
KeRF> \typed{read_striped_from_path("stripe_example")}
┌─┬─┐
│a│b│
├─┼─┤
│1│4│
│2│5│
│3│6│
└─┴─┘
\end{Verbatim}

For high-performance data storage, Kerf provides a set of alternatives to the ``\texttt{read\_table\_}''-prefixed methods which begin with ``\texttt{create\_table\_}'', like \primu{create\_table\_from\_csv}{createTableFromCsv}. Instead of simply reading a file into memory, these routines load data into a memory-mapped, disk-backed data structure, deleting any pre-existing destination file if necessary. These routines will use striped files preferentially, but also support conventional serialized Kerf objects. The \texttt{create\_table\_} functions allow you to work efficiently with large data files which may not fit in memory at once.

\vspace{0.5cm}

There are also a series of ``\texttt{append\_table\_}''-prefixed equivalents which, as you might expect, append data to any pre-existing destination file or create a new file if none exists.

\pagebreak
\subsection{Parceled tables}\label{sec:parcels}
A natural way of storing large amounts of time series data is parceling the data by day into separate subdirectories which are named by day. This allows for easier updates, backups and error recovery. Kerf provides a table type which logically connects the separate daily parcels. The requirements are that the subdirectories are named by the correct days. In the following example, we will create a small table with two days worth of data, create a directory in the /tmp directory, write out the tables with the data from the given days, then read the table in as a parceled table using \primu{read\_parceled\_from\_path}{readParceledFromPath}\texttt{(path)}:.

\begin{Verbatim}
KeRF> \typed{twodays: \{\{timedate: \{[x] 1999.01.01 + 8h*x \} mapright range(6), vals: range(6)\}\}}
┌───────────────────────┬────┐
│timedate               │vals│
├───────────────────────┼────┤
│             1999.01.01│   0│
│1999.01.01T08:00:00.000│   1│
│1999.01.01T16:00:00.000│   2│
│             1999.01.02│   3│
│1999.01.02T08:00:00.000│   4│
│1999.01.02T16:00:00.000│   5│
└───────────────────────┴────┘

KeRF> \typed{mkdir("/tmp/p");}
KeRF> \typed{write_striped_to_path("/tmp/p/1999.01.01",select * from twodays where timedate <1999.01.02);}
KeRF> \typed{write_striped_to_path("/tmp/p/1999.01.02",select * from twodays where timedate >=1999.01.02);}
KeRF> \typed{twoparcels: read_parceled_from_path("/tmp/p")};

\end{Verbatim}

Parceled tables automatically have a virtual ``date'' column.
\begin{Verbatim}
KeRF> \typed{select avg(vals) from twoparcels where date=1999.01.01}
┌────┐
│vals│
├────┤
│ 1.0│
└────┘
\end{Verbatim}

Parceled tables are distinct from standard tables, and this is reflected in the Kerf repl.
\begin{Verbatim}
KeRF> \typed{kerf_type_name twoparcels}
  "parceled table"
\end{Verbatim}

Since the parceling logically divides by day, there is an implied grouping by day.
\begin{Verbatim}
KeRF> \typed{select min(vals),min(timedate) from twoparcels}
┌────┬──────────┐
│vals│timedate  │
├────┼──────────┤
│   0│1999.01.01│
│   3│1999.01.02│
└────┴──────────┘
\end{Verbatim}

\pagebreak

\subsection{Network I/O (IPC)}\label{sec:netio}
Kerf has a specialized remote procedure call system built on TCP which permits distributing tasks across multiple processes or machines. This is sometimes described as Inter-Process Communication (IPC). To spawn a Kerf process which listens for IPC calls, invoke \texttt{kerf} with the \texttt{-p} command-line argument and specify a TCP port number:

\begin{Verbatim}
> \typed{./kerf -p 1234}
Kerf Server listening on port: 1234
KeRF>  
\end{Verbatim}

The function \primu{open\_socket}{openSocket}\texttt{(host, port)} opens a connection to a remote Kerf instance at hostname \texttt{host} and listening on \texttt{port} and returns a connection handle. Both \texttt{host} and \texttt{port} must be strings. Once opened, a connection handle may be closed via \primu{close\_socket}{closeSocket}\texttt{(handle)}.

\begin{Verbatim}
KeRF> \typed{open_socket("localhost", "1234")}
  4
\end{Verbatim}

The function \primu{send\_async}{sendAsync}\texttt{(handle, x)} will send a string \texttt{x} to a remote Kerf instance without waiting for a reply. \texttt{x} will be \prim{eval}ed on the remote server, returning 1 on a successful send.

\vspace{0.5cm}

The function \primu{send\_sync}{sendSync}\texttt{(handle, y)} will send a string \texttt{y} to a remote Kerf instance, waiting for a reply. \\\texttt{y} will be \prim{eval}ed on the remote server, and the result will be returned.

\begin{Verbatim}
KeRF> \typed{c: open_socket("localhost", "1234")}
  4
KeRF> \typed{send_async(c, "foo: 2+3")}
  1
KeRF> \typed{foo}
  \{\}
KeRF> \typed{send_sync(c, "[foo, foo]")}
  [5, 5]
KeRF> \typed{send_sync(c, "sum range 1000")}
  499500
\end{Verbatim}

Network IPC is automatically compressed if Kerf determines that will reduce transfer times. Compression and decompression takes places transparently on each end, so the user typically need not think about it. Kerf will not attempt to recompress already zipped items. It will also not attempt to zip small messages that would not benefit from compression, such as single atoms.

\vspace{0.5cm}

During IPC execution, the constant \const{.Net.client}{netClient} contains the current client's unique handle:
\begin{Verbatim}
KeRF> \typed{open_socket("localhost", "10101")}
  6
KeRF> \typed{send_sync(6, ".Net.client")}
  6
KeRF> \typed{.Net.client}
  0
\end{Verbatim}

\pagebreak
If defined, an IPC server will call the single-argument function \const{.Net.on\_close}{netOnClose} with a client handle when that client closes its connection:
\begin{Verbatim}
KeRF> \typed{.Net.on_close: \{[x] out 'client closed: ' join (string x) join '\textbackslash{}n'\};}
KeRF> 
server: new connection from 127.0.0.1 on socket 6
client closed: 6

\end{Verbatim}

\vspace{0.5cm}
Data can be sent to the foreign process using \primu{send\_sync}{sendSync} or \primu{send\_async}{sendAsync} when using these verbs with three arguments. Kerf assumes that the third argument is a list, so if a higher order construct is sent over, it must be payloaded as a list. Arguments are retrieved on the remote side with \texttt{\$1}.

\begin{Verbatim}
KeRF> \typed{c: open_socket("localhost", "1234")}
  4
KeRF> \typed{send_async(c, "foolist: $1",[range(10)])}
  1
KeRF> \typed{send_sync(c,"tbl:$1",[{{a:[1, 2 ,3],b:["a", "b", "c"]}}])}
┌─┬─┐
│a│b│
├─┼─┤
│1│a│
│2│b│
│3│c│
└─┴─┘

\end{Verbatim}
\pagebreak

\subsubsection{Starting an HTTP Server}

Starting Kerf with the command-line argument \texttt{-P 8080} will start Kerf with an HTTP server opened on the provided port, in this case 8080. The global variable \const{.Net.parse\_request}{netParseRequest} is pre-populated with a browser-compatible HTML response. This variable is a one-argument function and may be changed as desired.

\subsubsection{Backgrounding a Kerf Server}

We recommend the UNIX command  \texttt{screen} for backgrounding Kerf servers. It's possible to use \texttt{nohup} or some related form of daemonization, but this has the downside of closing \texttt{stdin}, which means that you cannot recover the ability to interact with Kerf via the terminal. The \texttt{screen} utility avoids this downside. The process will run in the background, even if you disconnect, and later on you can still type in the console.\\

Some helpful shell commands:
\begin{Verbatim}
#Try screen instead of nohup

#Installing screen
#if necessary, choose one
sudo yum -y install screen
sudo apt-get install screen
brew install screen
#and so on...

#start a screen session in the background with a Kerf server on port 1234
screen -dm ./kerf -p 1234

#Optional: bring the screen to foreground/terminal
screen -dRR

#Test with another client using the attached test script.
./kerf test-client.kerf

#This has the benefit of retaining STDIN to the server and the server output. (nohup kills stdin.)
\end{Verbatim}

\texttt{test-client.kerf}
\begin{Verbatim}
//open server: ./kerf -p 1234
//     client: ./kerf test-client.kerf 

s: open_socket("localhost","1234")
display send_async(s,"a:$1+1", [range 999])
display send_sync(s, "a:$1", [range 1e4])
\end{Verbatim}


\pagebreak
\section {Foreign Function Interface}\label{sec:ffi}
Kerf provides a Foreign Function Interface (FFI) which makes it possible to call out to C libraries from Kerf and call into Kerf from C. The FFI permits users to supplement Kerf with new IO capabilities, make use of pre-existing libraries and fine-tune high performance applications. In this section we will discuss how to use this facility and describe the data structures and the native API exposed by the Kerf executable.

\subsection{C from Kerf}

To compile a dynamic library for use with Kerf, you will need \texttt{kerf\_api.h}, which should be included with the Kerf binary and other documentation. This contains the signatures of exposed \texttt{kerf\_api\_} functions you can use in building dynamic libraries as well as a number of useful constants. If your C source code is stored in \texttt{example.c} and this header is in the current directory, compile it from the command line as follows:\\

For OSX:
\begin{Verbatim}
>cc -m64 -flat_namespace -undefined suppress -dynamiclib example.c -o example.dylib
\end{Verbatim}

The \texttt{-m64} option requests code be generated for a 64-bit architecture. The \texttt{-flat\_namespace} and \texttt{-undefined suppress} are necessary to create a dynamic library which can be linked against the Kerf binary at runtime- this is how your dynamic library can access built-in utility methods from the interpreter itself.  The \texttt{-o} option specifies a name for the output file, which we suffix with \texttt{.dylib} by convention.

\vspace{0.5cm}
For Linux:
\begin{Verbatim}
>cc -m64 -shared -fpic example.c -o example.dylib
\end{Verbatim}

Linux also requires \texttt{-m64}, but by contrast uses \texttt{-fpic} and \texttt{-shared} to build a shared library which can be dynamically linked to Kerf at runtime. While Linux generally uses \texttt{.so} rather than \texttt{.dylib} suffixes for shared objects, we will stick to the OSX naming convention for these examples for the sake of consistency. 

\vspace{0.5cm}

With this dynamic library compiled, the \prim{dlload} built-in function can be used to load the library and create a wrapper function for a specific function from the library which can then be invoked in Kerf as if it were an ordinary Kerf function. The Kerf FFI does not marshal Kerf's native data representations into C types- if another representation is desired you must close the gap in your code. This approach simplifies the FFI implementation and permits very efficient data exchange, but requires a great deal of care and attention from library authors.
\vspace{0.5cm}

\pagebreak

All values in Kerf are internally stored in \texttt{KERF} structures. This struct is what is called a \emph{tagged union}- some fields have different interpretations dependent on the value of a \emph{tag field}. In our case, the typecode field \texttt{t} permits this discrimination.

\begin{Verbatim}
typedef struct kerf0 \{
	char m;     \comment{// log_2 of memory slab size (internal use only)}
	char a;     \comment{// attribute flags}
	char h;     \comment{// log_2 of header subslice size (internal use only)}
	char t;     \comment{// typecode, as in kerf_type}
	int32_t r;  \comment{// reference count}
	
	union \{
		int64_t       i; \comment{// value of a Kerf integer or stamp}
		double        f; \comment{// value of a Kerf float}
		char          c; \comment{// value of a Kerf char}
		char*         s;
		struct kerf0* k;
		
		struct \{
			int64_t n;   \comment{// in a vector or list, the number of elements}
			char g[];    \comment{// in a vector or list, the elements themselves}
		\};
	\};
\} *KERF, KERF0;
\end{Verbatim}

Some of the fields of a \texttt{KERF} structure are for internal use by the interpreter and should not be manipulated directly in well-behaved dynamic libraries. The next section will describe the internal representation of various Kerf types in terms of \texttt{KERF} structures. Three fields are of general interest:

\begin{itemize}
	\item The \texttt{r} field contains a \emph{reference count} for the object. Examining this field explicitly is sometimes useful for debugging memory corruption problems. Your code should treat it as read-only.
	\item The \texttt{t} field indicates the object's \emph{typecode}, identical to the typecodes given by \primu{kerf\_type}{kerfType}. Negative values indicate vector types.
	\item The \texttt{a} field contains \emph{attribute flag} bits which provide the interpreter with metadata that alters the behavior of values or permits runtime optimizations.
\end{itemize}

Functions called from Kerf will always take some number of \texttt{KERF} structures as arguments and return a \texttt{KERF} structure. In the event that your function doesn't produce a meaningful return value, return 0- Kerf will coerce this into the equivalent of \texttt{null}.

\pagebreak
\subsection{Kerf from C}

It is easy to call Kerf methods from C. The Kerf binary is compiled using \texttt{-rdynamic},  which allows other binaries to load it directly as a shared library. This makes the regular Kerf binary similar to a \texttt{.so} shared object file. All of Kerf's symbols are exposed in this manner, although you should limit yourself to the methods beginning with \texttt{kerf\_api\_} as described in \texttt{kerf\_api.h}. The private Kerf symbols may change at any time. The methods exposed via the API are wrapped and guaranteed to be future-proof. 
\vspace{0.5cm}

When calling Kerf from C, remember to call \ffi{kerf\_api\_init}{kerfApiInit} to initialize the Kerf process if it has not already had a chance to initialize itself. Failure to do so may result in undefined behavior.

\vspace{0.5cm}

The following C source file \texttt{kerf\_from\_c.c} illustrates how to call the plain Kerf binary from a C executable. See the comments for compilation instructions. If you prefer, you can load each function individually by using \texttt{dlsym}, avoiding the need to suppress unresolved symbols as we do here for the sake of brevity:

\begin{Verbatim}
#include <dlfcn.h>
#include "kerf_api.h"

\comment{//OSX:   cc  -m64 -rdynamic -flat_namespace -undefined suppress kerf_from_c.c -o kerf_from_c}
\comment{//LINUX: cc  -m64 -rdynamic -fPIC -Wl,--unresolved-symbols=ignore-in-object-files}
\comment{//            kerf_from_c.c -o kerf_from_c -ldl}

int main() \{
	void *lib = dlopen("/full/path/to/kerf/binary", RTLD_NOW|RTLD_GLOBAL);
	if(!lib) printf ("A dynamic linking error occurred: (\%s){\textbackslash}n", dlerror());

	kerf_api_init(); \comment{// always call this first!}

	KERF s = kerf_api_new_int(33);
	kerf_api_show(s);
	kerf_api_release(s);

	KERF c = kerf_api_new_charvec("1+1");
	kerf_api_show(c);

	KERF k = kerf_api_interpret(c);
	kerf_api_show(k);
	kerf_api_release(k);

	return 0;
\}
\end{Verbatim}

\subsubsection{Kerf \texttt{.a} archive and \texttt{.o} object files}

Depending on your arrangement, you may be granted access to Kerf object files. These \texttt{.a} and \texttt{.o} files will similarly expose the Kerf methods, with the exception that they may be statically compiled into other binaries. In most cases this is unnecessary, as the regular \texttt{-rdynamic} Kerf binary will suffice.

\pagebreak
\subsection{Reference Counting}

Kerf manages dynamically allocated memory using a strategy called \emph{reference counting}. Each \texttt{KERF} object contains a counter of how many references to the object exist throughout the runtime. Whenever an object is used or stored, its reference count is incremented. When an object is no longer needed (perhaps a function using the object completes and returns) this count is decremented. When an object has a reference count of 0, the Kerf runtime knows that it is free to deallocate the object and reclaim the associated memory.

\vspace{0.5cm}

Reference counting is contrasted with \emph{garbage collection}, another popular method of managing dynamic memory. A garbage collector actively \emph{searches} for references to objects and automatically frees objects when they are no longer reachable. Garbage collectors remove the need to explicitly maintain reference counts, but generally incur runtime overhead for performing their heap scanning. Kerf uses reference counting because it has low runtime overhead and, by giving programmers more explicit awareness of memory management, permits more predictable runtime performance.

\vspace{0.5cm}

If the reference counts on an object are not maintained properly, a variety of bugs can occur. If references are not \emph{released} when an object is no longer needed, memory will \emph{leak}- it is no longer useful but cannot be reclaimed for other purposes. In long-running processes this can eventually exhaust system memory. If references are not \emph{retained} when an object is still needed, they can be deallocated out from under your code, allowing data to be overwritten and creating a variety of potential intermittent failures.

\vspace{0.5cm}

Some objects require special consideration. For efficiency purposes, Kerf will sometimes allocate objects which can be passed as arguments to your dynamic libraries on the \emph{stack} instead of its reference-counted \emph{heap}. Stack-allocated objects typically have a reference count of -1 and cannot be retained indefinitely without copying. These and other special cases mean that simply decrementing or incrementing the \texttt{r} field of a \texttt{KERF} object is not sufficient for controlling reference counts correctly. The Kerf native API exposes two functions- \ffi{kerf\_api\_release}{kerfApiRelease} and \ffi{kerf\_api\_retain}{kerfApiRetain}- for this purpose which perform all the necessary bookkeeping. Do \emph{not} directly modify the \texttt{r} field of \texttt{KERF} objects!

\subsubsection{Releasing}
As a general rule, if a \texttt{KERF} object is allocated in a function (as with any of the \ffi{kerf\_api\_new\_}{kerfApiNewCharvec} functions) it must either be returned from that function or released with \ffi{kerf\_api\_release}{kerfApiRelease} before the function returns. The following routine leaks a \texttt{KERF\_CHARVEC}. Can you see why?
\begin{Verbatim}
KERF leaky_demo(KERF monad) \{
	return kerf_api_call_monad(monad, kerf_api_new_charvec("Hello!"));
\}
\end{Verbatim}

A corrected version would be as follows:
\begin{Verbatim}
KERF leaky_demo(KERF monad) \{
	KERF string = kerf_api_new_charvec("Hello!");
	KERF result = kerf_api_call_monad(monad, string);
	kerf_api_release(string);
	return result;
\}
\end{Verbatim}
Any objects which were allocated inside \ffi{kerf\_api\_call\_monad}{kerfApiCallMonad} are the responsibility of that routine, and the result it returns can be freely returned from our routine. Objects passed \emph{into} our routine are the responsibility of the code which called our routine, and will be automatically deallocated unless we explicitly retain them. This idea of \emph{local responsibility} is the key to understanding reference counting.

\pagebreak
\subsubsection{Retaining}
In many situations, simply releasing objects you allocate is sufficient, but in some situations we need to explicitly retain an object to ensure it is not deallocated too soon. Consider this pass-through function which prints information about reference counts:

\begin{Verbatim}
KERF show_refcount(KERF x) \{
	printf("incoming reference count: \%d\textbackslash{}n", x->r);
	KERF result = kerf_api_retain(x);
	printf("outgoing reference count: \%d\textbackslash{}n", result->r);
	return result;
\}
\end{Verbatim}

The calling function which passed the arguments into our dynamic library function is responsible for discarding those arguments when our function returns. If we want to return a value that was originally passed to us as an argument, we must retain it to counteract this.

\begin{Verbatim}
KeRF> \typed{refcount: dlload("example.dylib", "show_refcount", 1);}
KeRF> \typed{refcount(5)}
incoming reference count: -1
outgoing reference count: 1
  5
KeRF> \typed{refcount([1,2,3])}
incoming reference count: 2
outgoing reference count: 3
  [1, 2, 3]
KeRF> \typed{a: 4 5 6;}
KeRF> \typed{refcount(a)}
incoming reference count: 3
outgoing reference count: 4
  [4, 5, 6]
\end{Verbatim}

In the first example above, the value was stack-allocated, and the call to \ffi{kerf\_api\_retain}{kerfApiRetain} copied this value to the heap, returning a pointer to the new object. \emph{Always} use the result of a call to \ffi{kerf\_api\_retain}{kerfApiRetain} instead of the original value.

\pagebreak
Retaining is also important if you want to stash a value for later use. Here's an example of some dynamic library functions which hang onto state:
\begin{Verbatim}
KERF stashed_value = 0;

KERF state_init(KERF value) \{
	stashed_value = kerf_api_retain(value);
	return 0;
\}
KERF state_double() \{
	KERF result = stashed_value;
	stashed_value = kerf_api_new_int((result->i) * 2);
	return result;
\}
KERF state_free(KERF value) \{
	kerf_api_release(stashed_value);
	stashed_value = 0;
	return 0;
\}
\end{Verbatim}
We retain the initial value passed in, since it would otherwise be destroyed when the function returns, as in the previous example. In subsequent calls to \texttt{state\_double}, we can return the stashed value, relinquishing control of it. The new value we construct each time has a reference count of 1 and can also be returned when the time comes. Freeing our stashed state is included for completeness.

\begin{Verbatim}
KeRF> \typed{init: dlload("example.dylib", "state_init", 1);}
KeRF> \typed{step: dlload("example.dylib", "state_double", 0);}
KeRF> \typed{free: dlload("example.dylib", "state_free", 0);}
KeRF> \typed{init(5);}
KeRF> \typed{step()}
  5
KeRF> \typed{step()}
  10
KeRF> \typed{step()}
  20
KeRF> \typed{free();}
\end{Verbatim}

\pagebreak
\subsection{Internal Representations}
To work with \texttt{KERF} structures, it is necessary to understand certain details of how they are represented. The implementation of some data structures, however, is kept intentionally opaque. Even dynamic libraries should not depend on distinguishing the internal structure of an enumeration or an index from a mixed-type list, for example. For low-level operations, \texttt{KERF} structures can be directly consulted, and for operations on higher-level datatypes the native API exposes helper functions.

\subsubsection{Integers}
Kerf Integers have a typecode of \texttt{KERF\_INT}, and store their values in the \texttt{i} field of a \texttt{KERF} structure as a signed 64-bit integer.

\subsubsection{Floats}
Kerf Floats have a typecode of \texttt{KERF\_FLOAT}, and store their values in the \texttt{f} field of a \texttt{KERF} structure as an IEEE-754 double-precision floating point number.

\subsubsection{Characters}
Kerf Characters have a typecode of \texttt{KERF\_CHAR}, and store their values in the \texttt{c} field of a \texttt{KERF} structure as UTF-8 characters.

\subsubsection{Stamps}
Kerf Timestamps have a typecode of \texttt{KERF\_STAMP}, and store their values in the \texttt{i} field of a \texttt{KERF} structure as a signed 64-bit count of nanoseconds since Unix Epoch.

\subsubsection{Vectors}
Vectors store their data in the \texttt{g} field of a \texttt{KERF} structure as a raw, packed array, and use the \texttt{n} field to indicate the number of elements they contain. Vectors are typically slab-allocated, and may contain extra allocated space beyond the item count given in \texttt{n}, but do not assume this will be the case. See \ffi{kerf\_api\_new\_kerf}{kerfApiNewKerf} for an example of how to create a vector from scratch.

\pagebreak
\subsection{Attribute Flags}
The \texttt{a} field of a \texttt{KERF} structure is an integer which represents a vector of single-bit \emph{flag} values. Each flag attached to a value represents a boolean piece of metadata which describes properties or configuration settings of the value. Kerf uses many attribute flags for internal bookkeeping, but a few of these flags represent information that could be generally useful for your dynamic libraries.

\vspace{0.5cm}

To test for the presence of a flag, bitwise AND the flag constant with the \texttt{a} field:
\begin{Verbatim}
int flag_is_set = ((x->a) & KERF_ATTR_Y) != 0;
\end{Verbatim}

To set a flag, bitwise OR the flag constant into the \texttt{a} field:
\begin{Verbatim}
(x->a) |= KERF_ATTR_Y;
\end{Verbatim}

To clear a flag, bitwise AND the \texttt{a} field with the bitwise complement of the flag constant. \\Think of it as ``keep everything \emph{except} this flag'':
\begin{Verbatim}
(x->a) &= ~KERF_ATTR_Y;
\end{Verbatim}

\vspace{0.5cm}

The \texttt{KERF\_ATTR\_SORTED} flag indicates that the elements of a vector or list is sorted in ascending order. The same information can be queried in Kerf using the \primu{sort\_debug}{sortDebug} built-in function.
\begin{Verbatim}
KERF is_sorted(KERF list) \{
	return kerf_api_new_int((list->a & KERF_ATTR_SORTED) != 0);
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{f: dlload("example.dylib", "is_sorted", 1);}
KeRF> \typed{f(1 2 3)}
  1
KeRF> \typed{f(3 1 2)}
  0
\end{Verbatim}

The \texttt{KERF\_ATTR\_BYTES} flag applies specifically to character vectors. If set, their contents will be pretty-printed as a series of hexadecimal bytes with a \texttt{0x} prefix instead of as characters.
\begin{Verbatim}
KERF demo_attr_bytes_set(KERF charvec) \{
	charvec = kerf_api_retain(charvec);   \comment{// returning a modified argument, must retain}
	charvec->a |= KERF_ATTR_BYTES;
	return charvec;
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{dlload("example.dylib", "is_sorted", 1)("ABCDE")}
  0x4142434445
\end{Verbatim}

\pagebreak
The \texttt{KERF\_ATTR\_DISK} flag indicates whether a value is located in disk-backed storage, and should be considered a read-only attribute. The same information is reflected in the \texttt{is\_disk} column of the results from \primu{meta\_table}{metaTable}.
\begin{Verbatim}
KERF demo_attr_disk_get(KERF x) \{
	return kerf_api_new_int((list->a & KERF_ATTR_DISK) != 0);
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{b: create_table_from_csv("breakfast.bin", "breakfast.csv", "SI", 1)}
┌───────────────┬────────┐
│Ingredient     │Quantity│
├───────────────┼────────┤
│          Bacon│       5│
│            Egg│       2│
│ English Muffin│       1│
│Bearnaise Sauce│       1│
└───────────────┴────────┘

KeRF> \typed{f: dlload("example.dylib", "demo_attr_disk_get", 1);}
KeRF> \typed{f b}
  1
KeRF> \typed{f \{\{foo: 1 2\}\}}
  0
\end{Verbatim}

\pagebreak
\subsection{Native API}
The signatures of the following methods are described in a machine-readable form in \texttt{kerf\_api.h}.

\ffidef{kerf\_api\_append}{Append to List}{kerfApiAppend}
\texttt{KERF kerf\_api\_append(KERF x, KERF y)}\\

Append an object \texttt{y} to the list {x}. If the original list can be referenced from elsewhere (if it is stored in a global, for example), you must retain it before appending. It is safe to call \ffi{kerf\_api\_append}{kerfApiAppend} on a list you construct yourself without any special work.
\begin{Verbatim}
KERF append_demo(KERF base) \{
	KERF tail = kerf_api_new_int(54);
	KERF list = kerf_api_append(kerf_api_retain(base), tail);
	kerf_api_release(tail);
	return list;
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{f: dlload("example.dylib", "append_demo", 1);}
KeRF> \typed{f([])}
  [54]
KeRF> \typed{f(1 2 3)}
  [1, 2, 3, 54]
KeRF> \typed{f(5)}
  [5, 54]
KeRF> \typed{a: 4 5 6;}
KeRF> \typed{f(a)}
  [4, 5, 6, 54]
KeRF> \typed{a}
  [4, 5, 6]
\end{Verbatim}
Note that the value stored in the global \texttt{a} \emph{was not modified}- we altered a copy.

\ffidef{kerf\_api\_call\_dyad}{Call Dyad}{kerfApiCallDyad}
\texttt{kerf\_api\_call\_dyad(KERF func, KERF x, KERF y)}\\

Call a dyadic (binary) function and return the result.
\begin{Verbatim}
KERF dyad_demo(KERF dyad) \{
	KERF a1  = kerf_api_new_int(3);
	KERF a2  = kerf_api_new_int(5);
	KERF ret = kerf_api_call_dyad(dyad, a1, a2);
	kerf_api_release(a1);
	kerf_api_release(a2);
	return ret;
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{dlload("example.dylib", "dyad_demo", 1)(\{[x,y] [x,y,x+y,x*y]\})}
  [3, 5, 8, 15]
\end{Verbatim}

\ffidef{kerf\_api\_call\_monad}{Call Monad}{kerfApiCallMonad}
\texttt{kerf\_api\_call\_monad(KERF func, KERF x)}\\

Call a monadic (unary) function and return the result.
\begin{Verbatim}
KERF monad_demo(KERF monad) \{
	KERF arg = kerf_api_new_int(17);
	KERF ret = kerf_api_call_monad(monad, arg);
	kerf_api_release(arg);
	return ret;
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{dlload("example.dylib", "monad_demo", 1)(\{[x] [x,0,2*x,x*x]\})}
  [17, 0, 34, 289]
\end{Verbatim}

\ffidef{kerf\_api\_call\_nilad}{Call Nilad}{kerfApiCallNilad}
\texttt{kerf\_api\_call\_nilad(KERF func)}\\

Call a niladic function (one which takes no arguments) and return the result.

\begin{Verbatim}
KERF nilad_demo(KERF nilad) \{
	KERF temp = kerf_api_call_nilad(nilad);
	kerf_api_show(temp);
	kerf_api_release(temp);
	return kerf_api_call_nilad(nilad);
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{a:[25]}
  [25]
KeRF> \typed{dlload("example.dylib", "nilad_demo", 1)(\{[] a[0]+:1; [3,2,a[0]]\})}
[3, 2, 26]     \comment{// printed by kerf_api_show}
  [3, 2, 27]   \comment{// returned}
\end{Verbatim}

\ffidef{kerf\_api\_copy\_on\_write}{Copy On Write}{kerfApiCopyOnWrite}
\texttt{KERF kerf\_api\_copy\_on\_write(KERF x)}\\

If \texttt{x} is referenced by multiple owners or stack-allocated, make a shallow copy and return this copy. Otherwise, it is safe to modify \texttt{x} in place. \ffi{kerf\_api\_copy\_on\_write}{kerfApiCopyOnWrite} may free the object passed in, so if you don't want the original destroyed it must be retained first.

\pagebreak
\ffidef{kerf\_api\_get}{Kerf Get}{kerfApiGet}
\texttt{KERF kerf\_api\_get(KERF x, KERF index)}\\

Index into the \texttt{KERF} list \texttt{x}. Equivalent to the normal Kerf expression \texttt{x[index]}.
\begin{Verbatim}
KERF get_demo(KERF list, KERF index) \{
	KERF zero  = kerf_api_new_int(0);
	KERF first = kerf_api_get(list, zero);
	kerf_api_show(first);
	kerf_api_release(zero);
	kerf_api_release(first);
	return kerf_api_get(list, index);
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{f: dlload("example.dylib", "get_demo", 2);}
KeRF> \typed{f("ABCD", 2)}
\textasciigrave"A"           \comment{// printed by kerf_api_show}
  \textasciigrave"C"         \comment{// returned}
KeRF> \typed{f(1 3 7 10, 2 0 2)}
1              \comment{// printed by kerf_api_show}
  [7, 1, 7]    \comment{// returned}
\end{Verbatim}

\ffidef{kerf\_api\_init}{Initialize the Kerf Process}{kerfApiInit}
\texttt{int kerf\_api\_init()}\\

Call this method at the beginning of any API interaction where Kerf is not the initiating process. This will ensure Kerf is initialized. Loading Kerf as a shared object from C (or any other language) will require \ffi{kerf\_api\_init}{kerfApiInit}. If Kerf launches on its own, then it will call this function internally, but it is still good practice to include the initialization in code loaded as dynamic libraries. There is no harm in calling the initialization multiple times, beyond wasted effort.

\pagebreak

\ffidef{kerf\_api\_interpret}{Interpret String}{kerfApiInterpret}
\texttt{KERF kerf\_api\_interpret(KERF charvec)}\\

Execute a \texttt{KERF\_CHARVEC} (string) as if via the function \prim{eval}.
\begin{Verbatim}
KERF interpret_demo() \{
	KERF s1 = kerf_api_new_charvec("a: 1+2");
	KERF s2 = kerf_api_new_charvec("2*range a");
	KERF r1 = kerf_api_interpret(s1);
	KERF r2 = kerf_api_interpret(s2);
	kerf_api_release(s1);
	kerf_api_release(s2);
	kerf_api_show(r1);
	kerf_api_show(r2);
	kerf_api_release(r1);
	kerf_api_release(r2);
	return 0;
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{dlload("example.dylib", "interpret_demo", 0)()}
3
[0, 2, 4]
\end{Verbatim}

\ffidef{kerf\_api\_len}{Kerf Length}{kerfApiLen}
\texttt{int64\_t kerf\_api\_len(KERF x)}\\

Determine the length of a \texttt{KERF} object \texttt{x}, as given by the function \prim{len}. This routine is more general than consulting the \texttt{n} field of a \texttt{KERF} structure, and will produce sensible results for non-vector types.
\begin{Verbatim}
KERF len_demo() \{
	KERF string = kerf_api_new_charvec("Hello, C!");
	KERF number = kerf_api_new_int(43);
	KERF list   = kerf_api_new_list();
	printf("\%d \%d \%d\textbackslash{}n",
		(int)kerf_api_len(string),
		(int)kerf_api_len(number),
		(int)kerf_api_len(list)
	);
	kerf_api_release(string);
	kerf_api_release(number);
	kerf_api_release(list);
	return 0;
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{dlload("example.dylib", "len_demo", 0)();}
9 1 0
\end{Verbatim}

\pagebreak
\ffidef{kerf\_api\_new\_charvec}{New Kerf String}{kerfApiNewCharvec}
\texttt{KERF kerf\_api\_new\_charvec(char* cstring)}\\

A wrapper for \ffi{kerf\_api\_new\_kerf}{kerfApiNewKerf} which allocates and initializes a \texttt{KERF\_CHARVEC} (string) from a null-terminated C string. The supplied string will be copied into the new vector; subsequent mutations will not propagate from one to the other.

\ffidef{kerf\_api\_new\_float}{New Kerf Float}{kerfApiNewFloat}
\texttt{KERF kerf\_api\_new\_float(double n)}\\

A wrapper for \ffi{kerf\_api\_new\_kerf}{kerfApiNewKerf} which allocates and initializes a single Kerf Float from an IEEE-754 double-precision floating point number \texttt{n}.

\ffidef{kerf\_api\_new\_int}{New Kerf Integer}{kerfApiNewInt}
\texttt{KERF kerf\_api\_new\_int(int64\_t n)}\\

A wrapper for \ffi{kerf\_api\_new\_kerf}{kerfApiNewKerf} which allocates and initializes a single Kerf Integer from a signed 64-bit C integer \texttt{n}.

\ffidef{kerf\_api\_new\_kerf}{New Kerf Object}{kerfApiNewKerf}
\texttt{KERF kerf\_api\_new\_kerf(char type, int64\_t length)}\\

Allocate a raw \texttt{KERF} structure with a given \texttt{type}. For scalar types like \texttt{KERF\_INT}, \texttt{length} should be 0. For vector types, \texttt{length} will be the number of entries the object will contain. This routine allocates space in Kerf's internal memory pool and initializes reference counts appropriately.

\begin{Verbatim}
KERF intvec_demo(KERF base, KERF count) \{
	KERF ret = kerf_api_new_kerf(KERF_INTVEC, count->i);
	for(int x = 0; x < count->i; x++) \{
		((int64_t*)(ret->g))[x] = (base->i) + x;
	\}
	return ret;
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{f: dlload("example.dylib", "intvec_demo", 2);}
KeRF> \typed{v: f(70000, 5)}
  [70000, 70001, 70002, 70003, 70004]
KeRF> \typed{kerf_type_name v}
  "integer vector"
\end{Verbatim}

\pagebreak
\ffidef{kerf\_api\_new\_list}{New Kerf List}{kerfApiNewList}
\texttt{KERF kerf\_api\_new\_list()}\\

Allocate an empty list. Useful in combination with \ffi{kerf\_api\_append}{kerfApiAppend}.
\begin{Verbatim}
KERF list_demo() \{
	return kerf_api_new_list();
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{v: dlload("example.dylib", "list_demo", 0)()}
  []
KeRF> \typed{kerf_type v}
  6
KeRF> \typed{kerf_type_name v}
  "list"
KeRF> \typed{len v}
  0
\end{Verbatim}

\ffidef{kerf\_api\_new\_map}{New Kerf Map}{kerfApiNewMap}
\texttt{KERF kerf\_api\_new\_map()}\\

Allocate an empty map.
\begin{Verbatim}
KERF map_demo() \{
	return kerf_api_new_map();
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{v: dlload("example.dylib", "map_demo", 0)()}
  {}
KeRF> \typed{kerf_type v}
  7
KeRF> \typed{kerf_type_name v}
  "map"
KeRF> \typed{len v}
  1
\end{Verbatim}

\pagebreak
\ffidef{kerf\_api\_new\_stamp}{New Kerf Timestamp}{kerfApiNewStamp}
\texttt{KERF kerf\_api\_new\_stamp(int64\_t nanoseconds)}\\

A wrapper for \ffi{kerf\_api\_new\_kerf()} which allocates and initializes a single Kerf Stamp from a signed 64-bit count of nanoseconds since Unix Epoch \texttt{n}.
\begin{Verbatim}
KERF stamp_demo(KERF ns) \{
	KERF epoch = kerf_api_new_stamp(0);
	kerf_api_show(epoch);
	kerf_api_release(epoch);
	return kerf_api_new_stamp(ns->i);
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{t: dlload("example.dylib", "stamp_demo", 1)(3000000)}
00:00:00.000    \comment{// printed by kerf_api_show}
  00:00:00.003  \comment{// returned}
KeRF> \typed{t[["year", "month", "day"]]}
  [1970, 1, 1]
\end{Verbatim}

\ffidef{kerf\_api\_nil}{Kerf Nil}{kerfApiNil}
\texttt{KERF kerf\_api\_nil()}\\

Allocate an object representing \texttt{nil}/\texttt{null}.
\begin{Verbatim}
KERF nil_demo() \{
	return kerf_api_nil();
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{v: dlload("example.dylib", "nil_demo", 0)();}
  
KeRF> \typed{kerf_type v}
  5
KeRF> \typed{kerf_type_name v}
  "null"
KeRF> \typed{len v}
  1
\end{Verbatim}

\ffidef{kerf\_api\_release}{Release Kerf Reference}{kerfApiRelease}
\texttt{void kerf\_api\_release(KERF x)}\\

Reduce the reference count for a \texttt{KERF} object. Any objects which are allocated in a dynamic library call and not returned or otherwise stored must be manually released, or they will not be reclaimed.

\ffidef{kerf\_api\_retain}{Retain Kerf Reference}{kerfApiRetain}
\texttt{KERF kerf\_api\_retain(KERF x)}\\

Increase the reference count for a \texttt{KERF} object. This process may require making a copy of the source object.

\ffidef{kerf\_api\_set}{Kerf Set}{kerfApiSet}
\texttt{KERF kerf\_api\_set(KERF x, KERF index, KERF replacement)}\\

Index into the \texttt{KERF} list \texttt{x} and replace the element with \texttt{replacement}, returning the modified list. Similar to the normal Kerf expression \texttt{x[index]:replacement}, but incapable of spread assignment. This operation will modify \texttt{x} in place.
\begin{Verbatim}
KERF set_demo(KERF list, KERF index, KERF rep) \{
	return kerf_api_set(kerf_api_retain(list), index, rep);
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{f: dlload("example.dylib", "set_demo", 3);}
KeRF> \typed{f(1 2 3, 1, 99)}
  [1, 99, 3]
\end{Verbatim}

\ffidef{kerf\_api\_show}{Show Kerf Object}{kerfApiShow}
\texttt{KERF kerf\_api\_show(KERF x)}\\

Print a prettyprinted representation of a \texttt{KERF} structure \texttt{x} to \texttt{stdout}, as displayed by the REPL, and return the structure unchanged. This routine primarily exists for debugging purposes.

\begin{Verbatim}
KERF show_demo(KERF argument) \{
	kerf_api_show(argument);
	KERF string = kerf_api_new_charvec("Hello, C!");
	kerf_api_show(string);
	kerf_api_release(string);
	return 0;
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{dlload("example.dylib", "show\_demo", 1)(1 2 3);}
[1, 2, 3]
"Hello, C!"
\end{Verbatim}


\vspace{0.5cm}

\pagebreak
\subsection{The Kerf IPC Protocol (KIP)}\label{sec:kipspec}

Another way for other languages to interoperate with Kerf is networked IPC. In this section we will provide a description of this protocol sufficient for writing connectors in another language of your choice. Example libraries in C, Python and Java are available on the Kerf website or by request, and \hyperref[sec:pythonkip]{\textbf{Kerf IPC with Python}} provides a step-by-step explanation of building such a connector. See \hyperref[sec:netio]{\textbf{Network I/O}} for additional information.

\vspace{0.5cm}

The Kerf IPC protocol (referred to hereafter as KIP for the sake of brevity) uses TCP as its transport layer. Individual messages consist of a \emph{header} followed by a \emph{payload}. The header contains information about the type of message and its size. The payload can take several forms, depending on message type. The entire message is 0-padded to an even power of two, which helps avoid memory fragmentation in low-level impementations of the protocol and makes a raw \texttt{memcpy()} of the message safe. 

\vspace{0.5cm}

To execute code on a remote Kerf instance it must be started with the \texttt{-p} flag. Your application can then open a TCP connection, transmit a message and wait for a response. Note that if the TCP connection is closed before the response has been transmitted, any in-progress execution on the remote Kerf instance will be aborted. After you receive a response you may send another message or close the connection. 

\vspace{0.5cm}

The binary representation of serialized Kerf data structures is beyond the scope of this document and highly subject to change in future revisions of the language, but it is also possible to send a payload as a UTF-8 encoded JSON string. We will describe this mode of operation in detail. Note that when transmitting JSON data a message is restricted to roughly 4 gigabytes, but this limitation is not present for other message types. If transmission of bulk data is a limiting factor in your application, consider using a pair of communicating Kerf processes rather than a custom connector.

\vspace{0.5cm}

The structure and content of the header may change slightly in future versions of Kerf, so this document will focus only on the most essential fields.

\begin{table}[h]
	\centering
	\rowcolors{1}{tableRowColor2}{tableRowColor2}
	\begin{tabular}{| m{3.0cm} | m{3.0cm} | m{3.0cm} | m{3.0cm} |}
		\hline
			\cellcolor{tableHeaderColor} 8 bits &
			\cellcolor{tableHeaderColor} 8 bits &
			\cellcolor{tableHeaderColor} 8 bits &
			\cellcolor{tableHeaderColor} 8 bits \\
		\hline
			\cellcolor{tableRowColor1} 0x00 &
			\cellcolor{tableRowColor1} 0x00 &
			\cellcolor{tableRowColor1} 0x00 &
			\cellcolor{tableRowColor1} 0x00 \\
		\hline
			Execution Type &
			Response Type &
			Display Type &
			\cellcolor{tableRowColor1} 0x00 \\
		\hline
			\cellcolor{tableRowColor1} 0x00 &
			\cellcolor{tableRowColor1} 0x00 &
			\cellcolor{tableRowColor1} 0x00 &
			\cellcolor{tableRowColor1} 0x00 \\
		\hline
			\multicolumn{4}{| c |}{Wire Size} \\
		\hline
			Shard Size &
			\cellcolor{tableRowColor1} 0x00 &
			\cellcolor{tableRowColor1} 0x00 &
			\cellcolor{tableRowColor1} 0xFF \\
		\hline
			\cellcolor{tableRowColor1} 0x01 &
			\cellcolor{tableRowColor1} 0x00 &
			\cellcolor{tableRowColor1} 0x00 &
			\cellcolor{tableRowColor1} 0x00 \\
		\hline
			\multicolumn{4}{| c |}{Payload Size} \\
		\hline
			\cellcolor{tableRowColor1} 0x00 &
			\cellcolor{tableRowColor1} 0x00 &
			\cellcolor{tableRowColor1} 0x00 &
			\cellcolor{tableRowColor1} 0x00 \\
		\hline
	\end{tabular}
	\\ \bigskip KIP Header Structure
\end{table}

\subsubsection{Execution Type}
An 8-bit signed integer indicating how a message should be executed by the recipient. For our purposes, this will always be 4, which indicates the payload is a JSON-encoded string.

\subsubsection{Response Type}
An 8-bit signed integer indicating the way the response should be formatted. 0 indicates no response is desired, 1 requests the complete JSON-encoded response.

\subsubsection{Display Type}
An 8-bit signed integer indicating how the Kerf process should display incoming messages, if at all. 0 indicates nothing should be printed when a message comes in, 1 indicates the incoming message content should be printed, 2 indicates the result of executing a message should be printed and 3 indicates that both should be printed. 3 is useful for debugging, but 0 or 1 may be most desirable in real applications.

\subsubsection{Wire Size}
A 32-bit unsigned integer in network byte order (big-endian) indicating the size, in bytes, of the payload plus 16. Note that this value is precisely the same as \texttt{pow(2, shard size)}.

\subsubsection{Shard Size}
An 8-bit signed integer indicating the $log_{2}$ of the length of the payload in bytes plus 16.

\subsubsection{Payload Size}
A 32-bit unsigned integer in native byte order (little-endian) indicating the size, in bytes, of the payload. The wire size will always exceed this size, and after the header and payload the remainder of a message will be 0-padded.

\pagebreak
\section {Built-In Function Reference}

\primdef{abs}{Absolute Value}
\texttt{abs(x)}\\

Calculate the absolute value of \texttt{x}. Atomic.
\begin{Verbatim}
KeRF> \typed{abs -4 7 -2.19 NaN}
  [4, 7, 2.19, nan]
\end{Verbatim}

\primdef{acos}{Arc Cosine}
\texttt{acos(x)}\\

Calculate the arc cosine (inverse cosine) of \texttt{x}, expressed in radians, within the interval [-1,1]. Atomic. The results of \texttt{acos} will always be floating point values.
\begin{Verbatim}
KeRF> \typed{acos 0.5 -0.2 1}
  [1.0472, 1.77215, 0]
KeRF> \typed{cos(acos 0.5 -0.2 1 4)}
  [0.5, -0.2, 1, nan]
\end{Verbatim}

\primdef{add}{Add}
\texttt{add(x, y)}\\

Calculate the sum of \texttt{x} and \texttt{y}. Fully atomic.
\begin{Verbatim}
KeRF> \typed{add(3, 5)}
  8
KeRF> \typed{add(3, 9 15 -7)}
  [12, 18, -4]
KeRF> \typed{add(9 15 -7, 3)}
  [12, 18, -4]
KeRF> \typed{add(9 15 -7, 1 3 5)}
  [10, 18, -2]
\end{Verbatim}

The symbol \texttt{+} is equivalent to \prim{add} when used as a binary operator:
\begin{Verbatim}
KeRF> \typed{2 4 3+9}
  [11, 13, 12]
\end{Verbatim}

\primdef{and}{Logical AND}
\texttt{and(x, y)}\\

Calculate the logical \emph{AND} of \texttt{x} and \texttt{y}. This operation is equivalent to the function \prim{min}. Fully atomic.
\begin{Verbatim}
KeRF> \typed{and(1 1 0 0, 1 0 1 0)}
  [1, 0, 0, 0]
KeRF> \typed{and(1 2 3 4, 0 -4 9 0)}
  [0, -4, 3, 0]
\end{Verbatim}

The symbol \texttt{\&} is equivalent to \prim{and} when used as a binary operator:
\begin{Verbatim}
KeRF> \typed{1 1 0 0 & 1 0 1 0}
  [1, 0, 0, 0]
\end{Verbatim}

\primdefu{append\_table\_from\_csv}{Append Table From CSV File}{appendTableFromCsv}
\texttt{append\_table\_from\_csv(tableFile, csvFile, fields, n)}\\

Equivalent to \primu{create\_table\_from\_csv}{createTableFromCsv} which appends to any pre-existing file instead of overwriting.

\primdefu{append\_table\_from\_fixed\_file}{Append Table From Fixed-Width File}{appendTableFromFixedFile}
\texttt{append\_table\_from\_fixed\_file(tableFile, fixedFile, attributes)}\\

Equivalent to \primu{create\_table\_from\_fixed\_file}{createTableFromFixedFile} which appends to any pre-existing file instead of overwriting.

\primdefu{append\_table\_from\_psv}{Append Table From PSV File}{appendTableFromPsv}
\texttt{append\_table\_from\_psv(tableFile, psvFile, fields, n)}\\

Equivalent to \primu{create\_table\_from\_psv}{createTableFromPsv} which appends to any pre-existing file instead of overwriting.

\primdefu{append\_table\_from\_tsv}{Append Table From TSV File}{appendTableFromTsv}
\texttt{append\_table\_from\_tsv(tableFile, tsvFile, fields, n)}\\

Equivalent to \primu{create\_table\_from\_tsv}{createTableFromTsv} which appends to any pre-existing file instead of overwriting.

\primdef{ascend}{Ascending Indices}
\texttt{ascend(x)}\\

For a list \texttt{x}, generate a list of indices into \texttt{x} in ascending order of the values of \texttt{x}.

\begin{Verbatim}
KeRF> \typed{t:5 2 3 1}
  [5, 2, 3, 1]
KeRF> \typed{ascend t}
  [3, 1, 2, 0]
KeRF> \typed{t[ascend t]}
  [1, 2, 3, 5]
\end{Verbatim}

Strings are sorted in lexicographic order:
\begin{Verbatim}
KeRF> \typed{ascend ["Orange","Apple","Pear","Aardvark","A"]}
  [4, 3, 1, 0, 2]
\end{Verbatim}

When applied to a map, \prim{ascend} will sort the keys by their values and produce a list:
\begin{Verbatim}
KeRF> \typed{ascend \{"A":2, "B":9, "C":0\}}
  ["C", "A", "B"]
\end{Verbatim}

\pagebreak
The symbol \texttt{<} is equivalent to \prim{ascend} when used as a unary operator:
\begin{Verbatim}
KeRF> \typed{<5 2 3 1}
  [3, 1, 2, 0]
\end{Verbatim}

\primdef{asin}{Arc Sine}
\texttt{asin(x)}\\

Calculate the arc sine (inverse sine) of \texttt{x}, expressed in radians, within the interval [-1,1]. Atomic. The results of \prim{asin} will always be floating point values.
\begin{Verbatim}
KeRF> \typed{asin 0.5 -0.2 1}
  [0.523599, -0.201358, 1.5708]
KeRF> \typed{sin(asin 0.5 -0.2 1 4)}
  [0.5, -0.2, 1, nan]
\end{Verbatim}

\primdefu{asof\_join}{Asof Join}{asofJoin}
\texttt{asof\_join(x, y, k1, k2)}\\

Perform a ``fuzzy'' \primu{left\_join}{leftJoin}. See \hyperref[sec:joins]{\textbf{Joins}}.

\primdef{atan}{Arc Tangent}
\texttt{atan(x)}\\

Calculate the arc tangent (inverse tangent) of \texttt{x}, expressed in radians. Atomic. The results of \prim{atan} will always be floating point values.
\begin{Verbatim}
KeRF> \typed{atan 0.5 -0.2 1 4}
  [0.463648, -0.197396, 0.785398, 1.32582]
KeRF> \typed{tan(atan 0.5 -0.2 1 4)}
  [0.5, -0.2, 1, 4]
\end{Verbatim}

\primdef{atlas}{Atlas Of}
\texttt{atlas(map)}\\

Create an atlas from a map or list of maps. An atlas is the schemaless NoSQL equivalent of a table. This gives tables in Kerf the option of being unstructured, or schema-less, for dealing with highly irregular data. Atlases are automatically indexed in such a way that all key-queries are indexed. Atlases allow for NoSQL queries.
\begin{Verbatim}
KeRF> \typed{atlas(\{name:["bob", "alice", "oscar"], id:[123, 421, 233]\})}
  atlas[\{name:["bob", "alice", "oscar"], id:[123, 421, 233]\}]
\end{Verbatim}

\pagebreak
\primdef{atom}{Is Atom?}
\texttt{atom(x)}\\

A predicate which returns 0 if \texttt{x} is a list or vector, and 1 if \texttt{x} is a non-list (atomic) value.
\begin{Verbatim}
KeRF> \typed{atom \textasciigrave"A"}
  1
KeRF> \typed{atom "A String"}
  0
KeRF> \typed{atom 37}
  1
KeRF> \typed{atom -0.2}
  1
KeRF> \typed{atom 2015.03.31}
  1
KeRF> \typed{atom null}
  1
KeRF> \typed{atom [2, 5, 16]}
  0
KeRF> \typed{atom \{a: 45, b: 76\}}
  1
\end{Verbatim}

\primdef{avg}{Average}
\texttt{avg(x)}\\

Calculate the arithmetic mean of the elements of a list \texttt{x}. Equivalent to \texttt{(\prim{sum} x)/\primu{count\_nonnull}{countNonnull} x}.
\begin{Verbatim}
KeRF> \typed{avg 3 7 12.5 9}
  7.875
\end{Verbatim}

\pagebreak
\primdef{bars}{Time Bars, Sample Buckets, etc.}
\texttt{bars(x, y)}\\

Round the elements of a list \texttt{y} to multiples of \texttt{x}. Particularly useful in the context of ``time bucketing'' sample data. Equivalent to \texttt{x * \prim{floor} y/x}.
\begin{Verbatim}
KeRF> \typed{bars(2, [1, 1.2, 1.4, 2, 2.5, 3, 3.1, 5])}
  [0, 0, 0, 2, 2, 2, 2, 4]
KeRF> \typed{t: [1:02, 1:03, 1:14, 1:15, 1:35];}
KeRF> \typed{bars(15, t['minute'])}   \comment{//roll up times into 15 minute bars}
  [0, 0, 0, 15, 30]
\end{Verbatim}

The bars function is also defined for simple relative date-times when used on timestamps for generating bars on tables that are across time boundaries. This is generally faster and more convenient than the equivalent multiple ``group by'' statement on multiple clocks.
\begin{Verbatim}
KeRF> \typed{ts: \{\{value:range(10),time: 1999.01.01 + 1i * mapright  range(10)\}\}}

┌─────┬───────────────────────┐
│value│time                   │
├─────┼───────────────────────┤
│    0│             1999.01.01│
│    1│1999.01.01T00:01:00.000│
│    2│1999.01.01T00:02:00.000│
│    3│1999.01.01T00:03:00.000│
│    4│1999.01.01T00:04:00.000│
│    5│1999.01.01T00:05:00.000│
└─────┴───────────────────────┘

KeRF> \typed{select avg(value) from ts group by bars(2i,time)} \comment{//select 2 minute bars}

┌───────────────────────┬─────┐
│time                   │value│
├───────────────────────┼─────┤
│             1999.01.01│  0.5│
│1999.01.01T00:02:00.000│  2.5│
│1999.01.01T00:04:00.000│  4.5│
└───────────────────────┴─────┘
\end{Verbatim}

When using bars with relative date-times, it may be useful to define a starting point as an optional third argument. 

\begin{Verbatim}
KeRF> \typed{select avg(value) from ts group by bars(2i,time,1999.01.01T00:01:00)}

┌───────────────────────┬─────┐
│time                   │value│
├───────────────────────┼─────┤
│1998.12.31T23:59:00.000│  0.0│
│1999.01.01T00:01:00.000│  1.5│
│1999.01.01T00:03:00.000│  3.5│
│1999.01.01T00:05:00.000│  5.5│
│1999.01.01T00:07:00.000│  7.5│
│1999.01.01T00:09:00.000│  9.0│
└───────────────────────┴─────┘
\end{Verbatim}

% TODO EXAMPLE WHERE THIS IS USEFUL

%Using \texttt{bars} allows you to accomplish time rollups in table selects:
%
%\begin{Verbatim}
%KeRF> \typed{t: \{\{views: 100 75 300 200 400, time: [1:02, 1:03, 1:14, 1:15, 1:35]\}\} }
%┌──────────┬─────────┐
%│views     │time     │
%├──────────┼─────────┤
%│       100│ 01:02:00│
%│        75│ 01:03:00│
%│       300│ 01:14:00│
%│       200│ 01:15:00│
%│       400│ 01:35:00│
%└──────────┴─────────┘
%KeRF> \typed{select sum(views) from t group by bars(15, time['minute']) }
%┌──────────┬─────────┐
%│time      │views    │
%├──────────┼─────────┤
%│         0│      475│
%│        15│      200│
%│        30│      400│
%└──────────┴─────────┘
%\end{Verbatim}
\pagebreak
\primdef{between}{Between?}
\texttt{between(x, y)}\\

Predicate which returns 1 if \texttt{x} is between the first two elements of the list \texttt{y}. Equivalent to \texttt{(x >= y[0]) \& (x <= y[1])}.
\begin{Verbatim}
KeRF> \typed{between(2 5 17, 3 10)}
  [0, 1, 0]
\end{Verbatim}

Be careful- \prim{between} will always fail if \texttt{y} is not a list or does not have the correct length:
\begin{Verbatim}
KeRF> \typed{between(2 5 17, 3)}
  [0, 0, 0]

KeRF> \typed{3[1]}
  NAN
\end{Verbatim}

\primdef{btree}{BTree}
\texttt{btree(x)}\\

Equivalent to \prim{indexed}.

\primdef{bucketed}{Bucket Values}
\texttt{bucketed(x, y)}\\

Equivalent to \texttt{\prim{floor} (\prim{order} y) * x / \prim{count} y}.

\primdef{car}{Contents of Address Register} %teehee
\texttt{car(x)}\\

Select the first element of the list \texttt{x}. Atomic types are unaffected by this operation. Equivalent to \prim{first}. \prim{car} is a reference to the Lisp primitive of the same name, which selected the first element of a pair. See \prim{cdr}.

\begin{Verbatim}
KeRF> \typed{car 32 83 90}
  32
KeRF> \typed{car 409}
  409
KeRF> \typed{nil = car []}
  1
\end{Verbatim}

\primdef{cdr}{Contents of Decrement Register}
\texttt{cdr(x)}\\

Select all the elements of the list \texttt{x} except for the first. Atomic types are unaffected by this operation. Equivalent to \prim{drop}\texttt{(1, x)}. \prim{cdr} is a reference to the Lisp primitive of the same name, which selected the second element of a pair. See \prim{car}.

\begin{Verbatim}
KeRF> \typed{cdr 32 83 90}
  [83, 90]
KeRF> \typed{cdr 409}
  409
\end{Verbatim}

\primdef{ceil}{Ceiling}
\texttt{ceil(x)}\\

Compute the smallest integer following a number \texttt{x}. Atomic.
\begin{Verbatim}
KeRF> \typed{ceil -3.2 0.4 0.9 1.1}
  [-3, 1, 1, 2]
\end{Verbatim}

Taking the ceiling of a string or char converts it to uppercase:
\begin{Verbatim}
KeRF> \typed{ceil "Hello, World!"}
  "HELLO, WORLD!"
\end{Verbatim}

\primdef{char}{Cast to Char}
\texttt{char(x)}\\

Cast a number or list \texttt{x} to a char or string, respectively. To reverse this operation, use \prim{int}.
\begin{Verbatim}
KeRF> \typed{char 65}
  \textasciigrave"A"
KeRF> \typed{char 66.7}
  \textasciigrave"B"
KeRF> \typed{char 72 101 108 108 111 44 32 75 101 82 70 33}
  "Hello, KeRF!"
\end{Verbatim}

\primdef{checksum}{Object Hashcode}
\texttt{checksum(x)}\\

Produce an integer hashcode for any Kerf object \texttt{x}. The precise algorithm used by \texttt{checksum} is not specified and may change, but results will be consistent across runs and any two objects for which \prim{match} produces 1 will have the same hashcode.

\begin{Verbatim}
KeRF> \typed{checksum 1 2 3}
  -7744665892335545863
KeRF> \typed{checksum 5}
  1200461294887951755
\end{Verbatim}

\primdefu{close\_socket}{Close Socket}{closeSocket}
\texttt{close\_socket(handle)}\\

Given a socket handle as obtained with \primu{open\_socket}{openSocket}, close the connection. See \hyperref[sec:netio]{\textbf{Network I/O}}.

\pagebreak
\primdef{combinations}{Combinations}
\texttt{combinations(x, n)}\\
\texttt{combinations(x, n, repeats)}\\

Produce a list of all the distinct subsets of \texttt{x} which contain \texttt{n} elements. Normally this will operate on the unique elements of \texttt{x}, but if \texttt{repeats} is truthy all elements will be preserved:
\begin{Verbatim}
KeRF> \typed{combinations(6 7 8, 2)}
  [[6, 7], 
   [6, 8], 
   [7, 8]]
KeRF> \typed{combinations(3 5 5 7, 3)}
  [[3, 5, 7]]
KeRF> \typed{combinations(3 5 5 7, 3, 1)}
  [[3, 5, 5], 
   [3, 5, 7], 
   [3, 5, 7], 
   [5, 5, 7]]
\end{Verbatim}

If \texttt{x} is a map, operate on its keys:
\begin{Verbatim}
KeRF> \typed{combinations(\{foo: 1, bar: 2, quux: 3\}, 2)}
  [["foo", "bar"], 
   ["foo", "quux"], 
   ["bar", "quux"]]
\end{Verbatim}

\primdef{compressed}{Compressed Vector Of}
\texttt{compressed(x)}\\
\texttt{compressed(x, type)}\\

Create a \emph{zip}, or compressed vector, from a vector \texttt{x}. Compressed vectors consume less memory at runtime, and if serialized to disk will consume less disk space. Precise savings will be data-dependent. Otherwise, they may be treated like an ordinary vector. Note that it is invalid to apply \prim{compressed} to a non-vectorizable object.
\begin{Verbatim}
KeRF> \typed{compressed 1 2 3}
  COMPRESSED[1, 2, 3]
KeRF> \typed{compressed [12:00, 11:58]}
  COMPRESSED[12:00:00.000, 11:58:00.000]
\end{Verbatim}

If \prim{compressed} is provided with a second character argument, \texttt{type}, you can specify a variety of specialized compressed vector types using typecodes as described for \hyperref[sec:fieldcodes]{\textbf{Delimited File IO}}. These specialized types can save additional space by reducing the number of bytes used to represent numbers, at the cost of some precision. Presently all compressed vectors use LZ4 compression for its favorable balance of speed and compression ratio. In the future additional algorithms may be available via typecodes which are better suited to specific types of data.

\pagebreak
\primdef{cos}{Cosine}
\texttt{cos(x)}\\

Calculate the cosine of \texttt{x}, expressed in radians. Atomic. The results of \prim{cos} will always be floating point values.
\begin{Verbatim}
KeRF> \typed{cos 3.14159 1 -20}
  [-1, 0.540302, 0.408082]
KeRF> \typed{acos cos 3.14159 1 -20}
  [3.14159, 1, 1.15044]
\end{Verbatim}

\primdef{cosh}{Hyperbolic Cosine}
\texttt{cosh(x)}\\

Calculate the hyperbolic cosine of \texttt{x}, expressed in radians. Atomic. The results of \prim{cosh} will always be floating point values.
\begin{Verbatim}
KeRF> \typed{cosh 3.14159 1 -20}
  [11.5919, 1.54308, 2.42583e+08]
\end{Verbatim}

\primdef{count}{Count}
\texttt{count(x)}\\

Equivalent to \prim{len}.

\primdefu{count\_nonnull}{Count Non-Nulls}{countNonnull}
\texttt{count\_nonnull(x)}\\

Determine the number of elements in \texttt{x} which are not null. Equivalent to \prim{sum} \prim{not} \prim{isnull} \texttt{x}.
\begin{Verbatim}
KeRF> \typed{count_nonnull 1 2 3}
  3
KeRF> \typed{count_nonnull [nan, null, 45]}
  1
\end{Verbatim}

\primdefu{count\_null}{Count Nulls}{countNull}
\texttt{count\_null(x)}\\

Determine the number of elements in \texttt{x} which are null. Equivalent to \prim{sum} \prim{isnull} \texttt{x}.
\begin{Verbatim}
KeRF> \typed{count_null 1 2 3}
  0
KeRF> \typed{count_null [nan, null, 45]}
  2
\end{Verbatim}

\pagebreak
\primdefu{create\_table\_from\_csv}{Create Table From CSV File}{createTableFromCsv}
\texttt{create\_table\_from\_csv(tableFile, csvFile, fields, n)}\\

Load a Comma-Separated Value file and create a table which is serialized on disk. If the table file already exists, this operation will overwrite. \texttt{tableFile} and \texttt{csvFile} are filenames on disk. \texttt{fields} is a string which indicates the expected datatype of each column in the CSV file- see \primu{read\_table\_from\_delimited\_file}{readTableFromDelimitedFile} for the supported column types and their symbols. \texttt{n} indicates how many rows of the file are treated as column headers- generally 0 or 1. See \hyperref[sec:stripeio]{\textbf{Striped Files}}.

\primdefu{create\_table\_from\_fixed\_file}{Create Table From Fixed-Width File}{createTableFromFixedFile}
\texttt{create\_table\_from\_fixed\_file(tableFile, fixedFile, attributes)}\\

Load a file with fixed-width columns and create a table which is serialized on disk. If the table file already exists, this operation will overwrite. \texttt{tableFile} and \texttt{fixedFile} are filenames on disk. \texttt{attributes} is a map specifying the format of the fixed-width file, as in \primu{read\_table\_from\_fixed\_file}{readTableFromFixedFile}. See \hyperref[sec:stripeio]{\textbf{Striped Files}}.

\primdefu{create\_table\_from\_psv}{Create Table From PSV File}{createTableFromPsv}
\texttt{create\_table\_from\_psv(tableFile, psvFile, fields, n)}\\

Equivalent to \primu{create\_table\_from\_csv}{createTableFromCsv} which processes pipe-delimited fields (\texttt{|}) instead of comma-delimited fields.

\primdefu{create\_table\_from\_tsv}{Create Table From TSV File}{createTableFromTsv}
\texttt{create\_table\_from\_tsv(tableFile, tsvFile, fields, n)}\\

Equivalent to \primu{create\_table\_from\_csv}{createTableFromCsv} which processes tab-delimited fields instead of comma-delimited fields.

\pagebreak
\primdef{cross}{Cartesian Product}
\texttt{cross(x, y)}\\

Pair up each element of \texttt{x} with each element of \texttt{y}. If \texttt{x} or \texttt{y} is a map, use the values:
\begin{Verbatim}
KeRF> \typed{cross(5, 3 4 6)}
  [[5, 3], 
   [5, 4], 
   [5, 6]]
KeRF> \typed{cross(1 2 3, 4 5)}
  [[1, 4], 
   [1, 5], 
   [2, 4], 
   [2, 5], 
   [3, 4], 
   [3, 5]]
KeRF> \typed{cross(1 2 3, \{a:4, b:5\})}
  [[1, 4], 
   [1, 5], 
   [2, 4], 
   [2, 5], 
   [3, 4], 
   [3, 5]]
\end{Verbatim}

\primdef{deal}{Deal}
\texttt{deal(count)}\\
\texttt{deal(count, x)}\\

Select \texttt{count} random elements from the list \texttt{x} without repeats. 

\begin{Verbatim}
KeRF> \typed{deal(5, 21 31 41 51 61 71 81)}
  [81, 21, 61, 51, 41]
KeRF> \typed{deal(4, "ABCD")}
  "CDBA"
\end{Verbatim}

If \texttt{x} is a map or table, select keys.
\begin{Verbatim}
KeRF> \typed{deal(3, \{a: 99, b: 22, c: 41, d: 55\})}
  ["d", "a", "b"]
KeRF> \typed{deal(2, \{\{a: 99 98, b: 21 22, c: 33 34\}\})}
  ["c", "b"]
\end{Verbatim}

If \texttt{x} is a number, select from \prim{range}\texttt{(x)}:
\begin{Verbatim}
KeRF> \typed{deal(10, 10)}
  [7, 4, 0, 2, 9, 8, 1, 6, 3, 5]
KeRF> \typed{deal(5, 5.0)}
  [2, 3, 1, 0, 4]
\end{Verbatim}

When \texttt{x} is omitted, the \prim{range} of \texttt{count} is used as the list.
\begin{Verbatim}
KeRF> \typed{deal(3)}
  [0, 2, 1]
\end{Verbatim}

\pagebreak
\primdefu{delete\_keys}{Delete Keys}{deleteKeys}
\texttt{delete\_keys(x, y)}\\

Remove elements from a list \texttt{x} at a specified index or indices \texttt{y}. All the supplied indices must fall within the dimensions of the original list.
\begin{Verbatim}
KeRF> \typed{"ABCDEF" delete_keys 2}
  "ABDEF"
KeRF> \typed{"ABCDEF" delete_keys 2 4}
  "ABDF"
\end{Verbatim}

If \texttt{x} is a map or table, remove a set of entries with keys \texttt{y}:
\begin{Verbatim}
KeRF> \typed{delete_keys(\{a:4, b:9, c:1\}, ["c", "a", "c", "f"])}
  \{b:9\}
KeRF> \typed{delete_keys(\{\{a:4, b:9, c:1\}\}, ["c", "a", "c", "f"])}
┌─┐
│b│
├─┤
│9│
└─┘
\end{Verbatim}

\primdef{descend}{Descending Indices}
\texttt{descend(x)}\\

For a list \texttt{x}, generate a list of indices into \texttt{x} in descending order of the values of \texttt{x}.

\begin{Verbatim}
KeRF> \typed{t:5 2 3 1}
  [5, 2, 3, 1]
KeRF> \typed{descend t}
  [0, 2, 1, 3]
KeRF> \typed{t[descend t]}
  [5, 3, 2, 1]
\end{Verbatim}

Strings are sorted in lexicographic order:
\begin{Verbatim}
KeRF> \typed{descend ["Orange","Apple","Pear","Aardvark","A"]}
  [2, 0, 1, 3, 4]
\end{Verbatim}

When applied to a map, \prim{descend} will sort the keys by their values and produce a list:
\begin{Verbatim}
KeRF> \typed{ascend \{"A":2, "B":9, "C":0\}}
  ["B", "A", "C"]
\end{Verbatim}

The symbol \texttt{>} is equivalent to \prim{descend} when used as a unary operator:
\begin{Verbatim}
KeRF> \typed{>5 2 3 1}
  [0, 2, 1, 3]
\end{Verbatim}

\primdefu{dir\_ls}{Directory Listing}{dirLs}
\texttt{dir\_ls(path)}\\
\texttt{dir\_ls(path, full)}\\

List the files and directories at a filesystem \texttt{path}. If \texttt{full} is provided and truthy, list complete paths to the elements of the directory. Otherwise, list only the base names. See \hyperref[sec:fileio]{\textbf{File I/O}}.

\primdef{display}{Display}
\texttt{display(x)}\\

Print a display representation of data to standard output. See \hyperref[sec:genio]{\textbf{General I/O}}.

\primdef{distinct}{Distinct Values}
\texttt{distinct(x)}\\

Select the first instance of each item in a list \texttt{x}. Atomic types are unaffected by this operation.
\begin{Verbatim}
KeRF> \typed{distinct "BANANA"}
  "BAN"
KeRF> \typed{distinct 2 3 3 5 3 4 5}
  [2, 3, 5, 4]
\end{Verbatim}

The symbol \texttt{\%} is equivalent to \prim{distinct} when used as a unary operator:
\begin{Verbatim}
KeRF> \typed{\%"BANANA"}
  "BAN"
\end{Verbatim}

\primdef{divide}{Divide}
\texttt{divide(x, y)}\\

Divide \texttt{x} by \texttt{y}. Fully atomic. The results of \prim{divide} will always be floating point values.
\begin{Verbatim}
KeRF> \typed{divide(3, 5)}
  0.6
KeRF> \typed{divide(-1, 0)}
  -inf
KeRF> \typed{divide(3, 2 4 5 0)}
  [1.5, 0.75, 0.6, inf]
KeRF> \typed{divide(1 3 4 0, 9)}
  [0.111111, 0.333333, 0.444444, 0.0]
KeRF> \typed{divide(10 5 3, 7 9 3)}
  [1.42857, 0.555556, 1.0]
\end{Verbatim}

The symbol \texttt{/} is equivalent to \prim{divide} when used as a binary operator:
\begin{Verbatim}
KeRF> \typed{10 5 3 / 7 9 3}
  [1.42857, 0.555556, 1.0]
\end{Verbatim}

\pagebreak
\primdef{dlload}{Dynamic Library Load}
\texttt{dlload(filename, function, argcount)}\\

Load a dynamic library function and return a Kerf function which can be invoked to call into it. \texttt{filename} is the name of the library, \texttt{function} is the name of the function and \texttt{argcount} is the number of arguments the function takes. The current implementation of \prim{dlload} permits a maximum \texttt{argcount} of 8.

\vspace{0.5cm} 

Let's look at a very simple C function which can be called from Kerf:
\begin{Verbatim}
#include <stdio.h>
#include "kerf_api.h"

KERF foreign_function_example(KERF argument) \{
	int64_t value = argument->i;
	printf("Hello from C! You gave me a \%d.\textbackslash{}n", (int)value);
	return 0;
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{f: dlload("example.dylib", "foreign_function_example", 1)}
  \{OBJECT:foreign_function_example\}
KeRF> \typed{f(42)}
Hello from C! You gave me a 42.
  
\end{Verbatim}

For more information about writing dynamic libraries for use in Kerf, see \hyperref[sec:ffi]{\textbf{FFI}}.

\primdef{dotp}{Dot Product}
\texttt{dotp(x, y)}\\

Calculate the dot product (or \emph{scalar product}) of the vectors \texttt{x} and \texttt{y}. Equivalent to \prim{sum} \texttt{x*y}.
\begin{Verbatim}
KeRF> \typed{dotp(1 2 3, 1 2 5)}
  20
\end{Verbatim}

\primdef{drop}{Drop Elements}
\texttt{drop(count, x)}\\

Remove \texttt{count} elements from the beginning of the list \texttt{x}. Atomic types are unaffected by this operation.
\begin{Verbatim}
KeRF> \typed{drop(3, "My Hero")}
  "Hero"
KeRF> \typed{drop(5, 9 2 0)}
  []
KeRF> \typed{drop(3, 5)}
  5
\end{Verbatim}

The symbol \texttt{\_} is equivalent to \prim{drop} when used as a binary operator:
\begin{Verbatim}
KeRF> \typed{3 _ "My Hero"}
  "Hero"
\end{Verbatim}

\primdefu{emu\_debug\_mode}{Toggle Bytecode Debugger}{emuDebugMode}
\texttt{emu\_debug\_mode(x)}\\

If \texttt{x} is truthy, enable the bytecode debugger. Otherwise, disable it. The bytecode debugger displays information about each bytecode as it is executed by Kerf's inner interpreter. This feature only works on debug builds of Kerf and will otherwise have no effect. The details of the information exposed by this feature are subject to change and beyond the scope of this document.

\begin{Verbatim}
KeRF> \typed{emu_debug_mode 1}
[DEBUG] puts.c:30: ======frame top =========
Stack 7 (t:2 n:1): 1
Stack 6 (t:2 n:0): 0
Stack 5 (t:2 n:0): 0
Stack 4 (t:2 n:0): 0
Stack 3 (t:2 n:0): 0
Stack 2 (t:0 n:72354530896904192): {[\$1].Net.client: \$1}
Stack 1 (t:2 n:0): 0
Stack 0 (t:2 n:0): 0
[DEBUG] puts.c:36: ======stack bottom=========
Stack: framept: 8, framebot: 8
Execute instruction: 20
\end{Verbatim}

\primdef{enlist}{Enlist Element}
\texttt{enlist(x)}\\

Wrap any element \texttt{x} in a list.
\begin{Verbatim}
KeRF> \typed{enlist "A"}
  ["A"]
KeRF> \typed{enlist 22 33}
  [[22, 33]]
\end{Verbatim}

\primdef{enum}{Enumeration}
\texttt{enum(x)}\\

Equivalent to \prim{hashed}.

\primdef{enumerate}{Enumerate Items}
\texttt{enumerate(x)}\\

If \texttt{x} is a number, generate a range of integers from 0 up to but not including \texttt{x}. Equivalent to \prim{til}.
\begin{Verbatim}
KeRF> \typed{enumerate 0}
  INT[]
KeRF> \typed{enumerate 3}
  [0, 1, 2]
KeRF> \typed{enumerate 5.3}
  [0, 1, 2, 3, 4]
\end{Verbatim}

\pagebreak
If \texttt{x} is a map, extract its keys.
\begin{Verbatim}
KeRF> \typed{enumerate {b:43, a:999}}
  ["b", "a"]
\end{Verbatim}

If \texttt{x} is a list, generate the Cartesian Product over the ranges of each element of \texttt{x}. This operation is sometimes called \emph{odometer}, for the way the resulting lists resemble the rolling digits of a car's odometer.
\begin{Verbatim}
KeRF> \typed{enumerate 2 3}
  [[0, 0], 
   [0, 1], 
   [0, 2], 
   [1, 0], 
   [1, 1], 
   [1, 2]]
KeRF> \typed{enumerate 2 2 2}
  [[0, 0, 0], 
   [0, 0, 1], 
   [0, 1, 0], 
   [0, 1, 1], 
   [1, 0, 0], 
   [1, 0, 1], 
   [1, 1, 0], 
   [1, 1, 1]]
\end{Verbatim}

The symbol \texttt{\^} is equivalent to \prim{enumerate} when used as a unary operator:
\begin{Verbatim}
KeRF> \typed{^9}
  [0, 1, 2, 3, 4, 5, 6, 7, 8]
\end{Verbatim}

\primdef{equal}{Equal?}
\texttt{equal(x, y)}\\

A predicate which returns 1 if \texttt{x} is equal to \texttt{y}. Equivalent to \prim{equals}. Fully atomic.
\begin{Verbatim}
KeRF> \typed{equal(5, 13)}
  0
KeRF> \typed{equal(5, 5 13)}
  [1, 0]
KeRF> \typed{equal(5 13, 5 13)}
  [1, 1]
KeRF> \typed{equal(.1, .100000000000001)}
  0
KeRF> \typed{equal(nan, nan)}
  1
\end{Verbatim}

The symbols \texttt{=} and \texttt{==} are equivalent to \prim{equal} when used as binary operators:
\begin{Verbatim}
KeRF> \typed{3 == 1 3 5}
  [0, 1, 0]
\end{Verbatim}

\primdef{equals}{Equals?}
\texttt{equals(x, y)}\\

Equivalent to \prim{equal}.

\primdef{erf}{Error Function}
\texttt{erf(x)}\\

Compute the Gauss error function of \texttt{x}. Atomic.
\begin{Verbatim}
KeRF> \typed{erf -.5 -.2 0 .2 .3 1 2}
  [-0.5205, -0.222703, 0, 0.222703, 0.328627, 0.842701, 0.995322]
\end{Verbatim}

\primdef{erfc}{Complementary Error Function}
\texttt{erfc(x)}\\

Compute the complementary Gauss error function of \texttt{x}. Equivalent to \texttt{1 - \prim{erf}(x)}. Atomic.
\begin{Verbatim}
KeRF> \typed{erfc -.5 -.2 0 .2 .3 1 2}
  [1.5205, 1.2227, 1, 0.777297, 0.671373, 0.157299, 0.00467773]
\end{Verbatim}

\primdef{eval}{Evaluate}
\texttt{eval(x)}\\

Evaluate a string \texttt{x} as a Kerf expression. Atomic down to strings.

\begin{Verbatim}
KeRF> \typed{a}
  {}
KeRF> \typed{eval(["2+3", "a: 24", "a: 999"])}
  [5, 24, 999]
KeRF> \typed{a}
  999
\end{Verbatim}

\primdef{except}{Except}
\texttt{except(x, y)}\\

Remove all the elements of \texttt{y} from \texttt{x}. Equivalent to \texttt{x[\prim{which} \prim{not} x \prim{in} y]}.
\begin{Verbatim}
KeRF> \typed{except("ABCDDBEFB", "ADF")}
  "BCBEB"
\end{Verbatim}

If \texttt{x} is atomic, the result will be enclosed in a list:
\begin{Verbatim}
KeRF> \typed{except(2, 3 4)}
  [2]
\end{Verbatim}

\primdef{exit}{Exit}
\texttt{exit()}\\
\texttt{exit(code)}\\

Exit the Kerf interpreter. If a number is provided, use it as an exit code.\\Otherwise, exit with code 0 (successful).

\begin{Verbatim}
KeRF> \typed{exit(1)}
\end{Verbatim}

\primdef{exp}{Natural Exponential Function}
\texttt{exp(x)}\\
\texttt{exp(x, y)}\\

Calculate $e^x$,  the natural exponential function. If \texttt{y} is provided, calculate $x^y$. Fully atomic.
\begin{Verbatim}
KeRF> \typed{exp 1 2 5}
  [2.71828, 7.38906, 148.413]
KeRF> \typed{exp(2, 0 1 2)}
  [1, 2, 4.0]
\end{Verbatim}

The symbol \texttt{**} is equivalent to \prim{exp}:
\begin{Verbatim}
KeRF> \typed{**1 2 5}
  [2.71828, 7.38906, 148.413]
KeRF> \typed{2**0 1 2}
  [1, 2, 4.0]
\end{Verbatim}

\primdef{explode}{Explode}
\texttt{explode(key, x)}\\

Violently and suddenly split the list \texttt{x} at instances of \texttt{key}. To reverse this process, use \prim{implode}.
\begin{Verbatim}
KeRF> \typed{explode(\textasciigrave"e", "A dream deferred")}
  ["A dr", "am d", "f", "rr", "d"]
KeRF> \typed{explode(0, 1 1 2 0 2 0 5)}
  [[1, 1, 2], [2], [5]]
\end{Verbatim}

\prim{explode} does not search for subsequences.\\Splitting on a 1-length string is not the same as splitting on a character:
\begin{Verbatim}
KeRF> \typed{explode("rat", "drat, that rat went splat.")}
  ["drat, that rat went splat."]
KeRF> \typed{explode("e", "A dream deferred")}
  ["A dream deferred"]
\end{Verbatim}

\pagebreak
\primdef{extract}{Extract From Table}
\texttt{extract(x)}\\

Isolate simple vector or scalar values from a table. \prim{extract} is mainly intended for unpacking the results from \hyperref[sec:select]{\texttt{SELECT}} queries. If the table has a single row and a single column, \prim{extract} will retrieve a scalar value. A single row and multiple columns naturally becomes a list:
\begin{Verbatim}
KeRF> \typed{extract SELECT a FROM \{\{a:55, b:27\}\}}
  55
KeRF> \typed{extract SELECT a,b FROM \{\{a:55, b:27\}\}}
  [55, 27]
\end{Verbatim}

A single column and multiple rows (or no rows) will be unpacked into a vector:
\begin{Verbatim}
KeRF> \typed{extract SELECT a FROM \{\{a:55 67, b:27 99\}\}}
  [55, 67]
KeRF> \typed{extract SELECT a FROM \{\{a:55 67, b:27 99\}\} WHERE a=0}
  INT[]
\end{Verbatim}

In other cases, \prim{extract} is roughly equivalent to \prim{xvals}:
\begin{Verbatim}
KeRF> \typed{extract \{\{a:1 2, b:3 4\}\}}
  [[1, 2], [3, 4]]
KeRF> \typed{xvals \{\{a:1 2, b:3 4\}\}}
  [[1, 2], [3, 4]]
\end{Verbatim}

\primdef{filter}{Filter}
\texttt{filter(f, x)}\\

Apply a predicate \texttt{f} to each element of \texttt{x}, and return a list of elements where \texttt{f} produces a truthy value:

\begin{Verbatim}
KeRF> \typed{(not isnull) filter [3, null, 27, nil, 39]}
  [3, 27, 39]
KeRF> \typed{\{[x] x > 100\} filter 20 19 130 5 -2 200 119}
  [130, 200, 119]
KeRF> \typed{\{[x] len(x) = 4\} filter ["apple","pear","knife","lock","spider"]}
  ["pear", "lock"]
\end{Verbatim}

If \texttt{x} is a map, \prim{filter} will operate on the values of \texttt{x} and produce a map result:
\begin{Verbatim}
KeRF> \typed{filter(isnull, \{a:23,b:null,c:22,e:null\})}
  \{b:null, e:null\}
KeRF> \typed{\{[x] len(x) > 1\} filter \{foo:1 2 3, bar:4, quux:5 6\}}
  \{foo:[1, 2, 3], quux:[5, 6]\}
\end{Verbatim}

For tables, prefer using SQL syntax and the more convenient \texttt{WHERE} clause.

\pagebreak
\primdef{first}{First}
\texttt{first(x)}\\
\texttt{first(x, y)}\\

When provided with a single argument, select the first element of the list \texttt{x}. Atomic types are unaffected by this operation.
\begin{Verbatim}
KeRF> \typed{first(43 812 99 23)}
  43
KeRF> \typed{first(99)}
  99
\end{Verbatim}

When provided with two arguments, select the first \texttt{x} elements of \texttt{y}, repeating elements of \texttt{y} as necessary. Equivalent to \prim{take}.
\begin{Verbatim}
KeRF> \typed{first(2, 43 812 99 23)}
  [43, 812]
KeRF> \typed{first(8, 43 812 99 23)}
  [43, 812, 99, 23, 43, 812, 99, 23]
\end{Verbatim}

\primdef{flatten}{Flatten}
\texttt{flatten(x)}\\

Concatenate the elements of the list \texttt{x}. To join elements with a delimiter, use \prim{implode}.
\begin{Verbatim}
KeRF> \typed{flatten(["foo", "bar", "quux"])}
  "foobarquux"
KeRF> \typed{flatten([2 3 4, 9 7 8, 14])}
  [2, 3, 4, 9, 7, 8, 14]
\end{Verbatim}

Note that \prim{flatten} only removes one level of nesting. To completely flatten an arbitrarily nested structure, combine it with \comb{converge}:
\begin{Verbatim}
KeRF> \typed{n: [[1,2],[3,4],[5,[6,7]]];}
KeRF> \typed{flatten n}
  [1, 2, 3, 4, 5, [6, 7]]
KeRF> \typed{flatten converge n}
  [1, 2, 3, 4, 5, 6, 7]
\end{Verbatim}

\primdef{float}{Cast to Float}
\texttt{float(x)}\\

Cast \texttt{x} to a float. Atomic.
\begin{Verbatim}
KeRF> \typed{float 0 7 15}
  [0, 7, 15.0]
\end{Verbatim}

When applied to a string, parse it into a number:
\begin{Verbatim}
KeRF> \typed{float "97"}
  97.0
\end{Verbatim}

\primdef{floor}{Floor}
\texttt{floor(x)}\\

Compute the largest integer preceding a number \texttt{x}. Atomic.
\begin{Verbatim}
KeRF> \typed{floor -3.2 0.4 0.9 1.1}
  [-4, 0, 0, 1]
KeRF> \typed{int -3.2 0.4 0.9 1.1}
  [-3, 0, 0, 1]
\end{Verbatim}

Taking the floor of a string or char converts it to lowercase:
\begin{Verbatim}
KeRF> \typed{floor "Hello, World!"}
  "hello, world!"
\end{Verbatim}

The symbol \texttt{\_} is equivalent to \prim{floor} when used as a unary operator:
\begin{Verbatim}
KeRF> \typed{_ 37.9 14.2}
  [37, 14]
\end{Verbatim}

\primdef{format}{Format String}
\texttt{format(x, y)}\\

Convert the elements of a list \texttt{y} into a single formatted string based on the string \texttt{x}. \prim{format} provides a subset of the functionality of the ubiquitous C \texttt{printf} function, with some Kerf-specific convenience features.

\vspace{0.5cm}

A format string contains one or more \emph{format sequences}. Each format sequence corresponds sequentially to one of the elements of \texttt{y}. Format sequences begin with the character \texttt{\%} and end with a \emph{format character} which specifies how to interpret the argument. The special combination \texttt{\%\%} produces a literal \texttt{\%} character in output, and all characters outside format sequences will likewise be preserved as-is.

\vspace{0.5cm}

Between the \texttt{\%} and the format character there may optionally be a \emph{width} and/or \emph{precision}, separated by a decimal point. The interpretation of each of these arguments depends on the format character. If the format character were \texttt{X}, the following would be valid format sequences:

\begin{Verbatim}
\%X     \comment{// simple format}
\%12X   \comment{// width only}
\%.5X   \comment{// precision only}
\%12.5X \comment{// width (12) and precision (5)}
\end{Verbatim}

\begin{table}[h]
	\centering
	\rowcolors{1}{tableRowColor1}{tableRowColor2}
	\begin{tabular}{| c | p{11cm} |}
		\hline
		\cellcolor{tableHeaderColor} Character &
		\cellcolor{tableHeaderColor} Behavior \\
		\% & Literal character \%. This sequence does not consume an argument. \\

		s & Format the argument as a string. Non-string arguments will be converted to strings as by the primitive \prim{rep}. Results will be padded by preceding spaces if less than \emph{width} characters long when specified. \emph{precision} is ignored. \\

		d & Format the argument as a decimal (integer) number. Floating point numbers will be truncated. Results will be padded by preceding spaces if less than \emph{width} characters long when specified. Numeric results will be padded with preceding zeroes if less than \emph{precision} digits long when specified. \\

		f & Format the argument as a float. Results will be padded by preceding spaces if less than \emph{width} characters long when specified. Numeric results will be shown with \emph{precision} decimal places when specified. \\
		\hline
	\end{tabular}
	\\ \bigskip Format Characters
\end{table}

\pagebreak
Let's look at a few examples:
\begin{Verbatim}
KeRF> \typed{"\%s \%d \%\% \%f " format ["text", 5, 7.8]}
  "text 5 \% 7.800000"
KeRF> \typed{"\%s | \%s | [\%5s]" format ["foo", 1 2 3, "abc"]}
  "foo | [1, 2, 3] | [  abc]"
KeRF> \typed{"[\%f] [\%.2f] [\%6.2f]" format take(3, 1.23456)}
  "[1.234560] [1.23] [  1.23]"
KeRF> \typed{"[\%d] [\%6d] [\%.8d] [\%6.4d]" format take(4, 123)}
  "[123] [   123] [00000123] [  0123]"
\end{Verbatim}

\primdefu{format\_stamp}{Format Timestamp}{formatStamp}
\texttt{format\_stamp(x, y)}\\

Convert a timestamp \texttt{y} into a string representation based on the string \texttt{x}. Right-atomic. The format string \texttt{x} builds on the the capabilities of the standard C \texttt{strftime} function, adding support for display of milliseconds or nanoseconds. To turn a formatted string back into a Kerf timestamp, see \primu{parse\_stamp}{parseStamp}.

\vspace{0.5cm}

As in \prim{format}, a format string contains one or more \emph{format sequences}. Each format sequence corresponds sequentially to one of the elements of \texttt{y}. Format sequences begin with the character \texttt{\%} and end with a \emph{format character} which specifies how to interpret the argument. All characters outside format sequences will be preserved as-is.

\begin{Verbatim}
KeRF> \typed{out "\%t\%D \%T.\%q" format_stamp now()}       \comment{// full nanosecond accuracy}
	04/29/16 18:18:10.316715000
KeRF> \typed{"Thank god it's \%A!" format_stamp now()}
  "Thank god it's Friday!"
\end{Verbatim}

\begin{table}[!htbp]
	\centering
	\rowcolors{1}{tableRowColor1}{tableRowColor2}
	\begin{tabular}{| c | l | >{\ttfamily}m{5.0cm} |}
		\hline
		\cellcolor{tableHeaderColor} Character &
		\cellcolor{tableHeaderColor} Behavior &
		\cellcolor{tableHeaderColor} \textnormal{Example} \\
		\% & Literal character \texttt{\%}. & \% \\
		a  & Abbreviated weekday name & Fri \\
		A  & Full weekday name & Friday \\
		b  & Abbreviated month name & Apr \\
		B  & Full month name & April \\
		c  & Alias for \texttt{\%a \%b \%d \%T \%Y} & Fri Apr 29 16:23:24 2016 \\
		C  & Year divided by 100 and truncated to integer (00-99) & 20 \\
		d  & Day of the month, zero-padded (01-31) & 29 \\
		D  & Alias for \texttt{\%m/\%d/\%y} & 04/29/16 \\
		e  & Day of the month, space-padded ( 1-31) & 29 \\
		% E is unpopulated.
		% f is unpopulated.
		F  & Alias for \texttt{\%Y-\%m-\%d} & 2016-04-29 \\
		g  & Week-based year, last two digits (00-99) & 16 \\
		G  & Week-based year & 2016 \\
		h  & Alias for \texttt{\%b} & Apr \\  % wasted.
		H  & Hour in 24h format (00-23) & 16 \\
		% i is unpopulated.
		I  & Hour in 12h format (01-12) & 04 \\
		j  & Day of the year (001-366) & 120 \\
		% J is unpopulated.
		% k is unpopulated.
		% K is unpopulated.
		% l is unpopulated.
		% L is unpopulated.
		m  & Month as a decimal number (01-12) & 04 \\
		M  & Minute (00-59) & 23 \\
		n  & Literal newline character & \\
		N  & Decimal nanoseconds (Kerf-specific) & 997456000 \\
		% N is unpopulated.
		% o is unpopulated.
		% O is unpopulated.
		p  & AM or PM designation & PM \\
		% P is unpopulated.
		q  & Decimal milliseconds (Kerf-specific) & 997 \\
		Q  & Decimal microseconds (Kerf-specific) & 997456 \\
		r  & Alias for \texttt{\%I:\%M:\%S \%p"} & 04:23:24 PM \\
		R  & Alias for \texttt{\%H:\%M} & 16:23 \\
		% s is unpopulated.
		S  & Second (00-61) & 24 \\
		t  & Literal tab character & \\
		T  & Alias for \texttt{\%H:\%M:\%S} (ISO 8601 time) & 16:23:24 \\
		u  & ISO 8601 weekday as number with Monday as 1 (1-7) & 5 \\
		U  & Week number from Sunday (00-53) & 17 \\
		% v is unpopulated.
		V  & ISO 8601 week number (00-53) & 17 \\
		w  & Weekday as a decimal number from Sunday (0-6) & 5 \\
		W  & Week number from Monday (00-53) & 17 \\
		x  & Alias for \texttt{\%D} & 04/29/16 \\ % wasted.
		X  & Alias for \texttt{\%T} & 16:23:24 \\ % wasted.
		y  & Year, last two digits (00-99) & 16 \\
		Y  & Year & 2016 \\
		z  & ISO 8601 offset from UTC in timezone & -0700 \\
		Z  & Abbreviated timezone name, if any & UTC \\
		\hline
	\end{tabular}
	\\ \bigskip Timestamp Format Characters
\end{table}

\pagebreak

%\subsection{\texttt{global} - Global}
%
%{\color{red} todo}
%
%\subsection{\texttt{globals} - Globals}
%
%{\color{red} todo}

\primdef{greater}{Greater Than?}
\texttt{greater(x, y)}\\

A predicate which returns 1 if \texttt{x} is greater than \texttt{y}. Fully atomic.
\begin{Verbatim}
KeRF> \typed{greater(1 2 3, 2)}
  [0, 0, 1]
KeRF> \typed{greater([5], [[], [3], [2 9]])}
  [0, 1, 0]
KeRF> \typed{greater("apple", ["a", "aa", "banana"])}
  [1, 1, 0]
\end{Verbatim}

The symbol \texttt{>} is equivalent to \prim{greater} when used as a binary operator:
\begin{Verbatim}
KeRF> \typed{3 4 7 > 1 9 0}
  [1, 0, 1]
\end{Verbatim}

\primdef{greatereq}{Greater or Equal?}
\texttt{greatereq(x, y)}\\

A predicate which returns 1 if \texttt{x} is greater than or equal to \texttt{y}. Fully atomic.
\begin{Verbatim}
KeRF> \typed{greatereq(1 2 3, 2)}
  [0, 1, 1]
\end{Verbatim}

The symbol \texttt{>=} is equivalent to \prim{greatereq} when used as a binary operator:
\begin{Verbatim}
KeRF> \typed{3 4 5 7 >= 1 9 5 0}
  [1, 0, 1, 1]
\end{Verbatim}

\primdefu{has\_column}{Table Has Column?}{hasColumn}
\texttt{has\_column(table, key)}\\

A predicate which returns 1 if \texttt{table} has a column with the key \texttt{key}.
\begin{Verbatim}
KeRF> \typed{has_column(\{\{a: 1 2 3; b: 4 2 1\}\}, "a")}
  1
KeRF> \typed{has_column(\{\{a: 1 2 3; b: 4 2 1\}\}, "fictional")}
  0
\end{Verbatim}

\pagebreak
\primdefu{has\_key}{Has Key?}{hasKey}
\texttt{has\_key(x, key)}\\

A predicate which returns 1 if a map \texttt{x} contains the key \texttt{key}.
\begin{Verbatim}
KeRF> \typed{m: \{alphonse: 1, betty: 3, oscar: 99\};}
KeRF> \typed{has_key(m, "alphonse")}
  1
KeRF> \typed{has_key(m, "alphys")}
  0
\end{Verbatim}

If \texttt{x} is a list, return 1 if \texttt{key} is a valid index into \texttt{x}:
\begin{Verbatim}
KeRF> \typed{l: 45 99 10 15;}
KeRF> \typed{has_key(l, -1)}
  0
KeRF> \typed{has_key(l, 2)}
  1
KeRF> \typed{has_key(l, 2.2)}
  1
KeRF> \typed{l[2.2]}
  10
KeRF> \typed{l[-1]}
  NAN
\end{Verbatim}

If \texttt{x} is a table, equivalent to \primu{has\_column}{hasColumn}\texttt{(x, key)}.


\primdef{hash}{Hash}
\texttt{hash(x)}\\

Equivalent to \prim{hashed}.

\primdef{hashed}{Hashed}
\texttt{hashed(x)}\\

Create a list containing the elements of \texttt{x}, with hashmap-backed local interning. Interning will minimize the storage consumed by values which occur frequently and permit much more efficient sorting.
\begin{Verbatim}
KeRF> \typed{data: rand(10000, ["apple", "pear", "banana"]);}
KeRF> \typed{write_to_path("a.data", data);}
KeRF> \typed{write_to_path("b.data", #data);}
KeRF> \typed{shell "wc -c a.data"}
  [" 1048576 a.data"]
KeRF> \typed{shell "wc -c b.data"}
  ["  262144 b.data"]
\end{Verbatim}

The symbol \texttt{\#} is equivalent to \prim{hashed} when used as a unary operator:
\begin{Verbatim}
KeRF> \typed{#["a", "b", "a"]}
  #["a", "b", "a"]
\end{Verbatim}

\primdef{help}{Help Tool}\label{subsec:help}
\texttt{help(x)}\\

Query the global \const{.Help}{help} table. Calling with an empty string lists the help subjects. Calling with a subject or entry will provide a table describing usage.

\primdef{ident}{Identity}
\texttt{ident(x)}\\

Unary identity function. Returns \texttt{x} unchanged.
\begin{Verbatim}
KeRF> \typed{ident 42}
  42
\end{Verbatim}

The symbol \texttt{:} is equivalent to \prim{ident} when used as a unary operator:
\begin{Verbatim}
KeRF> \typed{:42}
  42
\end{Verbatim}

\primdef{ifnull}{If Null?}
\texttt{ifnull(x)}\\

Equivalent to \prim{isnull}.

\primdef{implode}{Implode}
\texttt{implode(key, x)}\\

Violently and suddenly join the elements of the list \texttt{x} intercalated with \texttt{key}. To reverse this process, use \prim{explode}.
\begin{Verbatim}
KeRF> \typed{implode("_and_", ["BIFF", "BOOM", "POW"])}
  "BIFF_and_BOOM_and_POW"
KeRF> \typed{implode(23, 10 4 3 15)}
  [10, 23, 4, 23, 3, 23, 15]
\end{Verbatim}

\primdef{in}{In?}
\texttt{in(key, x)}\\

A predicate which returns 1 if each \texttt{key} is an element of \texttt{x}. Atomic over \texttt{key}.
\begin{Verbatim}
KeRF> \typed{in(3, 8 7 3 2)}
  [1]
KeRF> \typed{in(3 4, 8 7 3 2)}
  [1, 0]
KeRF> \typed{in("a", "cassiopeia")}
  [1]
\end{Verbatim}

\primdef{index}{Index}
\texttt{index(x)}\\

Equivalent to \prim{indexed}.

\primdef{indexed}{Indexed}
\texttt{indexed(x)}\\

Create an indexed version of a list \texttt{x}. This constructs an associated B-Tree, permitting faster searches and range queries. Do not use \prim{indexed} if you know the list must always be ascending. The command \primu{sort\_debug}{sortDebug} can be used to determine whether Kerf thinks a list is already sorted.
Indexed columns in tables can help with performance if the column is time oriented, or a float/int which is often used as a query key. Indexes incur memory overhead, so prefer a \prim{sort} on a primary column.

\begin{Verbatim}
KeRF> \typed{indexed 3 7 0 5 2}
  =[3, 7, 0, 5, 2]
\end{Verbatim}

The symbol \texttt{=} is equivalent to \prim{indexed} when used as a unary operator:
\begin{Verbatim}
KeRF> \typed{=3 2}
  =[3, 2]
\end{Verbatim}

\primdef{int}{Cast to Int}
\texttt{int(x)}\\

Cast \texttt{x} to an int, truncating. Atomic.
\begin{Verbatim}
KeRF> \typed{int 33.6 -12.5 4 nan}
  [33, -12, 4, NAN]
KeRF> \typed{floor 33.6 -12.5 4 nan}
  [33, -13, 4, NAN]
\end{Verbatim}

When applied to a character or string, produce character codes. To reverse this operation, use \prim{char}. If you want the numeric equivalent of a string, see \primu{parse\_int}{parseInt}.
\begin{Verbatim}
KeRF> \typed{int \textasciigrave{}A}
  65
KeRF> \typed{int "100"}
  [49, 48, 48]
KeRF> \typed{int "Hello, Kerf!"}
  [72, 101, 108, 108, 111, 44, 32, 75, 101, 114, 102, 33]
\end{Verbatim}

\primdef{intersect}{Set Intersection}
\texttt{intersect(x, y)}\\

Find unique items contained in both \texttt{x} and \texttt{y}. Equivalent to \texttt{\prim{distinct}(x)[\prim{which} \prim{distinct}(x) \prim{in} y]}.
\begin{Verbatim}
KeRF> \typed{intersect(4, 4 5 6)}
  [4]
KeRF> \typed{intersect(3 4, 1 2 3 4 5 6)}
  [3, 4]
KeRF> \typed{intersect("ABD", "BCBD")}
  "BD"
\end{Verbatim}

\primdef{isnull}{Is Null?}
\texttt{isnull(x)}\\

A predicate which returns 1 if \texttt{x} is null. Atomic.
\begin{Verbatim}
KeRF> \typed{isnull([(), nan, 2, -3.7, [], \{a:5\}])}
  [1, 1, 0, 0, [], \{a:0\}]
\end{Verbatim}

\primdef{join}{Join}
\texttt{join(x, y)}\\

Form a list by catenating \texttt{x} and \texttt{y}.
\begin{Verbatim}
KeRF> \typed{join(1, 2)}
  [1, 2]
KeRF> \typed{join(2, 3 4)}
  [2, 3, 4]
KeRF> \typed{join(2 3, 4 5)}
  [2, 3, 4, 5]
KeRF> \typed{join(2 3, 4)}
  [2, 3, 4]
KeRF> \typed{join(2 3, "ABC")}
  [2, 3, \textasciigrave"A", \textasciigrave"B", \textasciigrave"C"]
KeRF> \typed{join(\{a:23, b:24\}, \{b:99\})}
  [\{a:23, b:24\}, \{b:99\}]
\end{Verbatim}

The symbol \texttt{\#} is equivalent to \prim{join} when used as a binary operator:
\begin{Verbatim}
KeRF> \typed{2 3 # 9}
  [2, 3, 9]
KeRF> \typed{"foo "#(rep 23)#"!"}
  "foo 23!"
\end{Verbatim}

\primdefu{json\_from\_kerf}{Convert Kerf to JSON}{jsonFromKerf}
\texttt{json\_from\_kerf(x)}\\

Convert a Kerf data structure \texttt{x} into a JSON (IETF RFC-4627) string.
\begin{Verbatim}
KeRF> \typed{json_from_kerf(\{a: 45, b: [1, 3, 5.0]\})}
  "\{\textbackslash"a\textbackslash":45,\textbackslash"b\textbackslash":[1,3,5]\}"
KeRF> \typed{json_from_kerf(\{\{a: 1 2 3, b: 4 5 6\}\})}
  "\{\textbackslash"a\textbackslash":[1,2,3],\textbackslash"b\textbackslash":[4,5,6],\textbackslash"is_json_table\textbackslash":[1]\}"
\end{Verbatim}

\pagebreak
\primdefu{kerf\_from\_json}{Convert JSON to Kerf}{kerfFromJson}
\texttt{kerf\_from\_json(string)}\\

Convert a JSON (IETF RFC-4627) string into a Kerf data structure. Note that booleans become the numbers 1 and 0 during this conversion process. Kerf-generated JSON strings generally contain the metadata necessary to round-trip without information loss, but JSON strings produced by another program may not.
\begin{Verbatim}
KeRF> \typed{kerf_from_json("[23, 45, 9]")}
  [23, 45, 9]
KeRF> \typed{kerf_from_json("[true, false]")}
  [1, 0]
KeRF> \typed{kerf_from_json("\{\textbackslash"a\textbackslash":[1,2,3],\textbackslash"b\textbackslash":[4,5,6]\}")}
  {a:[1, 2, 3], b:[4, 5, 6]}
KeRF> \typed{kerf_from_json("\{\textbackslash"a\textbackslash":[1,2,3],\textbackslash"b\textbackslash":[4,5,6],\textbackslash"is_json_table\textbackslash":[1]\}")}
┌─┬─┐
│a│b│
├─┼─┤
│1│4│
│2│5│
│3│6│
└─┴─┘
\end{Verbatim}

\primdefu{kerf\_type}{Type Code}{kerfType}
\texttt{kerf\_type(x)}\\

Obtain a numeric typecode from a Kerf value.
\begin{Verbatim}
KeRF> \typed{kerf_type 45.0}
  3
\end{Verbatim}

\begin{table}[h]
	\centering
	\rowcolors{1}{tableRowColor1}{tableRowColor2}
	\begin{tabular}{| l | l | c | c |}
		\hline
		\cellcolor{tableHeaderColor} Type &
		\cellcolor{tableHeaderColor} Example &
		\cellcolor{tableHeaderColor} \primu{kerf\_type\_name}{kerfTypeName} &
		\cellcolor{tableHeaderColor} \primu{kerf\_type}{kerfType} \\
		Timestamp Vector & \texttt{[2000.01.01]}       & \texttt{stamp vector}     & -4 \\
		Float Vector     & \texttt{[0.1]}              & \texttt{float vector}     & -3 \\
		Integer Vector   & \texttt{[1]}                & \texttt{integer vector}   & -2 \\
		Character Vector & \texttt{"A"}                & \texttt{character vector} & -1 \\
		Function         & \texttt{\{[x] 1+x\}}        & \texttt{function}         &  0 \\
		Character        & \texttt{\textasciigrave{}A} & \texttt{character}        &  1 \\
		Integer          & \texttt{1}                  & \texttt{integer}          &  2 \\
		Float            & \texttt{0.1}                & \texttt{float}            &  3 \\
		Timestamp        & \texttt{2000.01.01}         & \texttt{stamp}            &  4 \\
		Null             & \texttt{()}                 & \texttt{null}             &  5 \\
		List             & \texttt{[]}                 & \texttt{list}             &  6 \\
		Map              & \texttt{\{a:1\}}            & \texttt{map}              &  7 \\
		Enumeration      & \texttt{enum ["a"]}         & \texttt{enum}             &  8 \\
		Index            & \texttt{index [1,2]}        & \texttt{sort}             &  9 \\
		Table            & \texttt{\{\{a:1\}\}}        & \texttt{table}            & 10 \\
		Atlas            & \texttt{atlas \{a:1\}}      & \texttt{atlas}            & 11 \\
		Zip              & \texttt{compressed [1,2]}   & \texttt{zip}              & 13 \\
		\hline
	\end{tabular}
	\\ \bigskip Kerf types
\end{table}

\primdefu{kerf\_type\_name}{Type Name}{kerfTypeName}
\texttt{kerf\_type\_name(x)}\\

Obtain a human-readable type name string from a Kerf value. See \primu{kerf\_type}{kerfType}.
\begin{Verbatim}
KeRF> \typed{kerf_type_name "Text"}
  "character vector"
\end{Verbatim}

\primdef{last}{Last}
\texttt{last(x)}\\
\texttt{last(count, x)}\\

When provided with a single argument, select the last element of the list \texttt{x}. Atomic types are unaffected by this operation.
\begin{Verbatim}
KeRF> \typed{last(43 812 99 23)}
  23
KeRF> \typed{last(99)}
  99
\end{Verbatim}

When provided with two arguments, select the last \texttt{count} elements of \texttt{x}, repeating elements of \texttt{x} as necessary. Equivalent to \texttt{\prim{take}(-count, x)}.
\begin{Verbatim}
KeRF> \typed{last(2, 43 812 99 23)}
  [99, 23]
KeRF> \typed{last(7, 43 812 99 23)}
  [812, 99, 23, 43, 812, 99, 23]
\end{Verbatim}

\primdefu{left\_join}{Left Join}{leftJoin}
\texttt{left\_join(x, y, z)}\\

Peform a left join of the tables \texttt{x} and \texttt{y} on the column \texttt{z}. See \hyperref[sec:joins]{\textbf{Joins}}.

\primdef{len}{Length}
\texttt{len(x)}\\

Determine the number of elements in \texttt{x}. Equivalent to \prim{count}. Atomic elements have a count of 1. The length of a table is the number of rows it contains.
\begin{Verbatim}
KeRF> \typed{len 4 7 9}
  3
KeRF> \typed{len [4 7 9, 23 32]}
  2
KeRF> \typed{len 5}
  1
KeRF> \typed{len \{a:23, b:45\}}
  1
KeRF> \typed{len \{\{a:1 2 3 4 5\}\}}
  5
\end{Verbatim}

\primdef{less}{Less Than?}
\texttt{less(x, y)}\\

A predicate which returns 1 if \texttt{x} is less than \texttt{y}. Fully atomic.
\begin{Verbatim}
KeRF> \typed{less(1 2 3, 2)}
  [1, 0, 0]
KeRF> \typed{less([5], [[], [3], [2 9]])}
  [1, 0, 1]
KeRF> \typed{less("apple", ["a", "aa", "banana"])}
  [0, 0, 1]
\end{Verbatim}

The symbol \texttt{<} is equivalent to \prim{less} when used as a binary operator:
\begin{Verbatim}
KeRF> \typed{3 4 7 < 1 9 0}
  [0, 1, 0]
\end{Verbatim}

\primdef{lesseq}{Less or Equal?}
\texttt{lesseq(x, y)}\\

A predicate which returns 1 if \texttt{x} is less than or equal to \texttt{x}. Fully atomic.
\begin{Verbatim}
KeRF> \typed{lesseq(1 2 3, 2)}
  [1, 1, 0]
KeRF> \typed{lesseq([5], [[], [3], [5], [2 9]])}
  [1, 0, 0, 1]
KeRF> \typed{lesseq("apple", ["a", "aa", "apple", "banana"])}
  [0, 0, 1, 1]
\end{Verbatim}

The symbol \texttt{<=} is equivalent to \prim{lesseq} when used as a binary operator:
\begin{Verbatim}
KeRF> \typed{3 4 1 7 <= 1 9 1 0}
  [0, 1, 1, 0]
\end{Verbatim}

\primdef{lg}{Base 2 Logarithm}
\texttt{lg(x)}\\

Calculate $\log _2(x)$. Equivalent to \texttt{\prim{log}(2, x)}. Atomic.
\begin{Verbatim}
KeRF> \typed{lg 128 512 37}
  [7, 9, 5.20945]
\end{Verbatim}

\primdef{lines}{Lines From File}
\texttt{lines(filename)}\\
\texttt{lines(filename, n)}\\

Load lines from \texttt{filename} into a list of strings. If \texttt{n} is present, limit loading to \texttt{n} lines. See \hyperref[sec:fileio]{\textbf{File I/O}}.

\primdef{ln}{Natural Logarithm}
\texttt{ln(x)}\\

Calculate $\log _e(x)$. Atomic.
\begin{Verbatim}
KeRF> \typed{ln 2 3 10 37}
  [0.693147, 1.09861, 2.30259, 3.61092]
\end{Verbatim}

\primdef{load}{Load Source}
\texttt{load(filename)}\\

Load and run Kerf source from a file. Given an example file:
\begin{Verbatim}
\comment{// comment}
a: 7+range 10
b: range 10
a * b
\end{Verbatim}

Loading the file from the Repl:
\begin{Verbatim}
KeRF> \typed{load("manual/example.kerf")}
KeRF> \typed{a}
  [7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
KeRF> \typed{b}
  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
\end{Verbatim}
Note that the value of the raw expression \texttt{a * b} is not printed when you \prim{load} a file. If this is desired, use \prim{display} in the script.

\primdef{log}{Logarithm}
\texttt{log(x)}\\
\texttt{log(x, y)}\\

Calculate the base \texttt{x} logarithm of \texttt{y}. If only one argument is provided, \texttt{\prim{log}(10, x)} is assumed. Fully atomic.
\begin{Verbatim}
KeRF> \typed{log 3 8 10 16 100}
  [0.477121, 0.90309, 1, 1.20412, 2.0]
KeRF> \typed{log(2, 3 8 10 16 100)}
  [1.58496, 3, 3.32193, 4, 6.64386]
KeRF> \typed{log(2 3 4, 8)}
  [3, 1.89279, 1.5]
\end{Verbatim}

\pagebreak
\primdef{lsq}{Least Squares Solution}
\texttt{lsq(A, B)}\\

Solve $Ax = B$ for $x$, where \texttt{A} is a matrix and \texttt{B} is a matrix or vector.
\begin{Verbatim}
KeRF> \typed{lsq([1 2;4 4], [3 4])}
  [[1, 0.5]]
KeRF> \typed{lsq([0 .5;2 0], [0 1;1 0])}
  [[2, 0.0], 
   [0, 0.5]]
\end{Verbatim}

The symbol \texttt{\textbackslash} is equivalent to \prim{lsq} when used as a binary operator:
\begin{Verbatim}
KeRF> \typed{[0 .5;2 0]\textbackslash[0 1;1 0]}
  [[2, 0.0], 
   [0, 0.5]]
\end{Verbatim}

\primdef{map}{Make Map}
\texttt{map(keys, values)}\\

Make a map from a list of keys and a list of values. These lists must be the same length. A map-based equivalent of \prim{table}.
\begin{Verbatim}
KeRF> \typed{map("ABC", 44 18 790)}
  \{\textasciigrave"A":44, \textasciigrave"B":18, \textasciigrave"C":790\}
\end{Verbatim}

The symbol \texttt{!} is equivalent to \prim{map} when used as a binary operator:
\begin{Verbatim}
KeRF> \typed{"ABC" ! 44 18 790}
  \{\textasciigrave"A":44, \textasciigrave"B":18, \textasciigrave"C":790\}
\end{Verbatim}

\primdef{match}{Match?}
\texttt{match(x, y)}\\

A predicate which returns 1 if \texttt{x} is identical to \texttt{y}. While \prim{equals} compares atoms, \prim{match} is not atomic and compares entire values.
\begin{Verbatim}
KeRF> \typed{match(5, 3 5 7)}
  0
KeRF> \typed{match(3 5 7, 3 5 7)}
  1
\end{Verbatim}

The symbol \texttt{\textasciitilde} is equivalent to \prim{match} when used as a binary operator:
\begin{Verbatim}
KeRF> \typed{3 5 7 ~ 3 5 7}
  1
\end{Verbatim}

\primdef{mavg}{Moving Average}
\texttt{mavg(x, y)}\\

For a series of sliding windows of size \texttt{x} ending at each element of the list \texttt{y}, find the arithmetic mean of valid (not \texttt{nan} and in range of the list) elements. Equivalent to \texttt{\prim{msum}(x, y)/\prim{mcount}(x, y)}.
\begin{Verbatim}
KeRF> \typed{mavg(3, 1 2 4 2 1 nan 0 4 6 7)}
  [1, 1.5, 2.33333, 2.66667, 2.33333, 1.5, 0.5, 2, 3.33333, 5.66667]
\end{Verbatim}

\primdef{max}{Maximum}
\texttt{max(x)}\\

Find the maximum element of \texttt{x}. Roughly equivalent to \prim{last} \prim{sort} \texttt{x}, but much more efficient.
\begin{Verbatim}
KeRF> \typed{max 7 0 15 -1 8}
  15
KeRF> \typed{max 0 -inf -5 nan inf}
  inf
\end{Verbatim}

\primdef{maxes}{Maximums}
\texttt{maxes(x, y)}\\

Find the maximum of \texttt{x} and \texttt{y}. Fully atomic.
\begin{Verbatim}
KeRF> \typed{maxes(1 3 7 2 0 1, -4 3 20 1 9 4)}
  [1, 3, 20, 2, 9, 4]
KeRF> \typed{maxes(8, -4 3 20 1 9 4)}
  [8, 8, 20, 8, 9, 8]
\end{Verbatim}

The symbol \texttt{|} is equivalent to \prim{maxes} when used as a binary operator:
\begin{Verbatim}
KeRF> \typed{-4 3 20 1 9 4 | 15}
  [15, 15, 20, 15, 15, 15]
\end{Verbatim}

\primdef{mcount}{Moving Count}
\texttt{mcount(x, y)}\\

For a series of sliding windows of size \texttt{x} ending at each element of the list \texttt{y}, count the number of valid (not \texttt{nan} and in range of the list) elements. Equivalent to \texttt{\prim{msum}(x, \prim{not} \prim{isnull} y)}.
\begin{Verbatim}
KeRF> \typed{mcount(3, 1 2 3 nan 4 5 nan nan nan)}
  [1, 2, 3, 2, 2, 2, 2, 1, 0]
\end{Verbatim}

\pagebreak
\primdef{median}{Median}
\texttt{median(x)}\\

Select the median of a list of numbers \texttt{x}:
\begin{Verbatim}
KeRF> \typed{median 1 3 19 7 4 2}
  3.5
\end{Verbatim}

\primdefu{meta\_table}{Meta Table}{metaTable}
\texttt{meta\_table(table)}\\

Produce a table containing debugging metadata about some some table:
\begin{Verbatim}
KeRF> \typed{meta_table \{\{a: 1 2 3, b: 3.0 17 4\}\}}
┌──────┬────┬──────────────┬────────────┬───────┐
│column│type│type_name     │is_ascending│is_disk│
├──────┼────┼──────────────┼────────────┼───────┤
│     a│  -2│integer vector│           1│      0│
│     b│  -3│  float vector│           0│      0│
└──────┴────┴──────────────┴────────────┴───────┘
\end{Verbatim}

\primdef{min}{Minimum}
\texttt{min(x)}\\

Find the minimum element of \texttt{x}. Roughly equivalent to \prim{first} \prim{sort} \texttt{x}, but much more efficient.
\begin{Verbatim}
KeRF> \typed{min 7 0 15 -1 8}
  -1
KeRF> \typed{min 0 -inf -5 nan inf}
  -inf
\end{Verbatim}

\primdef{mins}{Minimums}
\texttt{mins(x, y)}\\

Find the minimum of \texttt{x} and \texttt{y}. Fully atomic.
\begin{Verbatim}
KeRF> \typed{mins(1 3 7 2 0 1, -4 3 20 1 9 4)}
  [-4, 3, 7, 1, 0, 1]
KeRF> \typed{mins(8, -4 3 20 1 9 4)}
  [-4, 3, 8, 1, 8, 4]
\end{Verbatim}

The symbol \texttt{\&} is equivalent to \prim{mins} when used as a binary operator:
\begin{Verbatim}
KeRF> \typed{-4 3 20 1 9 4 & 15}
  [-4, 3, 15, 1, 9, 4]
\end{Verbatim}

\primdef{minus}{Minus}
\texttt{minus(x, y)}\\

Calculate the difference of \texttt{x} and \texttt{y}. Fully atomic.
\begin{Verbatim}
KeRF> \typed{minus(3, 5)}
  -2
KeRF> \typed{minus(3, 9 15 -7)}
  [-6, -12, 10]
KeRF> \typed{minus(9 15 -7, 3)}
  [6, 12, -10]
KeRF> \typed{minus(9 15 -7, 1 3 5)}
  [8, 12, -12]
\end{Verbatim}

The symbol \texttt{-} is equivalent to \prim{minus} when used as a binary operator:
\begin{Verbatim}
KeRF> \typed{2 4 3 - 9}
  [-7, -5, -6]
\end{Verbatim}

\primdef{minv}{Matrix Inverse}
\texttt{minv(x)}\\

Calculate the inverse of a matrix \texttt{x}.
\begin{Verbatim}
KeRF> \typed{minv([1 2;3 4])}
  [[-2,    1  ], 
   [ 1.5, -0.5]]
\end{Verbatim}

\primdef{mkdir}{Create directory}
\texttt{mkdir(x)}\\

Create the directory specified by \texttt{x}.
\begin{Verbatim}
KeRF> \typed{mkdir("dir/subdir")}
\end{Verbatim}

\primdef{mmax}{Moving Maximum}
\texttt{mmax(x, y)}\\

For a series of sliding windows of size \texttt{x} ending at each element of the list \texttt{y}, find the maximum element. Equivalent to \texttt{(x-1) \prim{or} \comb{mapback} \comb{converge} y}.
\begin{Verbatim}
KeRF> \typed{mmax(3, 0 1 0 2 0 1 0)}
  [0, 1, 1, 2, 2, 2, 1]
\end{Verbatim}

\primdef{mmin}{Moving Minimum}
\texttt{mmin(x, y)}\\

For a series of sliding windows of size \texttt{x} ending at each element of the list \texttt{y}, find the minimum element. Equivalent to \texttt{(x-1) \prim{and} \comb{mapback} \comb{converge} y}.
\begin{Verbatim}
KeRF> \typed{mmin(3, 4 0 3 0 2 0 4 5 6)}
  [4, 0, 0, 0, 0, 0, 0, 0, 4]
\end{Verbatim}

\primdef{mmul}{Matrix Multiply}
\texttt{mmul(x, y)}\\

Multiply the matrix or vector \texttt{x} by the matrix or vector \texttt{y}. Equivalent to \texttt{x \prim{dotp} \comb{mapleft} y}.
\begin{Verbatim}
KeRF> \typed{mmul([1 2;3 4], [5 6])}
  [[15, 18], 
   [35, 42]]
KeRF> \typed{mmul([1 2;3 4], [0 1;1 0])}
  [[2, 1], 
   [4, 3]]
\end{Verbatim}

\primdef{mod}{Modulus}
\texttt{mod(x, y)}\\

Calculate \texttt{x} modulo \texttt{y}. Equivalent to \texttt{x - y * \prim{floor}(x/y)}. Left-atomic.
\begin{Verbatim}
KeRF> \typed{mod(0 1 2 3 4 5 6 7, 3)}
  [0, 1, 2, 0, 1, 2, 0, 1]
KeRF> \typed{mod(-4 -3 -2 -1 0 1 2, 2)}
  [0, 1, 0, 1, 0, 1, 0]
\end{Verbatim}

The symbol \texttt{\%} is equivalent to \prim{mod} when used as a binary operator:
\begin{Verbatim}
KeRF> \typed{0 1 2 3 4 5 6 7 \% 3}
  [0, 1, 2, 0, 1, 2, 0, 1]
\end{Verbatim}

\primdef{msum}{Moving Sum}
\texttt{msum(x, y)}\\

Calculate a series of sums of each element in a list \texttt{y} and up to the \texttt{x} previous values, ignoring \texttt{nan}s and nonexistent values.
\begin{Verbatim}
KeRF> \typed{msum(2, 10 20 30 40)}
  [10, 30, 50, 70]
KeRF> \typed{msum(2, 1 2 2 nan 1 2)}
  [1, 3, 4, 2, 1, 3.0]
KeRF> \typed{msum(3, 10 10 14 10 25 10 Nan 10)}
  [10, 20, 34, 34, 49, 45, 35, 20.0]
\end{Verbatim}

\texttt{\prim{msum}(1, y)} can be used to remove \texttt{nan} from data:
\begin{Verbatim}
KeRF> \typed{msum(1, 4 2 1 nan 2)}
  [4, 2, 1, 0, 2.0]
\end{Verbatim}

\pagebreak
\primdef{negate}{Negate}
\texttt{negate(x)}\\

Reverse the sign of a number \texttt{x}. Equivalent to \texttt{-1 * x}. Atomic.
\begin{Verbatim}
KeRF> \typed{negate 2 4 -77}
  [-2, -4, 77]
\end{Verbatim}

The symbol \texttt{-} is equivalent to \prim{negate} when used as a unary operator:
\begin{Verbatim}
KeRF> \typed{-(2 4 -77)}
  [-2, -4, 77]
\end{Verbatim}

\primdef{negative}{Negative}
\texttt{negative(x)}\\

Equivalent to \prim{negate}.

\primdef{ngram}{N-Gram}
\texttt{ngram(n, x)}\\

Break a list \texttt{x} into non-overlapping subsequences of length \texttt{n}.\\ Equivalent to \texttt{\prim{split}(\prim{range}(0,\prim{count}(x),n), x)}.

\begin{Verbatim}
KeRF> \typed{ngram(3, "Prisencolinensinainciusol")}
  ["Pri", "sen", "col", "ine", "nsi", "nai", "nci", "uso", "l"]
KeRF> \typed{ngram(2, 34 12 44 19 29 90)}
  [[34, 12], [44, 19], [29, 90]]
\end{Verbatim}

\primdef{not}{Logical Not}
\texttt{not(x)}\\

Calculate the logical \emph{NOT} of \texttt{x}. Atomic.
\begin{Verbatim}
KeRF> \typed{not(1 0)}
  [0, 1]
KeRF> \typed{not([0, -4, 9, nan, []])}
  [1, 0, 0, 0, []]
\end{Verbatim}

The symbol \texttt{!} is equivalent to \prim{not} when used as a unary operator:
\begin{Verbatim}
KeRF> \typed{!1 0 8}
  [0, 1, 0]
\end{Verbatim}

\primdef{noteq}{Not Equal?}
\texttt{noteq(x, y)}\\

A predicate which returns 1 if \texttt{x} is not equal to \texttt{y}. Equivalent to \prim{not} \prim{equals}. Fully atomic.
\begin{Verbatim}
KeRF> \typed{noteq(5, 13)}
  1
KeRF> \typed{noteq(5, 5 13)}
  [0, 1]
KeRF> \typed{noteq(5 13, 5 13)}
  [0, 0]
KeRF> \typed{noteq(.1, .100000000000001)}
  1
KeRF> \typed{noteq(nan, nan)}
  0
\end{Verbatim}

The symbols \texttt{!=} and \texttt{<>} are equivalent to \prim{noteq} when used as binary operators:
\begin{Verbatim}
KeRF> \typed{3 != 1 3 5}
  [1, 0, 1]
\end{Verbatim}

\primdef{now}{Current DateTime}
\texttt{now()}\\

Return a stamp containing the current date and time in UTC.
\begin{Verbatim}
KeRF> \typed{now()}
  2015.10.31T21:14:09.018
\end{Verbatim}

\primdefu{now\_date}{Current Date}{nowDate}
\texttt{now\_date()}\\

Return a stamp containing the current date only in UTC.
\begin{Verbatim}
KeRF> \typed{now_date()}
  2015.10.31
\end{Verbatim}

\primdefu{now\_time}{Current Time}{nowTime}
\texttt{now\_time()}\\

Return a stamp containing the current time only in UTC.
\begin{Verbatim}
KeRF> \typed{now_time()}
  21:14:09.018
\end{Verbatim}

\primdefu{open\_socket}{Open Socket}{openSocket}
\texttt{open\_socket(host, port)}\\

Establish a connection to a remote Kerf instance at hostname \texttt{host} and listening on \texttt{port} and return a connection handle. Both \texttt{host} and \texttt{port} must be strings. See \hyperref[sec:netio]{\textbf{Network I/O}}.

\primdefu{open\_table}{Open Table}{openTable}
\texttt{open\_table(filename)}\\

Load a serialized table from the binary file \texttt{filename}. See \hyperref[sec:fileio]{\textbf{File I/O}}.

\primdef{or}{Logical OR}
\texttt{or(x, y)}\\

Calculate the logical \emph{OR} of \texttt{x} and \texttt{y}. This operation is equivalent to \prim{max}. Fully atomic.
\begin{Verbatim}
KeRF> \typed{or(1 1 0 0, 1 0 1 0)}
  [1, 1, 1, 0]
KeRF> \typed{or(1 2 3 4, 0 -4 9 0)}
  [1, 2, 9, 4]
\end{Verbatim}

The symbol \texttt{|} is equivalent to \prim{or} when used as a binary operator:
\begin{Verbatim}
KeRF> \typed{1 1 0 0 | 1 0 1 0}
  [1, 1, 1, 0]
\end{Verbatim}

\primdef{order}{Order}
\texttt{order(x)}\\

Generate a list of indices showing the relative ascending order of items in the list \texttt{x}. Equivalent to \texttt{<<x}.
\begin{Verbatim}
KeRF> \typed{order "ABCEDF"}
  [0, 1, 2, 4, 3, 5]
KeRF> \typed{order 2 4 1 9}
  [1, 2, 0, 3]
KeRF> \typed{<2 4 1 9}
  [2, 0, 1, 3]
KeRF> \typed{<<2 4 1 9}
  [1, 2, 0, 3]
\end{Verbatim}

\primdef{out}{Output}
\texttt{out(x)}\\

Print a string \texttt{x} to standard output. See \hyperref[sec:genio]{\textbf{General I/O}}.

\primdefu{parse\_float}{Parse Float From String}{parseFloat}
\texttt{parse\_float(string)}\\

Parse a string to obtain a floating point number. Atomic down to strings.
\begin{Verbatim}
KeRF> \typed{parse_float "1"}
  1.0
KeRF> \typed{parse_float "2e4"}
  20000.0
KeRF> \typed{parse_float ["10","11","15"]}
  [10, 11, 15.0]
\end{Verbatim}

\primdefu{parse\_int}{Parse Integer From String}{parseInt}
\texttt{parse\_int(string)}\\
\texttt{parse\_int(string, radix)}\\

Parse a string to obtain an integer. If no \texttt{radix} (numerical base) is provided, assume 10. The \texttt{radix} must be between 2 and 36, inclusive. Atomic over the left argument down to strings.
\begin{Verbatim}
KeRF> \typed{parse_int "+337"}
  337
KeRF> \typed{parse_int("1010011", 2)}
  83
KeRF> \typed{parse_int("100", 16)}
  256
KeRF> \typed{parse_int(["Ab", "cD", "eF"], 16)}
  [171, 205, 239]
\end{Verbatim}

\primdefu{parse\_stamp}{Parse Timestamp From String}{parseStamp}
\texttt{parse\_stamp(format, x)}\\

Parse a string to obtain a timestamp, according to the specified \texttt{format}. See \primu{format\_stamp}{formatStamp} for details on permissible timestamp formats. Atomic over the right argument down to strings.
\begin{Verbatim}
KeRF> \typed{parse_stamp("\%S:\%M:\%H", "56:34:12")}
  12:34:56.000
KeRF> \typed{parse_stamp("\%M", ["1", "2", "3"])}
  [00:01:00.000, 00:02:00.000, 00:03:00.000]
KeRF> \typed{f: "\%H:\%M:\%S.\%Q";}
KeRF> \typed{t: now()}
  2016.05.23T00:26:31.688
KeRF> \typed{parse_stamp(f, format_stamp(f, t))}
  00:26:31.688
\end{Verbatim}

\pagebreak
\primdef{part}{Partition}
\texttt{part(x)}\\

Produce a map from unique elements of a list \texttt{x} to lists of the indices at which these elements could originally be found.
\begin{Verbatim}
KeRF> \typed{part 3 5 7 7 5}
  \{3:[0], 5:[1, 4], 7:[2, 3]\}
KeRF> \typed{part ["apple", "frog", "frog", "kumquat"]}
  \{apple:[0], frog:[1, 2], kumquat:[3]\}
\end{Verbatim}

\prim{part} does not affect atomic types:
\begin{Verbatim}
KeRF> \typed{part \{a: 23 45, b: 9\}}
  \{a:[23, 45], b:9\}
KeRF> \typed{part 23}
  23
\end{Verbatim}

The symbol \texttt{\&} is equivalent to \prim{part} when used as a unary operator:
\begin{Verbatim}
KeRF> \typed{\&2 2 1 2}
  \{2:[0, 1, 3], 1:[2]\}
\end{Verbatim}

\primdef{permutations}{Permutations}
\texttt{permutations(x)}\\
\texttt{permutations(x, repeats)}\\

Generate a list of all possible orderings of the elements of \texttt{x}. Normally this will operate on the unique elements of \texttt{x}, but if \texttt{repeats} is truthy all elements will be preserved:
\begin{Verbatim}
KeRF> \typed{permutations(1 2 2)}
  [[1, 2, 2], 
   [2, 1, 2], 
   [2, 2, 1]]
KeRF> \typed{permutations(1 2 2, 1)}
  [[1, 2, 2], 
   [1, 2, 2], 
   [2, 1, 2], 
   [2, 2, 1], 
   [2, 1, 2], 
   [2, 2, 1]]
\end{Verbatim}

If \texttt{x} is a map, operate on its keys:
\begin{Verbatim}
KeRF> \typed{permutations(\{foo: 27, bar: 38\})}
  [["foo", "bar"], 
   ["bar", "foo"]]
\end{Verbatim}

\primdef{plus}{Plus}
\texttt{plus(x, y)}\\

Equivalent to \prim{add}.

\primdef{pow}{Exponentiation}
\texttt{pow(x)}\\
\texttt{pow(x, y)}\\

Equivalent to \prim{exp}.

\primdef{powerset}{Power Set}
\texttt{powerset(x)}\\

Produce a list of all possible sublists of \texttt{x}. If \texttt{x} is a map, generate a powerset of its keys:
\begin{Verbatim}
KeRF> \typed{powerset 45 67 33}
  [INT[], 
   [33], 
   [67], 
   [67, 33], 
   [45], 
   [45, 33], 
   [45, 67], 
   [45, 67, 33]]
KeRF> \typed{powerset(\{foo: 23, bar: 94\})}
  [[], 
   ["bar"], 
   ["foo"], 
   ["foo", "bar"]]
\end{Verbatim}

\primdef{rand}{Random Numbers}
\texttt{rand()}\\
\texttt{rand(x)}\\
\texttt{rand(x, y)}\\

Generate a random vector of \texttt{x} numbers from 0 up to but not including \texttt{y}.
\begin{Verbatim}
KeRF> \typed{rand(10, 3)}
  [0, 2, 1, 2, 1, 2, 1, 2, 0, 2]
KeRF> \typed{rand(5, 3.0)}
  [0.74465, 1.72491, 0.79121, 2.53097, 0.573115]
\end{Verbatim}

If \texttt{y} is a list, select random elements from \texttt{y}.
\begin{Verbatim}
KeRF> \typed{rand(6, "ABC")}
  "CBCBBA"
\end{Verbatim}

\pagebreak
If \texttt{y} is not provided, generate a single random number from 0 up to but not including \texttt{x}. As above, if \texttt{x} is a list, choose a single random element.
\begin{Verbatim}
KeRF> \typed{rand(10)}
  1
KeRF> \typed{rand(10)}
  8
KeRF> \typed{rand(10.0)}
  6.77151
KeRF> \typed{rand(10.0)}
  0.401473
KeRF> \typed{rand("ABCDE")}
  \textasciigrave"B"
\end{Verbatim}

If \prim{rand} is given no arguments, generate a single random float from 0 up to but not including 1.
\begin{Verbatim}
KeRF> \typed{rand()}
  0.389022
\end{Verbatim}

The symbol \texttt{?} is equivalent to \prim{rand} when used as a binary operator:
\begin{Verbatim}
KeRF> \typed{5?2}
  [0, 0, 1, 0, 0]
\end{Verbatim}

\primdef{range}{Range}
\texttt{range(x)}\\
\texttt{range(x, y)}\\
\texttt{range(x, y, z)}\\

If \prim{range} is provided with one argument, generate a vector of integers from 0 up to but not including \texttt{x}:
\begin{Verbatim}
KeRF> \typed{range 5}
  [0, 1, 2, 3, 4]
\end{Verbatim}

If \prim{range} is provided with two arguments, generate a vector of numbers from \texttt{x} up to but not including \texttt{y}, spaced 1 apart:
\begin{Verbatim}
KeRF> \typed{range(10, 15)}
  [10, 11, 12, 13, 14]
KeRF> \typed{range(10.5, 16.5)}
  [10.5, 11.5, 12.5, 13.5, 14.5, 15.5]
\end{Verbatim}

If \prim{range} is provided with three arguments, generate a vector of numbers from \texttt{x} up to but not including \texttt{y}, spaced \texttt{z} apart:
\begin{Verbatim}
KeRF> \typed{range(1, 3, .3)}
  [1, 1.3, 1.6, 1.9, 2.2, 2.5, 2.8]
\end{Verbatim}

\primdefu{read\_from\_path}{Read From Path}{readFromPath}
\texttt{read\_from\_path(filename)}\\

Load a serialized Kerf data structure from the binary file \texttt{filename}. See \hyperref[sec:fileio]{\textbf{File I/O}}.


\primdefu{read\_parceled\_from\_path}{Read Parceled Table From Path}{readParceledFromPath}
\texttt{read\_parceled\_from\_path(path)}\\

Load a parceled Kerf data structure from the directory \texttt{path}. See \hyperref[sec:parcels]{\textbf{Parceled Tables}}.

\primdefu{read\_striped\_from\_path}{Read Striped File From Path}{readStripedFromPath}
\texttt{read\_striped\_from\_path(path)}\\

Load a striped Kerf data structure from the directory \texttt{path}. See \hyperref[sec:stripeio]{\textbf{Striped Files}}.

\primdefu{read\_table\_from\_csv}{Read Table From CSV File}{readTableFromCsv}
\texttt{read\_table\_from\_csv(filename, fields, n)}\\

Load a Comma-Separated Value file into a table. \texttt{fields} is a string which indicates the expected datatype of each column in the CSV file- see \primu{read\_table\_from\_delimited\_file}{readTableFromDelimitedFile} for the supported column types and their symbols. \texttt{n} indicates how many rows of the file are treated as column headers- generally 0 or 1.\\

Equivalent to \texttt{read\_table\_from\_delimited\_file(",", filename, fields, n)}.

\primdefu{read\_table\_from\_delimited\_file}{Read Table From Delimited File}{readTableFromDelimitedFile}
\texttt{read\_table\_from\_delimited\_file(delimiter, filename, fields, n)}\\

Load the contents of a text file with rows separated by newlines and fields separated by some character \texttt{delimiter} into a table. \texttt{fields} is a string which indicates the expected datatype of each column. \texttt{n} indicates how many rows of the file are treated as column headers- generally 0 or 1.

\begin{table}[h] \label{sec:fieldcodes}
	\centering
	\rowcolors{1}{tableRowColor1}{tableRowColor2}
	\begin{tabular}{| c | l |}
		\hline
		\cellcolor{tableHeaderColor} Symbol &
		\cellcolor{tableHeaderColor} Datatype \\
		\texttt{I} & Integer                                               \\
		\texttt{F} & Float                                                 \\
		\texttt{S} & String                                                \\
		\texttt{E} & Enumerated String (see \prim{hashed})                 \\
		\texttt{G} & IETF RFC-4122 UUID                                    \\
		\texttt{N} & IP address as parsed by C's \texttt{inet\_pton()}     \\
		\texttt{A} & Nanoseconds since UNIX Epoch (Timestamp) \\
		\texttt{Z} & Custom Datetime. (see \const{.Parse.strptime\_format}{parseStrptimeFormat}) \\
		\texttt{Y} & Custom Times. (see \const{.Parse.strptime\_format2}{parseStrptimeFormat2}) \\
		\texttt{*} & Skipped field                                         \\
		\texttt{W} & 64-bit (8 byte) \prim{compressed} integer \\
		\texttt{4} & 32-bit (4 byte) \prim{compressed} integer \\
		\texttt{2} & 16-bit (2 byte) \prim{compressed} integer \\
		\texttt{1} & 8-bit  (1 byte) \prim{compressed} integer \\
		\texttt{V} & 64-bit \prim{compressed} float \\
		\texttt{0} & 32-bit \prim{compressed} float \\
		\texttt{D} & 64-bit \prim{compressed} decimal (see notes) \\
		\texttt{9} & \prim{compressed} timestamp (see \const{.Parse.strptime\_format}{parseStrptimeFormat})\\
		\texttt{3} & \prim{compressed} STR32 (see notes) \\
		\hline
	\end{tabular}
	\\ \bigskip Symbols accepted as part of \texttt{fields}
\end{table}

\pagebreak
Columns with a \prim{compressed} datatype are compressed into memory as the file is parsed. The \texttt{STR32} type is capable of representing a vector of strings no longer than 32 characters, which may not contain the null character \texttt{\textbackslash 0}. The decimal type \texttt{D} is stored as a fixed-point integer, retaining 4 decimal places.


Given a file like the following:
\begin{Verbatim}
Language&Lines&Runtime
C&271&0.101
Java&89&0.34
Python&62&3.79
\end{Verbatim}

\begin{Verbatim}
KeRF> \typed{read_table_from_delimited_file("&", "code.txt", "SIF", 1)}
┌────────┬─────┬───────┐
│Language│Lines│Runtime│
├────────┼─────┼───────┤
│       C│  271│  0.101│
│    Java│   89│   0.34│
│  Python│   62│   3.79│
└────────┴─────┴───────┘
\end{Verbatim}

As another example, let's take a look at how some specialized types are handled. Observe how strings in the \texttt{STR32} column are truncated as necessary, and the decimal column retains only the first 4 decimal places:
\begin{Verbatim}
Label&Float
First&10.5
Second&0.123456
Third&90000
A considerably longer string which won't fit.&320
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{t: read_table_from_delimited_file("&", "delimited.txt", "3D", 1)}
┌────────────────────────────────┬───────┐
│Label                           │Float  │
├────────────────────────────────┼───────┤
│                           First│   10.5│
│                          Second│ 0.1234│
│                           Third│90000.0│
│A considerably longer string whi│  320.0│
└────────────────────────────────┴───────┘
KeRF> \typed{t["Label"]}
  COMPRESSED["First", "Second", "Third", "A considerably longer string whi"]
KeRF> \typed{kerf_type_name t["Label"]}
  "zip"
KeRF> \typed{kerf_type_name t["Float"][2]}
  "float"
\end{Verbatim}

\pagebreak
\primdefu{read\_table\_from\_fixed\_file}{Read Table From Fixed-Width File}{readTableFromFixedFile}
\texttt{read\_table\_from\_fixed\_file(filename, attributes)}

Load the contents of a text file with fixed-width columns. The map \texttt{attributes} specifies the details of the format:

\begin{table}[h]
	\centering
	\rowcolors{1}{tableRowColor1}{tableRowColor2}
	\begin{tabular}{| c | c | c | l |}
		\hline
		\cellcolor{tableHeaderColor} Key &
		\cellcolor{tableHeaderColor} Type &
		\cellcolor{tableHeaderColor} Optional &
		\cellcolor{tableHeaderColor} Description \\

		\texttt{fields} & String & No & As in \primu{read\_table\_from\_delimited\_file}{readTableFromDelimitedFile}. \\
		\texttt{widths} & Integer Vector & No & The width of each column in characters. \\
		\texttt{line\_limit} & Integer & Yes & The maximum number of rows to load. \\
		\texttt{titles} & List of String & Yes & Key for each column in the resulting table. \\
		\texttt{header\_rows} & Integer & Yes & How many rows are treated as column headers. \\
		\texttt{newline\_separated} & Boolean & Yes & if false, do not expect newlines separating rows. \\
		\hline
	\end{tabular}
	\\ \bigskip Settings described in \texttt{attributes}
\end{table}

\begin{table}[h]
	\centering
	\rowcolors{1}{tableRowColor1}{tableRowColor2}
	\begin{tabular}{| c | l |}
		\hline
		\cellcolor{tableHeaderColor} Symbol &
		\cellcolor{tableHeaderColor} Datatype \\
		\texttt{R} & NYSE TAQ symbol                               \\
		\texttt{Q} & NYSE TAQ time format (\texttt{HHMMSSXXX})     \\
		\hline
	\end{tabular}
	\\ \bigskip Additional symbols accepted as part of \texttt{fields} in fixed-width files
\end{table}

Given a file like this list of ingredients for my \emph{famous} pizza dough:
\begin{Verbatim}
Eggs      2.0 -    
Flour     5.0 cups 
Honey     2.0 tbs  
Water     2.0 cups 
Olive Oil 2.0 tbsp 
Yeast     1.0 tbsp 
\end{Verbatim}

\begin{Verbatim}
KeRF> \typed{fmt: \{ fields: "SFS", widths: [10, 4, 5], titles: ["Ingredient", "Amount", "Unit"] \};}
KeRF> \typed{read_table_from_fixed_file("dough.txt", fmt)}
┌──────────┬──────┬────┐
│Ingredient│Amount│Unit│
├──────────┼──────┼────┤
│      Eggs│   2.0│   -│
│     Flour│   5.0│cups│
│     Honey│   2.0│tbsp│
│     Water│   2.0│cups│
│ Olive Oil│   2.0│tbsp│
│     Yeast│   1.0│tbsp│
└──────────┴──────┴────┘
\end{Verbatim}

\primdefu{read\_table\_from\_tsv}{Read Table From TSV File}{readTableFromTsv}
\texttt{read\_table\_from\_tsv(filename, fields, n)}\\

Load a Tab-Separated Value file into a table. \texttt{fields} is a string which indicates the expected datatype of each column in the TSV file- see \primu{read\_table\_from\_delimited\_file}{readTableFromDelimitedFile} for the supported column types and their symbols. \texttt{n} indicates how many rows of the file are treated as column headers- generally 0 or 1.\\

Equivalent to \texttt{\primu{read\_table\_from\_delimited\_file}{readTableFromDelimitedFile}("\char`\\t", filename, fields, n)}.

\primdef{rep}{Output Representation}
\texttt{rep(x)}\\

Convert a value \texttt{x} into a printable string representation. If you only wish to convert the atoms of \texttt{x} into strings, use \prim{string}.
\begin{Verbatim}
KeRF> \typed{rep 45}
  "45"
KeRF> \typed{rep 2 5 3}
  "[2, 5, 3]"
KeRF> \typed{rep \{a:4\}}
  "\{a:4\}"
KeRF> \typed{rep "Some text"}
  "\textbackslash"Some text\textbackslash""
\end{Verbatim}

\primdef{repeat}{Repeat}
\texttt{repeat(n, x)}\\

Create a list containing \texttt{n} copies of \texttt{x}. Equivalent to \texttt{n \prim{take} \prim{enlist} x}.
\begin{Verbatim}
KeRF> \typed{repeat(2, 5)}
  [5, 5]
KeRF> \typed{repeat(4, "AB")}
  ["AB", "AB", "AB", "AB"]
KeRF> \typed{repeat(0, "AB")}
  []
KeRF> \typed{repeat(-3, "AB")}
  []
\end{Verbatim}

\primdef{reserved}{Reserved Names}
\texttt{reserved()}\\

Print and return an unsorted list of Kerf's reserved names, including reserved literals such as \texttt{true}.

\primdef{reset}{Reset}
\texttt{reset()}\\
\texttt{reset(drop\_args)}\\

Reset the Kerf interpreter, clearing the workspace and cleaning up any open resources. If a truthy argument is supplied, reset the interpreter as if invoked without any command-line arguments.
\begin{Verbatim}
> \typed{./kerf -q}
KeRF> \typed{a: 437;}
KeRF> \typed{reset()}
KeRF> \typed{a}

 Undefined token error

KeRF>
\end{Verbatim}

\pagebreak
\primdef{reverse}{Reverse}
\texttt{reverse(x)}\\

Reverse the order of the elements of the list \texttt{x}. Atomic types are unaffected by this operation.
\begin{Verbatim}
KeRF> \typed{reverse 23 78 94}
  [94, 78, 23]
KeRF> \typed{reverse "backwards"}
  "sdrawkcab"
KeRF> \typed{reverse 5}
  5
KeRF> \typed{reverse \{a: 23 56, b:0 1\}}
  {a:[23, 56], b:[0, 1]}
\end{Verbatim}

The symbol \texttt{/} is equivalent to \prim{reverse} when used as a unary operator:
\begin{Verbatim}
KeRF> \typed{/"example text"}
  "txet elpmaxe"
\end{Verbatim}

\primdef{rsum}{Running Sum}
\texttt{rsum(x)}\\

Calculate a running sum of the elements of the list \texttt{x}, from left to right. \texttt{nan}s are ignored.
\begin{Verbatim}
KeRF> \typed{rsum 1}
  1
KeRF> \typed{rsum 1 2}
  [1, 3]
KeRF> \typed{rsum 1 2 5}
  [1, 3, 8]
KeRF> \typed{rsum 1 2 5 7 8}
  [1, 3, 8, 15, 23]
KeRF> \typed{rsum 1 2 3 nan 4}
  [1, 3, 6, 6, 10.0]
KeRF> \typed{rsum []}
  []
\end{Verbatim}

\subsection{\texttt{run} - Run}
\texttt{run(filename)}\\

Load and run Kerf source from a file. Equivalent to \prim{load}.

\pagebreak
\primdef{search}{Search}
\texttt{search(x, y)}\\

Look for \texttt{x} in \texttt{y}. If found, return the index. If not found, return NAN:
\begin{Verbatim}
KeRF> \typed{search(3, 0 3 17 30)}
  1
KeRF> \typed{search(30, 0 3 17 30)}
  3
KeRF> \typed{search(15, 0 3 17 30)}
  NAN
KeRF> \typed{search("F", "AEIOU")}
  NAN
\end{Verbatim}

\primdefu{seed\_prng}{Set random seed}{seedPrng}
\texttt{seed\_prng(x)}\\

Sets random number generator seed used in \prim{rand} to \texttt{x}.


\primdefu{send\_async}{Send Asynchronous}{sendAsync}
\texttt{send\_async(x, y)}\\

Given a connection handle \texttt{x}, as obtained with \primu{open\_socket}{openSocket}, send a string \texttt{y} to a remote Kerf instance and do not wait for a reply. See \hyperref[sec:netio]{\textbf{Network I/O}}.

\primdefu{send\_sync}{Send Synchronous}{sendSync}
\texttt{send\_sync(x, y)}\\

Given a connection handle \texttt{x}, as obtained with \primu{open\_socket}{openSocket}, send a string \texttt{y} to a remote Kerf instance, waiting for a reply. See \hyperref[sec:netio]{\textbf{Network I/O}}.

\primdef{setminus}{Set Disjunction}
\texttt{setminus(x, y)}\\

Equivalent to \prim{except}.

\primdef{shell}{Shell Command}
\texttt{shell(x)}\\

Execute a string \texttt{x} containing a shell command as if from \texttt{/bin/sh -c x}. See \hyperref[sec:genio]{\textbf{General I/O}}.

\pagebreak
\primdef{shift}{Shift}
\texttt{shift(n, x)}\\
\texttt{shift(n, x, fill)}\\

Offset the list \texttt{x} by \texttt{n} positions, filling shifted-in positions with \texttt{fill}.
\begin{Verbatim}
KeRF> \typed{shift(4, 1 2 3 4 5 6 7, 999)}
  [999, 999, 999, 999, 1, 2, 3]
KeRF> \typed{shift(-1, 1 2 3 4 5 6 7, 999)}
  [2, 3, 4, 5, 6, 7, 999]
\end{Verbatim}

If \texttt{fill} is not provided, use a type-appropriate null value as generated by \primu{type\_null}{typeNull}.
\begin{Verbatim}
KeRF> \typed{shift(3, "ABCDE")}
  "   AB"
KeRF> \typed{shift(-3, "ABCDE")}
  "DE   "
KeRF> \typed{shift(2, 1 2 3 4)}
  [NAN, NAN, 1, 2]
KeRF> \typed{shift(2, 1.0 2.0 3.0 4.0)}
  [nan, nan, 1, 2.0]
\end{Verbatim}

\primdef{shuffle}{Shuffle}
\texttt{shuffle(x)}\\

Randomly permute the elements of the list \texttt{x}. Equivalent to \texttt{\prim{rand}(-\prim{len}(x), x)}.
\begin{Verbatim}
KeRF> \typed{shuffle "APPLE"}
  "PAEPL"
KeRF> \typed{shuffle "APPLE"}
  "LEAPP"
KeRF> \typed{shuffle "APPLE"}
  "LEPAP"
\end{Verbatim}

\primdef{sin}{Sine}
\texttt{sin(x)}\\

Calculate the sine of \texttt{x}, expressed in radians. Atomic. The results of \prim{sin} will always be floating point values.
\begin{Verbatim}
KeRF> \typed{sin 3.14159 1 -20}
  [2.65359e-06, 0.841471, -0.912945]
KeRF> \typed{asin sin 3.14159 1 -20}
  [2.65359e-06, 1, -1.15044]
\end{Verbatim}

\pagebreak
\primdef{sinh}{Hyperbolic Sine}
\texttt{sinh(x)}\\

Calculate the hyperbolic sine of \texttt{x}, expressed in radians. Atomic. The results of \prim{sinh} will always be floating point values.
\begin{Verbatim}
KeRF> \typed{sinh 3.14159 1 -20}
  [11.5487, 1.1752, -2.42583e+08]
\end{Verbatim}

\primdef{sleep}{Sleep}
\texttt{sleep(x)}\\

Delay for at least \texttt{x} milliseconds and then return \texttt{x}.
\begin{Verbatim}
KeRF> \typed{timing 1;}
KeRF> \typed{sleep 50}
  50
    51 ms
KeRF>
\end{Verbatim}

\primdef{sort}{Sort}
\texttt{sort(x)}\\

Sort the elements of the list \texttt{x} in ascending order. Equivalent to \texttt{x[\prim{ascend} x]}.
\begin{Verbatim}
KeRF> \typed{sort "ALPHABETICAL"}
  "AAABCEHILLPT"
KeRF> \typed{sort 27 18 4 9}
  [4, 9, 18, 27]
KeRF> \typed{sort unique "how razorback jumping frogs can level six piqued gymnasts"}
  " abcdefghijklmnopqrstuvwxyz"
\end{Verbatim}

Sort when run on a table sorts in column order, so for maximum performance on time oriented joins, put the time column first in the table.

\pagebreak
\primdefu{sort\_debug}{Sort Debug}{sortDebug}
\texttt{sort\_debug(x)}\\

Return a map containing debugging information about the list or table \texttt{x} which is relevant to the performance and internal datapaths of searching and sorting. If the input is a table which is actually sorted, it will set global attr\_sorted flag if not already set.

\begin{Verbatim}
KeRF> \typed{sort_debug range(4)}
  \{attr_sorted:1, is_array:1, is_enum:0, is_actually_sorted_array:1, is_index:0,
    is_index_working:0, is_table:0, is_table_sorted:0\}

KeRF> \typed{sort_debug "ACED"}
  \{attr_sorted:0, is_array:1, is_enum:0, is_actually_sorted_array:0, is_index:0,
    is_index_working:0, is_table:0, is_table_sorted:0\}

KeRF> \typed{sort_debug 27}
  \{attr_sorted:1, is_array:0, is_enum:0, is_actually_sorted_array:0, is_index:0,
    is_index_working:0, is_table:0, is_table_sorted:0\}

KeRF> \typed{sort_debug \{\{a: 4 2 1\}\}}
  \{attr_sorted:0, is_array:0, is_enum:0, is_actually_sorted_array:0, is_index:0,
    is_index_working:0, is_table:1, is_table_sorted:0\}
\end{Verbatim}

For tables, the sort attribute is for the first column of the table.

\primdef{split}{Split List}
\texttt{split(x, y)}\\

Subdivide the list \texttt{y} at the index/indices given by \texttt{x}. Equivalent to \texttt{y[\prim{xvals} \prim{part} \prim{rsum} (\prim{xkeys} y) \prim{in} x]}.

\begin{Verbatim}
KeRF> \typed{split(4 9, "SomeWordsTogether")}
  ["Some", "Words", "Together"]
KeRF> \typed{3 split "ABCDEF"}
  ["ABC", "DEF"]
KeRF> \typed{split(0 1 3 5, 11 22 33 44 55)}
  [[11], [22, 33], [44, 55]]
\end{Verbatim}

\primdef{sqrt}{Square Root}
\texttt{sqrt(x)}\\

Calculate the square root of \texttt{x}. Atomic.
\begin{Verbatim}
KeRF> \typed{sqrt 2 25 100}
  [1.41421, 5, 10.0]
\end{Verbatim}

\pagebreak
\primdef{stamp}{Cast to Stamp}
\texttt{stamp(x)}\\

Cast \texttt{x} to a timestamp. Atomic down to strings. To convert a string to a timestamp using a custom format, see \primu{parse\_stamp}{parseStamp}.
\begin{Verbatim}
KeRF> \typed{stamp []}
  STAMP[]
KeRF> \typed{stamp [0, "2001.02.03"]}
  [00:00:00.000, 2001.02.03]
\end{Verbatim}

\primdefu{stamp\_diff}{Timestamp Difference}{stampDiff}
\texttt{stamp\_diff(x, y)}\\

Calculate the difference between the timestamps \texttt{x} and \texttt{y} in nanoseconds.
\begin{Verbatim}
KeRF> \typed{t: now(); sleep(10); stamp_diff(now(), t)}
  10302000
KeRF> \typed{t: now(); sleep(10); stamp_diff(t, now())}
  -10874000
\end{Verbatim}

\primdef{std}{Standard Deviation}
\texttt{std(x)}\\

Calculate the standard deviation of the elements of the list \texttt{x}. Equivalent to \prim{sqrt} \prim{var}.
\begin{Verbatim}
KeRF> \typed{std 4 7 19 2 0 -2}
  6.87992
KeRF> \typed{std \{a: 4 1 0\}}
  \{a:1.69967\}
\end{Verbatim}

\primdef{string}{Cast to String}
\texttt{string(x)}\\

Convert the value \texttt{x} to a string. Atomic. If you wish to recursively convert an entire data structure to a string, use \prim{rep}.
\begin{Verbatim}
KeRF> \typed{string 990}
  "990"
KeRF> \typed{string 15 9 10}
  ["15", "9", "10"]
KeRF> \typed{string \{a:4 5\}}
  \{a:["4", "5"]\}
\end{Verbatim}

\primdef{subtract}{Subtract}
\texttt{subtract(x, y)}\\

Equivalent to \prim{minus}.

\primdef{sum}{Sum}
\texttt{sum(x)}\\

Calculate the sum of the elements of the list \texttt{x}.
\begin{Verbatim}
KeRF> \typed{sum 4 3 9}
  16
KeRF> \typed{sum 5}
  5
KeRF> \typed{sum []}
  0
\end{Verbatim}

\primdef{table}{Make Table}
\texttt{table(columns, values)}\\

Make a table from a list of column names and a matrix of values. A table-based equivalent of \prim{map}.
\begin{Verbatim}
KeRF> \typed{table(["foo", "bar"],[1 2 3, 2001.1.1 2001.1.2 2001.1.3])}
┌───┬──────────┐
│foo│bar       │
├───┼──────────┤
│  1│2001.01.01│
│  2│2001.01.02│
│  3│2001.01.03│
└───┴──────────┘
\end{Verbatim}

\primdef{tables}{Tables}
\texttt{tables()}\\

Generate a list of the names of all currently loaded tables.
\begin{Verbatim}
KeRF> \typed{tables()}
  []
KeRF> \typed{t: \{\{a: 1 2 3, b: 4 5 6\}\};}
KeRF> \typed{tables()}
  ["t"]
\end{Verbatim}

\pagebreak
\primdef{take}{Take}
\texttt{take(x, y)}\\

Create a list containing the first \texttt{x} elements of \texttt{y}, looping \texttt{y} as necessary. If \texttt{x} is negative, take backwards from the last to the first. Equivalent to \prim{first}.
\begin{Verbatim}
KeRF> \typed{take(3, \textasciigrave"A")}
  "AAA"
KeRF> \typed{take(2, range(5))}
  [0, 1]
KeRF> \typed{take(8, range(5))}
  [0, 1, 2, 3, 4, 0, 1, 2]
KeRF> \typed{take(-3, range(5))}
  [2, 3, 4]
\end{Verbatim}

The symbol \texttt{\^} is equivalent to \prim{take} when used as a binary operator:
\begin{Verbatim}
KeRF> \typed{3^"ABCDE"}
  "ABC
\end{Verbatim}

\primdef{tan}{Tangent}
\texttt{tan(x)}\\

Calculate the tangent of \texttt{x}, expressed in radians. Atomic. The results of \prim{tan} will always be floating point values.
\begin{Verbatim}
KeRF> \typed{tan 0.5 -0.2 1 4}
  [0.546302, -0.20271, 1.55741, 1.15782]
KeRF> \typed{atan(tan 0.5 -0.2 1 4)}
  [0.5, -0.2, 1, 0.858407]
\end{Verbatim}

\primdef{tanh}{Hyperbolic Tangent}
\texttt{tanh(x)}\\

Calculate the hyperbolic tangent of \texttt{x}, expressed in radians. Atomic. The results of \prim{tanh} will always be floating point values.
\begin{Verbatim}
KeRF> \typed{tanh 3.14159 1 -20}
  [0.996272, 0.761594, -1.0]
\end{Verbatim}

\pagebreak
\primdef{times}{Multiplication}
\texttt{times(x, y)}\\

Calculate the product of \texttt{x} and \texttt{y}. Fully atomic.
\begin{Verbatim}
KeRF> \typed{times(3, 5)}
  15
KeRF> \typed{times(1 2 3, 5)}
  [5, 10, 15]
KeRF> \typed{times(3, 5 8 9)}
  [15, 24, 27]
KeRF> \typed{times(10 15 3, 8 2 4)}
  [80, 30, 12]
\end{Verbatim}

The symbol \texttt{*} is equivalent to \prim{times} when used as a binary operator:
\begin{Verbatim}
KeRF> \typed{1 2 3*2}
  [2, 4, 6]
\end{Verbatim}

\primdef{timing}{Timing}
\texttt{timing(x)}\\

If \texttt{x} is truthy, enable timing. Otherwise, disable it. Returns a boolean timing status. When timing is active, all operations will print their approximate runtime in milliseconds after completing.
\begin{Verbatim}
KeRF> \typed{timing(1)}
  1
KeRF> \typed{sum range exp(2, 24)}
  140737479966720

    203 ms
KeRF> \typed{timing(0)}
  0
\end{Verbatim}

\primdef{tolower}{To Lowercase}
\texttt{tolower(x)}\\

Convert a string \texttt{x} to lowercase. Equivalent to \prim{floor}.

\primdef{toupper}{To Uppercase}
\texttt{toupper(x)}\\

Convert a string \texttt{x} to uppercase. Equivalent to \prim{ceil}.

\pagebreak
\primdef{transpose}{Transpose}
\texttt{transpose(x)}\\

Take the transpose (flip the x and y axes) of a matrix \texttt{x}. Has no effect on atoms or lists of atoms.
\begin{Verbatim}
KeRF> \typed{transpose [1 2 3, 4 5 6, 7 8 9]}
  [[1, 4, 7], 
   [2, 5, 8], 
   [3, 6, 9]]
KeRF> \typed{transpose 1 2 3}
  [1, 2, 3]
\end{Verbatim}

Atoms will ``spread'' as needed to produce a rectangular matrix if the list contains any sublists:
\begin{Verbatim}
KeRF> \typed{transpose [2, 3 4 5, 6]}
  [[2, 3, 6], 
   [2, 4, 6], 
   [2, 5, 6]]
\end{Verbatim}

The symbol \texttt{+} is equivalent to \prim{transpose} when used as a unary operator:
\begin{Verbatim}
KeRF> \typed{+[1 2, 3 4]}
  [[1, 3],
   [2, 4]]
\end{Verbatim}

\primdef{trim}{Trim}
\texttt{trim(x)}\\

Remove leading and trailing whitespace from strings. Atomic.
\begin{Verbatim}
KeRF> \typed{trim(" some text   ")}
  "some text"
KeRF> \typed{trim [" some text   ", "    another", "\textbackslash{}tab\textbackslash{}t"]}
  ["some text", "another", "ab"]
\end{Verbatim}

\primdefu{type\_null}{Type Null}{typeNull}
\texttt{type\_null(x)}\\

Generate the equivalent type-specific null value for \texttt{x}.
\begin{Verbatim}
KeRF> \typed{type_null("ABC")}
  \textasciigrave" "
KeRF> \typed{type_null(1.0)}
  nan
KeRF> \typed{type_null(1)}
  NAN
KeRF> \typed{type_null(now())}
  00:00:00.000
\end{Verbatim}

\primdef{uneval}{Uneval}
\texttt{uneval(x)}\\

Equivalent to \primu{json\_from\_kerf}{jsonFromKerf}.

\primdef{union}{Set Union}
\texttt{union(x, y)}\\

Construct an unsorted list of the unique elements in either \texttt{x} or \texttt{y}. Equivalent to \prim{distinct} \prim{join}.
\begin{Verbatim}
KeRF> \typed{union(2, 4 5)}
  [2, 4, 5]
KeRF> \typed{union([], 2)}
  [2]
KeRF> \typed{union(2 3 4, 1 3 9)}
  [2, 3, 4, 1, 9]
\end{Verbatim}

\primdef{unique}{Unique Elements}
\texttt{unique(x)}\\

Equivalent to \prim{distinct}.

\primdef{unzip}{Decompress Object}
\texttt{unzip(x)}\\

Decompress a string, as produced by \prim{zip}, to reconstruct a Kerf object.
\begin{Verbatim}
KeRF> \typed{unzip zip 2048 take "ABCD"}
  "ABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCD
   ABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCD
   ABCDABCDABCDABCDA..."
\end{Verbatim}

\primdef{var}{Variance}
\texttt{var(x)}\\

Calculate the variance of the elements of a list \texttt{x}. Equivalent to \texttt{(\prim{sum} (x - \prim{avg} x)**2)/\primu{count\_nonnull}{countNonnull} x}.
\begin{Verbatim}
KeRF> \typed{var []}
  nan
KeRF> \typed{var 4 3 8 2}
  5.1875
KeRF> \typed{sqrt var 4 3 8 2}
  2.27761
\end{Verbatim}

\primdef{which}{Which}
\texttt{which(x)}\\

For each index $i$ of the list \texttt{x}, produce \texttt{x[i]} copies of \texttt{i}:
\begin{Verbatim}
KeRF> \typed{which 1 2 1 4}
  [0, 1, 1, 2, 3, 3, 3, 3]
KeRF> \typed{which 1 2 3}
  [0, 1, 1, 2, 2, 2]
KeRF> \typed{which 1 1 1}
  [0, 1, 2]
\end{Verbatim}

This operation is most often used to retrieve a list of the indices of nonzero elements of a boolean vector:
\begin{Verbatim}
KeRF> \typed{which 0 0 1 0 1 1 0 1}
  [2, 4, 5, 7]
\end{Verbatim}

The symbol \texttt{?} is equivalent to \prim{which} when used as a unary operator:
\begin{Verbatim}
KeRF> \typed{?0 0 1 0 1 1 0 1}
  [2, 4, 5, 7]
\end{Verbatim}

\pagebreak
\primdefu{write\_csv\_from\_table}{Write CSV From Table}{writeCsvFromTable}
\texttt{write\_csv\_from\_table(filename, table)}\\

Write \texttt{table} to disk as a Comma-Separated Value file called \texttt{filename}.

Equivalent to \primu{write\_delimited\_file\_from\_table}{writeDelimitedFileFromTable}\texttt{(",", filename, table)}.

\primdefu{write\_delimited\_file\_from\_table}{Write Delimited File From Table}{writeDelimitedFileFromTable}
\texttt{write\_delimited\_file\_from\_table(delimiter, filename, table)}\\

Write \texttt{table} to disk as \texttt{filename} using newlines to separate rows and \texttt{delimiter} to separate columns. The file will be written with a header row corresponding to the keys of the columns of \texttt{table}. Returns the number of bytes written to the file.

\begin{Verbatim}
KeRF> \typed{t: \{\{a: 1 2 3, b:["one", "two", "three"]\}\};}
KeRF> \typed{write_delimited_file_from_table("|", "example.psv", t)}
  23
KeRF> \typed{shell("wc -c example.psv")}
  ["      23 example.psv"]
KeRF> \typed{shell("cat example.psv")}
  ["a|b", "1|one", "2|two", "3|three"]
\end{Verbatim}

\primdefu{write\_striped\_to\_path}{Write Striped File To Path}{writeStripedToPath}
\texttt{write\_striped\_to\_path(path, x)}\\

Write \texttt{x} to disk at \texttt{path} as a striped file. See \hyperref[sec:stripeio]{\textbf{Striped Files}}.

\primdefu{write\_text}{Write Text}{writeText}
\texttt{write\_text(filename, x)}\\

Write the value \texttt{x} to a text file \texttt{filename}, creating the file as necessary. See \hyperref[sec:fileio]{\textbf{File I/O}}.

\primdefu{write\_to\_path}{Write to Path}{writeToPath}
\texttt{write\_to\_path(filename, x)}\\

Write the value \texttt{x} to a binary file \texttt{filename}, creating the file as necessary. See \hyperref[sec:fileio]{\textbf{File I/O}}.

\pagebreak
\primdef{xkeys}{Object Keys}
\texttt{xkeys(x)}\\

Produce a list of keys for a map, table or list \texttt{x}.
\begin{Verbatim}
KeRF> \typed{xkeys 33 14 9}
  [0, 1, 2]
KeRF> \typed{xkeys \{a: 42, b: 49\}}
  ["a", "b"]
KeRF> \typed{xkeys \{\{a: 42, b: 49\}\}}
  ["a", "b"]
\end{Verbatim}

\primdef{xvals}{Object Values}
\texttt{xvals(x)}\\

Produce a list of values for a map or table \texttt{x}. If \texttt{x} is a list, produce a list of valid indices to \texttt{x}.

\begin{Verbatim}
KeRF> \typed{xvals 33 14 9}
  [0, 1, 2]
KeRF> \typed{xvals \{a: 42, b: 49\}}
  [42, 49]
KeRF> \typed{xvals \{\{a: 42, b: 49\}\}}
  [[42], [49]]
\end{Verbatim}

\primdef{zip}{Compress Object}
\texttt{zip(x)}\\

Produce a string representing a compressed version of \texttt{x} suitable for reconstruction with \prim{unzip}.

\begin{Verbatim}
KeRF> \typed{count 2048 take "ABCD"}
  2048
KeRF> \typed{count zip 2048 take "ABCD"}
  1316
KeRF> \typed{zip 2048 take "ABCD"}
  "\{\{\textbackslash{}"sJ\textbackslash{}u0000\textbackslash{}u0000\textbackslash{}u0000\textbackslash{}u00ca\textbackslash{}u0000\textbackslash{}u0000\textbackslash{}u0000\textbackslash{}u00ca\textbackslash{}u0000\textbackslash{}u0000\textbackslash{}u0000...
\end{Verbatim}

\pagebreak
\section {Combinator Reference}

\combdef{converge}{Converge}

Given a unary function, apply it to a value repeatedly until it does not change or the next iteration will repeat the initial value. Some functional languages refer to this operation as \texttt{fixedpoint}.
\begin{Verbatim}
KeRF> \typed{\{[x] floor x/2\} converge 32}
  0
KeRF> \typed{\{[x] mod(x+1, 5)\} converge 0}
  4
KeRF> \typed{\{[x] display x; mod(x+1, 5)\} converge 3}
3
4
0
1
2
  2
\end{Verbatim}

If a numeric left argument is provided, instead repeatedly apply the function some number of times:
\begin{Verbatim}
KeRF> \typed{3 \{[x] floor x/2\} converge 32}
  4
KeRF> \typed{3 \{[x] x*2\} converge 32}
  256
KeRF> \typed{5 \{[x] join("A", x)\} converge "B"}
  "AAAAAB"
\end{Verbatim}

Applied to a binary function, \comb{converge} is equivalent to \comb{fold}.

\combdef{deconverge}{Deconverge}

\comb{deconverge} is similar to \comb{converge}, except it gathers a list of intermediate results.
\begin{Verbatim}
KeRF> \typed{\{[x] floor x/2\} deconverge 32}
  [32, 16, 8, 4, 2, 1, 0]
KeRF> \typed{\{[x] mod(x+1, 5)\} deconverge 1}
  [1, 2, 3, 4, 0]
KeRF> \typed{3 \{[x] floor x/2\} deconverge 32}
  [32, 16, 8, 4]
KeRF> \typed{3 \{[x] x*2\} deconverge 32}
  [32, 64, 128, 256]
\end{Verbatim}

Applied to a binary function, \comb{deconverge} is equivalent to \comb{unfold}.

\pagebreak
\combdef{fold}{Fold}

Given a binary function, apply it to pairs of the elements of a list from left to right, carrying the result forward on each step. Some functional languages refer to this operation as \texttt{foldl}.
\begin{Verbatim}
KeRF> \typed{add fold 1 2 3 4}
  10
KeRF> \typed{\{[a,b] join(enlist a, b)\} fold 1 2 3 4}
  [[[1, 2], 3], 4]
\end{Verbatim}

Note that the function will not be applied if \comb{fold}ed over an empty or 1-length list:
\begin{Verbatim}
KeRF> \typed{\{[a,b] out "nope"; a+b\} fold [5]}
  5
KeRF> \typed{\{[a,b] out "nope"; a+b\} fold 1 2}
nope  3
\end{Verbatim}

It is also possible to supply an initial value for the \comb{fold} as a left argument:
\begin{Verbatim}
KeRF> \typed{0 \{[a,b] join(enlist a, b)\} fold 1 2 3}
  [[[0, 1], 2], 3]
KeRF> \typed{7 \{[a,b] out "yep"; a+b\} fold 5}
yep  12
\end{Verbatim}

The symbol \texttt{\char`\\/} is equivalent to \comb{fold}:
\begin{Verbatim}
KeRF> \typed{add \textbackslash/ 1 2 3}
  6
KeRF> \typed{7 add \textbackslash/ 5}
  12
\end{Verbatim}

Applied to a unary function, \comb{fold} is equivalent to \comb{converge}.

\combdef{mapback}{Map Back}

Given a binary function, \comb{mapback} pairs up each value of a list with its predecessor and applies the function to these values. The first item of the resulting list will be the first item of the original list:

\begin{Verbatim}
KeRF> \typed{join mapback 1 2 3}
  [1, 
   [2, 1], 
   [3, 2]]
\end{Verbatim}

A common application of \comb{mapback} is to calculate deltas between successive elements of a list:

\begin{Verbatim}
KeRF> \typed{- mapback 5 3 2 9}
  [5, -2, -1, 7]
\end{Verbatim}

If a left argument is provided, it will be used as the previous value of the right argument's first value:
\begin{Verbatim}
KeRF> \typed{1 join mapback 2 3 4}
  [[2, 1], 
   [3, 2], 
   [4, 3]]
\end{Verbatim}

The symbol \texttt{\char`\\\~} is equivalent to \comb{mapback}:
\begin{Verbatim}
KeRF> \typed{0 != \textbackslash~ 1 1 0 1 0 0 0}
  [1, 0, 1, 1, 1, 0, 0]
\end{Verbatim}

\combdef{mapcores}{Map to Cores}

Similar to \comb{mapdown}, except it distributes work to multiple CPU cores (as available) and performs work in parallel. There is some overhead to distributing work and collecting results, so only use \comb{mapcores} after careful profiling. For a realistic use case, see the discussion of optimizing a \hyperref[mapcoresBase64]{\textbf{Base64 Encoder}}.
\begin{Verbatim}
KeRF> \typed{time: \{[f] s:now(); v:f(); [v, stamp_diff(now(), s)]\};}

KeRF> \typed{time \{[] \{[x] sleep 100; x*2\} mapdown 1 3 7 9\}}
  [[2, 6, 14, 18], 404506000]

KeRF> \typed{time \{[] \{[x] sleep 100; x*2\} mapcores 1 3 7 9\}}
  [[2, 6, 14, 18], 184118000]
\end{Verbatim}

Every parallel worker is given its own independent environment tree, and writes to global variables are discarded after results are gathered. Side effects to IO devices are performed in an arbitrary order unless otherwise synchronized.
\begin{Verbatim}
KeRF> \typed{a: [0];}
KeRF> \typed{\{[x] a[0]:2*x; a[0]\} mapdown 1 3 7 9}
  [2, 6, 14, 18]
KeRF> \typed{a}
  [18]

KeRF> \typed{a: [0];}
KeRF> \typed{\{[x] a[0]:2*x; a[0]\} mapcores 1 3 7 9}
  [2, 6, 14, 18]
KeRF> \typed{a}
  [0]

KeRF> \typed{\{[x] display x; 2*x\} mapcores 1 3 7 9}
3
7
9
1
  [2, 6, 14, 18]
\end{Verbatim}

Uses of \comb{mapcores} can be nested, generally with diminishing returns. The current implementation arbitrarily caps nesting at 2:
\begin{Verbatim}
KeRF> \typed{\{[x] \{[x] 2*x\} mapcores range x\} mapcores 3 2 5}
  [[0, 2, 4], 
 [0, 2], 
 [0, 2, 4, 6, 8]]

KeRF> \typed{\{[x] \{[x] \{[x] 2*x\} mapcores range x\} mapcores range x\} mapcores 2 3}
  ...nge x\} mapcores range x\} mapcores 2 3
                              ^
 Parallel execution error
\end{Verbatim}

\combdef{mapdown}{Map Down}

Apply a unary function to every element of a list, yielding a new list of the same size. Some functional programming languages refer to this as simply \texttt{map}. \comb{mapdown} can be used to achieve a similar effect to how atomic built-in functions naturally ``push down'' onto the values of lists.

\begin{Verbatim}
KeRF> \typed{negate mapdown 2 -5}
  [-2, 5]
KeRF> \typed{\{[n] 3*n\} mapdown 2 5 9}
  [6, 15, 27]
\end{Verbatim}

Given a binary function and a left argument, \comb{mapdown} pairs up sequential values from two equal-length lists and applies the function to these pairs. Some functional programming languages refer to this as \texttt{zip}, meshing together a pair of lists like the teeth of a zipper:
\begin{Verbatim}
KeRF> \typed{1 2 3 join mapdown 4 5 6}
  [[1, 4], 
   [2, 5], 
   [3, 6]]
\end{Verbatim}

\comb{mapdown} also works with maps and tables:
\begin{Verbatim}
KeRF> \typed{count mapdown \{a: 1 2, b: 3 4 5, c: 6\}}
  [2, 3, 1]
KeRF> \typed{reverse mapdown \{\{a: 1 2, b: 3 4\}\}}
  [[2, 1], [4, 3]]
\end{Verbatim}

The symbol \texttt{\char`\\=} is equivalent to \comb{mapdown}:
\begin{Verbatim}
KeRF> \typed{\{[n] 3*n\} \textbackslash= 2 5 9}
  [6, 15, 27]
\end{Verbatim}

\combdef{mapleft}{Map Left}

Given a binary function, apply it to each of the values of the left argument and the right argument, gathering the results in a list.
\begin{Verbatim}
KeRF> \typed{1 2 3 join mapleft 4}
  [[1, 4], 
   [2, 4], 
   [3, 4]]
\end{Verbatim}

The symbol \texttt{\char`\\<} is equivalent to \comb{mapleft}.

\combdef{mapright}{Map Right}

Given a binary function, apply it to a left argument and each of the values of the right argument, gathering the results in a list. \comb{mapright}, like \comb{mapdown}, provides a way of ``pushing a function down onto'' data or overriding existing atomicity:
\begin{Verbatim}
KeRF> \typed{1 join mapright 2 3 4}
  [[1, 2], 
   [1, 3], 
   [1, 4]]
\end{Verbatim}

\comb{mapright} and \comb{mapleft} can be used to take the \emph{cartesian product} of two lists:
\begin{Verbatim}
KeRF> \typed{0 1 2 add 0 1 2}
  [0, 2, 4]
KeRF> \typed{0 1 2 add mapright 0 1 2}
  [[0, 1, 2], 
   [1, 2, 3], 
   [2, 3, 4]]
\end{Verbatim}

The symbol \texttt{\char`\\>} is equivalent to \comb{mapright}.

\combdef{reconverge}{Reconverge}

Equivalent to \comb{unfold}.

\combdef{reduce}{Reduce}

Equivalent to \comb{fold}.

\combdef{refold}{Refold}

Equivalent to \comb{unfold}.

\combdef{rereduce}{Re-Reduce}

Equivalent to \comb{unfold}.

\combdef{unfold}{Unfold}

\comb{unfold} is similar to \comb{fold}, except it gathers a list of intermediate results. This can often provide a useful way to debug the behavior of \comb{fold}.
\begin{Verbatim}
KeRF> \typed{add unfold 1 2 3 4}
  [1, 3, 6, 10]
KeRF> \typed{100 add unfold 1 2 3 4}
  [101, 103, 106, 110]
KeRF> \typed{\{[a,b] join(enlist a, b)\} unfold 1 2 3 4}
  [1, 
   [1, 2], 
   [[1, 2], 3], 
   [[[1, 2], 3], 4]]
\end{Verbatim}

The symbol \texttt{\char`\\\char`\\} is equivalent to \comb{unfold}:
\begin{Verbatim}
KeRF> \typed{add \textbackslash\textbackslash 1 2 3}
  [1, 3, 6]
KeRF> \typed{7 add \textbackslash\textbackslash 5}
  [12]
\end{Verbatim}

Applied to a unary function, \comb{unfold} is equivalent to \comb{deconverge}.

\pagebreak
\section {Global Reference}

\subsection{Environment}

\constdef{.Argv}{Arguments}{argv}
A list of the arguments provided to Kerf at the command line.
\begin{Verbatim}
>\typed{kerf -q foo}
File handle status failed during directory check.: No such file or directory
KeRF> \typed{.Argv}
  ["kerf", "-q", "foo"]
\end{Verbatim}

\constdef{.Help}{Function Reference}{help}
A table which can be examined at the command line, listing subject, name of item of interest, usage and description.  See \prim{help} for more information.

\subsection{Math}

\constdef{.Math.BILLION}{Billion}{mathBillion}
Constant representing $\lfloor 10^9 \rfloor$.

\constdef{.Math.E}{E}{mathE}
Constant representing Euler's number. \texttt{2.7182818284590452353602}.

\constdef{.Math.TAU}{Tau}{mathTau}
Constant representing $2\pi$. \texttt{6.2831853071795864769252}.

\subsection{Net}
\constdef{.Net.client}{Client}{netClient}
During IPC execution, contains a constant representing the current client's unique handle. See \hyperref[sec:netio]{\textbf{Network I/O}}.

\constdef{.Net.on\_close}{On Close}{netOnClose}
If defined, an IPC server will call this single-argument function with a client handle when that client closes its connection. See \hyperref[sec:netio]{\textbf{Network I/O}}.

\constdef{.Net.parse\_request}{Parse Request}{netParseRequest}
An HTTP server will call this single-argument function with the text of a completed GET request. The return value will be passed to the browser, provided the type is character vector. See \hyperref[sec:netio]{\textbf{Network I/O}}.

\pagebreak
\subsection{Parse}
\constdef{.Parse.strptime\_format}{Time Stamp Format}{parseStrptimeFormat}

Specifies the format used for formatting and parsing dates and time stamps from delimited files when the field specifier is \texttt{Z} or \texttt{9}. Builds directly on the standard C function \texttt{strptime}. See \primu{format\_stamp}{formatStamp} for details.

\vspace{0.5cm}

By default, \texttt{\%d-\%b-\%y \%H:\%M:\%S}. \\

\constdef{.Parse.strptime\_format2}{Time Format}{parseStrptimeFormat2}
Specifies the format used for formatting and parsing timestamps from delimited files when the field specifier is \texttt{Y}. Used for parsing time-only columns in data files where dates and times are in separate columns. \\

\subsection{Print}
\constdef{.Print.stamp\_format}{Print Stamp Format}{printStampFormat}

If set, specifies the format used for printing timestamps. See \primu{format\_stamp}{formatStamp} for details. Setting this global is particularly useful if you want to see a finer-grained display of timestamps which includes nanoseconds.

\pagebreak
\section {Programming Techniques}
This section contains case studies illustrating how Kerf can be used to solve problems, ranging from simple to complex. We will build up solutions step by step and consider tradeoffs in performance and style.

\subsection {Reversing a Map}
A map links a set of keys with a set of values. It is easy and efficient to use a key to look up the associated value. Sometimes is desirable to go the other way- using a value to look up the associated key. One way to approach this problem might be to iterate through each key in the map until we found one which is associated with our target value:

\begin{Verbatim}
def find_key(m, val) \{
	keys: xkeys m
	for(i: 0; i < len(keys); i: i+1) \{
		if (m[keys[i]] == val) \{ return keys[i] \}
	\}
	return null
\}
\end{Verbatim}

As the number of keys in the map scales up, the amount of time this function takes to run increases proportionally. If we need to perform many repeated reverse lookups against a large map, this approach will be prohibitively slow.

\vspace{0.5cm}

As a general rule of thumb when programming, if something is too expensive to calculate, cache it. By writing a function which analyzes a map and constructs a new map which ``reverses'' the keys and values of the original, we can pay this construction cost once and then achieve efficient reverse-lookups.

\vspace{0.5cm}

There are several ways to approach this problem. A programmer used to imperative programming languages might come up with something like this:

\begin{Verbatim}
def map_reverse_1(m) \{
	r: \{\}
	keys: xkeys m
	vals: xvals m
	for(i: 0; i < len(keys); i: i+1) \{
		r[vals[i]]: keys[i]
	\}
	return r
\}
\end{Verbatim}

Perhaps you want to get fancy and try to represent the same algorithm using the combinator \comb{fold}?

\begin{Verbatim}
\{\} \{[m, e] m[e[0]]: e[1]\} fold transpose([xvals m, xkeys m])
\end{Verbatim}

The simplest approach is to take advantage of the \prim{map} built-in function:

\begin{Verbatim}
def map_reverse_2(m) \{
	return map(xvals m, xkeys m)
\}
\end{Verbatim}

\pagebreak
All of these solutions are making an unsafe assumption. The keys of a map are always unique by definition, but what happens if the values are not unique?

\begin{Verbatim}
KeRF> \typed{map_reverse_2(\{a: "A", b:"B", c:"C"\})}
  \{A:"a", B:"b", C:"c"\}
KeRF> \typed{map_reverse_2(\{a: "A", b:"B", c:"A"\})}
  \{A:"a", B:"b"\}
\end{Verbatim}

We've lost information! A more robust map reversal routine should gather the keys of repeated values as a list, producing a result more like:

\begin{Verbatim}
KeRF> \typed{map_reverse_3(\{a: "A", b:"B", c:"C"\})}
  \{A:["a","c"], B:["b"]\}
\end{Verbatim}

First, let's look at an imperative approach to solving the problem. We can iterate through the keys of the original map, as before. Instead of storing the key directly in the result map, we will append it to a list stored in the map. This requires us to first ensure that any slot in the result map is initialized with an empty list:
\begin{Verbatim}
def map_reverse_3(m) \{
	r: \{\}
	keys: xkeys m
	vals: xvals m
	for(i: 0; i < len(keys); i: i+1) \{
		if (not r has_key vals[i]) \{ r[vals[i]]: [] \}
		r[vals[i]]: join(r[vals[i]], enlist keys[i])
	\}
	return r
\}
\end{Verbatim}

The \prim{enlist} is important here- without it, string keys would be mashed together:
\begin{Verbatim}
KeRF> \typed{join([], "foo")}
  "foo"
KeRF> \typed{join("foo", "bar")}
  "foobar"
KeRF> \typed{join([], enlist "foo")}
  ["foo"]
KeRF> \typed{join(["foo"], enlist "bar")}
  ["foo", "bar"]
\end{Verbatim}

We can simplify this slightly by using ``spread assignment'' to initialize our result map with empty lists in every entry:
\begin{Verbatim}
	...
	r[vals]: [[]]
	for(i: 0; i < len(keys); i: i+1) \{
		r[vals[i]]: join(r[vals[i]], enlist keys[i])
	\}
	...
\end{Verbatim}

What happens if we leave out this initialization entirely? Try it!

\pagebreak
Now let's look at a functional approach to solving this problem. If we partition the value set of the original map, we obtain lists of the indices of the values which are identical:
\begin{Verbatim}
KeRF> \typed{m: \{a: "A", b:"B", c:"A"\}}
  \{a:"A", b:"B", c:"A"\}
KeRF> \typed{xvals m}
  ["A", "B", "A"]
KeRF> \typed{part xvals m}
  \{A:[0, 2], B:[1]\}
\end{Verbatim}

Since the key and value vectors produced by \prim{xkeys} and \prim{xvals} line up, we could also use those indices to obtain the corresponding keys for each group of values. Kerf's powerful indexing facilities make this simple:
\begin{Verbatim}
KeRF> \typed{xkeys m}
  ["a", "b", "c"]
KeRF> \typed{xvals part xvals m}
  [[0, 2], [1]]
KeRF> \typed{(xkeys m)[xvals part xvals m]}
  [["a", "c"], ["b"]]
\end{Verbatim}

Now we have what we need to assemble the result, so we use \prim{map} to join the unique elements of the original value set with the lists of corresponding keys we computed previously. The \prim{unique} function collects results in the order they appear, just like \prim{part}, so everything will line up properly:
\begin{Verbatim}
def map_reverse_4(m) \{
	nk: unique xvals m
	nv: (xkeys m)[xvals part xvals m]
	return map(nk, nv)
\}
\end{Verbatim}

Notice how we were able to use the Kerf REPL and a single working example to experiment interactively and then distill the results into a general definition. It is very natural to develop functional solutions to problems in this manner. Manipulating an entire data structure at once often results in a simpler solution with fewer conditionals and loops than trying to solve a problem ``one step at a time''.

\vspace{0.5cm}

It is also possible to write this as a more compact one-liner by avoiding intermediate variables and using some of the symbolic shorthands for \prim{map} (\texttt{!}), \prim{unique} (\texttt{\%}), \prim{enumerate} (\texttt{\textasciicircum}) and \prim{part} (\texttt{\&}), but the result is much harder to read and understand at a glance:
\begin{Verbatim}
\{[m] (\%xvals m)!(^m)[xvals(&xvals m)]\}
\end{Verbatim}

Shorthand is a nice way to save typing at the REPL, but favor a more relaxed, verbose style when writing larger programs- future maintainers (yourself included) will be thankful! Use Kerf's syntactic alternatives- infix function calls, optional parentheses, function aliases, etc.- to write your programs in the clearest, most readable way possible.

\pagebreak
\subsection{Run-Length Encoding}
Run-Length Encoding (RLE) is a simple means of compressing data. Wherever there is a repeated run of identical elements, instead of storing each element store a single copy of the element and the length of the run. We will use this problem as an opportunity to gain familiarity with more of Kerf's combinators and the elegance of tacit definitions.

\vspace{0.5cm}

If our input list looked like:
\begin{Verbatim}
"AAABBAAAAAAA"
\end{Verbatim}

An RLE-compressed representation might look like:
\begin{Verbatim}
[[3, \textasciigrave"A"], [2, \textasciigrave"B"], [7, \textasciigrave"A"]]
\end{Verbatim}

Let's start by writing a \emph{decompressor}- given an RLE-compressed list, reconstruct the original. For a given element of the list, we can use \prim{take} to create a run:
\begin{Verbatim}
KeRF> \typed{p: [3, \textasciigrave"A"]}
  [3, \textasciigrave"A"]
KeRF> \typed{take(p[0], p[1])}
  "AAA"
\end{Verbatim}

One way to apply a binary function to a pair of arguments is to use the combinator \comb{fold}. A fold is like placing a function between the elements of a list. Thus, these two expressions are equivalent:
\begin{Verbatim}
KeRF> \typed{take fold p}
  "AAA"
KeRF> \typed{p[0] take p[1]}
  "AAA"
\end{Verbatim}

We really want to apply \prim{take} to \emph{each} pair in the original list. The combinator \comb{mapdown} applies a unary function to each element of a list, returning a list of results:
\begin{Verbatim}
KeRF> \typed{(take fold) mapdown [[3, \textasciigrave{}A],[2, \textasciigrave{}B],[7, \textasciigrave{}A]]}
  ["AAA", "BB", "AAAAAAA"]
\end{Verbatim}

The parentheses are not required- in this case they are simply making it clearer that the function \comb{mapdown} is applying to each element of the list to the right is ``\prim{take} \comb{fold}''. When combinators are attached to functions, they form new compound functions which can be passed around or stored in variables just like any other function:
\begin{Verbatim}
KeRF> \typed{take fold mapdown [[3, \textasciigrave{}A],[2, \textasciigrave{}B],[7, \textasciigrave{}A]]}
  ["AAA", "BB", "AAAAAAA"]
KeRF> \typed{take fold}
  take fold
\end{Verbatim}

To reproduce the original sequence from this list of runs, we need to join all the runs together. The built-in function \prim{flatten} does exactly what we need. Alternatively, we could use the equivalent \prim{join} \comb{fold}:
\begin{Verbatim}
KeRF> \typed{flatten ["AAA", "BB", "AAAAAAA"]}
  "AAABBAAAAAAA"
KeRF> \typed{join fold ["AAA", "BB", "AAAAAAA"]}
  "AAABBAAAAAAA"
\end{Verbatim}

Putting everything together, we could write a definition for \texttt{rle\_decode} in several ways:
\begin{Verbatim}
def rle_decode(x) \{return flatten take fold mapdown x\}

rle_decode: \{[x] flatten take fold mapdown x\}

rle_decode: flatten take fold mapdown
\end{Verbatim}

This last approach is called a \emph{tacit definition}- it doesn't require naming any variables or arguments. The combinators glue together functions to produce a function that is simply waiting for a right argument. Composing together functions won't always work out this nicely, but when a tacit definition is possible the results can be very aesthetically pleasing, as if there were hardly any syntax to the language at all:

\begin{Verbatim}
KeRF> \typed{rle_decode: flatten take fold mapdown}
  flatten take fold mapdown

KeRF> \typed{rle_decode [[3, \textasciigrave{}A],[2, \textasciigrave{}B],[7, \textasciigrave{}A]]}
  "AAABBAAAAAAA"

KeRF> \typed{flatten take fold mapdown [[3, \textasciigrave{}A],[2, \textasciigrave{}B],[7, \textasciigrave{}A]]}
  "AAABBAAAAAAA"
\end{Verbatim}

Now that we're a bit more comfortable with using combinators, let's tackle the \emph{compressor}- given a list, we want to break it into runs. For each run, we need to determine the first element (or any element, really) and the length of the run.

\vspace{0.5cm}

To find the start of each run, we can compare each element of the list with the item which came before it. If they're different, we are beginning a new run. Otherwise, we're continuing an existing run. The combinator \comb{mapback} applies a function to each element of a list and its predecessor, which is just what we're looking for:
\begin{Verbatim}
KeRF> \typed{!= mapback "AAABBAAAAAAA"}
  [\textasciigrave"A", 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0]
\end{Verbatim}

Well, \emph{nearly} what we're looking for. What's that character doing at the beginning of our result? \comb{mapback} doesn't have anything to pair the first element of a list up with, so by default it leaves that item alone. If we supply a value on the left, \comb{mapback} will use that to pair with the first element of the list on the right. Supplying a \texttt{null} will ensure that the first list element is considered ``not equal to'' this default value:
\begin{Verbatim}
KeRF> \typed{\textasciigrave{}A != mapback "AAABBAAAAAAA"}
  [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0]

KeRF> \typed{\textasciigrave{}B != mapback "AAABBAAAAAAA"}
  [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0]

KeRF> \typed{\textasciigrave{}B != mapback "BAABBAAAAAAA"}
  [0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0]

KeRF> \typed{null != mapback "AAABBAAAAAAA"}
  [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0]
\end{Verbatim}

\pagebreak
The function \prim{which}, given a boolean list, produces a list of the indices of the 1s. If we index into the original list, we can retrieve a list of the items which begin each run, in order:
\begin{Verbatim}
KeRF> \typed{s: "AAABBAAAAAAA"}
  "AAABBAAAAAAA"
KeRF> \typed{null != mapback s}
  [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0]
KeRF> \typed{which null != mapback s}
  [0, 3, 5]
KeRF> \typed{s[which null != mapback s]}
  "ABA"
\end{Verbatim}

Now we just need to find the lengths of each run. Let's consider that vector we already created which identifies run heads. If we take a running sum (\prim{rsum}) of that list, we can uniquely label all the members of each run:
\begin{Verbatim}
KeRF> \typed{h: null != mapback s}
  [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0]
KeRF> \typed{rsum h}
  [1, 1, 1, 2, 2, 3, 3, 3, 3, 3, 3, 3]
\end{Verbatim}

Partitioning these labels will conveniently group them together, and we can count each of the resulting groups:
\begin{Verbatim}
KeRF> \typed{part rsum h}
  {1:[0, 1, 2], 2:[3, 4], 3:[5, 6, 7, 8, 9, 10, 11]}
KeRF> \typed{count mapdown part rsum h}
  [3, 2, 7]
\end{Verbatim}

An alternative to \prim{part} \prim{rsum} would be to use \prim{split}:
\begin{Verbatim}
KeRF> \typed{split(which h, s)}
  ["AAA", "BB", "AAAAAAA"]
KeRF> \typed{count mapdown split(which h, s)}
  [3, 2, 7]
\end{Verbatim}

With the list of counts and the list of values, we can join each to produce the tuples we want. By giving the combinator \comb{mapdown} a left argument and a binary function, we can neatly ``zip'' together our lists:
\begin{Verbatim}
KeRF> \typed{1 2 3 join mapdown "ABC"}
  [[1, \textasciigrave"A"],
   [2, \textasciigrave"B"], 
   [3, \textasciigrave"C"]]
\end{Verbatim}

\pagebreak
Bringing everything together,
\begin{Verbatim}
def rle_encode(s) \{
	heads:   null != mapback s
	vals:    s[which heads]
	counts:  count mapdown part rsum heads
	return   counts join mapdown vals
\}
\end{Verbatim}

For the sake of comparison, here's an imperative solution:
\begin{Verbatim}
def rle_encode_2(s) \{
	r: []
	c: 1
	for(i: 0; i < len(s); i: i+1) \{
		if (s[i] != s[i+1]) \{
			r: join(r, enlist [c, s[i]])
			c: 1
		\} else \{
			c: c+1
		\}
	\}
	return r
\}
\end{Verbatim}

Which of these is easier to understand and reason about? The imperative program is familiar, but involves a number of variables which continuously change throughout execution. Did we make any off-by-one errors? The functional solution replaces loops and conditionals with built-in functions and combinators, and never changes the contents of a variable once it is assigned.

\vspace{0.5cm}

``Readability'' is inherently subjective, so let's compare performance:
\begin{Verbatim}
KeRF> \typed{data: 10000?"ABCD";}
KeRF> \typed{timing 1;}
KeRF> \typed{rle_encode data ;}
    21 ms
KeRF> \typed{rle_encode_2 data ;}
    781 ms
\end{Verbatim}
Kerf executes the functional solution substantially faster. Combinators and built-in functions which operate on entire lists at once are highly optimized and have very little interpreter overhead, so an individual operation can approach native execution speeds. Explicit loops and conditionals force the interpreter to do most of the heavy lifting, which is less efficient.

\pagebreak
\subsection{Base64 Conversion}
Base64 is an encoding scheme which permits storing arbitrary binary data- often ASCII text- using a restricted set of 64 symbols. Base64 encoded data avoids invisible control characters and common delimiters, making it easy to embed inside other document formats or copy and paste between applications without getting scrambled or truncated along the way. In this section we will develop a Base64 encoder and decoder in Kerf, and along the way learn how to dramatically improve the performance of parallel operations by using the \comb{mapcores} combinator.

\vspace{0.5cm}

First, let's review numeric base conversion in general. The numbers we see everywhere on a daily basis use what's called a \emph{positional number system}. In this system, the value of each digit is determined by its position in the overall number. Digits further to the left are ``worth more'' than digits on the right:

\begin{Verbatim}
	┌──── 3 hundreds (3 * 100)
	│┌─── 5 tens     (5 * 10)
	││┌── 7 ones     (7 * 1)
	│││
	357              (3 * 100) + (5 * 10) + (7 * 1)
\end{Verbatim}

With 10 distinct digits (0-9), each successive place to the left is worth 10 times as much as the previous. We call a number system which has 10 distinct digits \emph{base-10} or \emph{decimal}. A number system which only has two distinct digits could be called \emph{base-2} or \emph{binary}. 

\vspace{0.5cm}

Representing a number in different bases can be useful for a variety of applications. Let's begin by developing a routine which can decompose a Kerf integer into its digits:
\begin{Verbatim}
KeRF> \typed{number_digits(357)}
  [3, 5, 7]
\end{Verbatim}

The most obvious approach is to reach for string manipulation. If we cast a number to a string with \prim{rep}, the digits will be successive characters:
\begin{Verbatim}
KeRF> \typed{rep 357}
  "357"
\end{Verbatim}

To obtain the ordinal value of digits, we could convert them to ASCII character codes and subtract the ASCII value of ``0'' (which happens to be 48) or we could simply \prim{eval} each character:
\begin{Verbatim}
KeRF> \typed{(int "357")-48}
  [3, 5, 7]
KeRF> \typed{eval enlist mapdown "357"}
  [3, 5, 7]
\end{Verbatim}

This works fine for base-10, since that is the base Kerf naturally uses for displaying numbers. A string-oriented approach won't help us if we want to support an \emph{arbitrary} base. A more general solution considers the value of each digit's place, as depicted above.

\vspace{0.5cm}

Let's try to calculate the value of each place in a 4-digit base-10 number. There are a number of reasonable approaches- can you think of any aside from those shown here?
\begin{Verbatim}
KeRF> \typed{v: reverse floor 10 pow range 4}         \comment{// pow's result is always a float, so we use floor}
  [1000, 100, 10, 1]
KeRF> \typed{v: reverse (4-1) \{[x] 10*x\} unfold 1}    \comment{// using the 'repeat N times' form of unfold}
  [1000, 100, 10, 1]
\end{Verbatim}

If we have each place value in \texttt{v}, dividing the original number by \texttt{v} and then taking the result modulo the base will determine the digit in each place:
\begin{Verbatim}
KeRF> \typed{floor 357 / v}
  [0, 3, 35, 357]
KeRF> \typed{(floor 357 / v) % 10}
  [0, 3, 5, 7]
\end{Verbatim}

Generalizing,
\begin{Verbatim}
def unpack_digits(base, places, n) \{
	v: reverse floor base pow range places
	return (floor n / v) % base
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{unpack_digits(10, 3, 357)}
  [3, 5, 7]
KeRF> \typed{unpack_digits(2, 8, 61)}
  [0, 0, 1, 1, 1, 1, 0, 1]
\end{Verbatim}

As written, this routine needs to be given the length of the number in digits ahead of time. The \prim{log} with respect to the base (rounding up) can determine how many digits we need to represent the input number in that base:
\begin{Verbatim}
def digits(base, n) \{
	v: reverse floor base pow range ceil log(base, n)
	return (floor n / v) % base
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{digits(10, 65539)}
  [6, 5, 5, 3, 9]
KeRF> \typed{digits(10, 15)}
  [1, 5]
KeRF> \typed{digits(16, 255)}
  [15, 15]
\end{Verbatim}

% note:
% even with some reasonably involved optimization and hoisting, "(int rep n) - 48" is WAY
% faster than the numerical approach to unpacking digits, going against the conventional
% wisdom of string operations being the bad approach for this type of thing. The interpreter
% overhead dominates.

If we have digits and a base, getting back to a number is extremely easy- multiply the digits by their place value and take the sum of the results:
\begin{Verbatim}
KeRF> \typed{3 5 7 * 100 10 1}
  [300, 50, 7]
KeRF> \typed{sum 3 5 7 * 100 10 1}
  357
\end{Verbatim}

Using a similar pattern as before, we'll create a generalized routine for doing this in any base:
\begin{Verbatim}
def pack_digits(base, n) \{
	v: reverse floor base pow range count n
	return sum n * v
\}
\end{Verbatim}

\pagebreak

Base64 encodes 3 bytes of 8-bit ASCII into 4 6-bit characters like so:
\begin{table}[h]
	\centering
	\rowcolors{1}{tableRowColor1}{tableRowColor2}
	\begin{tabular}{| l |c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
		\hline
			\cellcolor{tableHeaderColor} ASCII char &
			\multicolumn{8}{c|}{(} &
			\multicolumn{8}{c|}{D} &
			\multicolumn{8}{c|}{E} \\
		\hline
			\cellcolor{tableHeaderColor} ASCII value &
			\multicolumn{8}{c|}{40} &
			\multicolumn{8}{c|}{68} &
			\multicolumn{8}{c|}{69} \\
		\hline
			\cellcolor{tableHeaderColor} Binary &
			0&0&1&0&1&0&0&0&0&1&0&0&0&1&0&0&0&1&0&0&0&1&0&1\\
		\hline
			\cellcolor{tableHeaderColor} Index &
			\multicolumn{6}{c|}{10} &
			\multicolumn{6}{c|}{4}  &
			\multicolumn{6}{c|}{17} &
			\multicolumn{6}{c|}{5} \\
		\hline
			\cellcolor{tableHeaderColor} Base64 &
			\multicolumn{6}{c|}{K} &
			\multicolumn{6}{c|}{E} &
			\multicolumn{6}{c|}{R} &
			\multicolumn{6}{c|}{F} \\
		\hline
	\end{tabular}
\end{table}

The characters used to represent the 64 distinct values of each 6-bit chunk vary from implementation to implementation, but a common scheme uses the uppercase alphabet followed by the lowercase alphabet, the digits 0 through 9 and finally the characters \texttt{+} and \texttt{/}:

\begin{Verbatim}
KeRF> \typed{int "AZaz09+/"}
  [65, 90, 97, 122, 48, 57, 43, 47]
KeRF> \typed{b64: char range(65, 91)#range(97, 123)#range(48, 58)#43#47}
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\textbackslash/"
KeRF> \typed{count b64}
  64
\end{Verbatim}

Using the definitions we've written so far, it is straightforward to do a conversion from ASCII into Base64 following the steps shown in the figure above. Convert characters to indices with \prim{int}, break those indices into binary digits, \prim{flatten} the list of bits and re-slice it into 6-bit fields with \prim{ngram}, convert back to decimal and then index through the lookup table we just built. Step by step,
\begin{Verbatim}
KeRF> \typed{int "(DE"}
  [40, 68, 69]
KeRF> \typed{\{[x] unpack_digits(2, 8, x)\} mapdown int "(DE"}
  [[0, 0, 1, 0, 1, 0, 0, 0], 
   [0, 1, 0, 0, 0, 1, 0, 0], 
   [0, 1, 0, 0, 0, 1, 0, 1]]
KeRF> \typed{b: flatten \{[x] unpack_digits(2, 8, x)\} mapdown int "(DE"}
  [0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1]
KeRF> \typed{6 ngram b}
  [[0, 0, 1, 0, 1, 0], 
   [0, 0, 0, 1, 0, 0], 
   [0, 1, 0, 0, 0, 1], 
   [0, 0, 0, 1, 0, 1]]
KeRF> \typed{\{[x] pack_digits(2, x)\} mapdown 6 ngram b}
  [10, 4, 17, 5]
KeRF> \typed{b64[\{[x] pack_digits(2, x)\} mapdown 6 ngram b]}
  "KERF"
\end{Verbatim}

Generalizing,
\begin{Verbatim}
def to_base64_simple(s) \{
	b: flatten \{[x] unpack_digits(2, 8, x)\} mapdown int s
	return b64[\{[x] pack_digits(2, x)\} mapdown 6 ngram b]
\}
\end{Verbatim}

\pagebreak
One important detail we haven't handled yet is what happens when we have an input string which is not divisible by 3 bytes. Base64 pads such data with zeroes out to a full 6-bit character boundary:
\begin{Verbatim}
KeRF> \typed{(6 - count 1 0) % 6}
  4
KeRF> \typed{(6 - count 1 0 1 1) % 6}
  2
KeRF> \typed{(6 - count 1 0 1 1 0 1) % 6}
  0
\end{Verbatim}

 If we had to add 2 bits, we'll add \texttt{=} to the end of the output string. If we had to add 4 bits, we'll add \texttt{==} to the end of the output string.
\begin{Verbatim}
def to_base64(s) \{
	bin: flatten \{[x] unpack_digits(2, 8, x)\} mapdown int s
	pad: (6 - count bin) % 6
	bip: bin join take(pad, 0)
	enc: b64[\{[x] pack_digits(2, x)\} mapdown 6 ngram bip]
	return enc join take(pad / 2, \textasciigrave"=")
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{to_base64 "A stri"}
  "QSBzdHJp"
KeRF> \typed{to_base64 "A strin"}
  "QSBzdHJpbg=="
KeRF> \typed{to_base64 "A string"}
  "QSBzdHJpbmc="
KeRF> \typed{to_base64 "A string."}
  "QSBzdHJpbmcu"
\end{Verbatim}

\pagebreak
If Base64 encoding is a performance-critical component of your application, you might want to consider calling out to an existing C library to do the conversion. We'll discuss Kerf's FFI and how to do this kind of enhancement in a later section. In the shorter term, though, there are some clear opportunities for speeding up our current solution. The following complete implementation specializes and inlines the logic we created in \texttt{unpack\_digits} and \texttt{pack\_digits} so that we aren't constantly reconstructing digit place tables:
\begin{Verbatim}
b64:    char range(65, 91)#range(97, 123)#range(48, 58)#43#47
bits_8: reverse floor 2 pow range 8
bits_6: 2 drop bits_8

def to_base64_fast(s) \{
	bin: flatten \{[x] (floor x / bits_8) % 2\} mapdown int s
	pad: (6 - count bin) % 6
	bip: bin join take(pad, 0)
	enc: b64[\{[x] sum x * bits_6\} mapdown 6 ngram bip]
	return enc join take(pad / 2, \textasciigrave"=")
\}
\end{Verbatim}

How much more efficient is this approach?
\begin{Verbatim}
KeRF> \typed{data: 50000 ? "ABCDE";}
KeRF> \typed{timing 1;}
KeRF> \typed{to_base64 data;}
    3.2 s
KeRF> \typed{to_base64_fast data;}
    2.5 s
KeRF> \typed{1 - 2.5/3.2}
  0.21875
\end{Verbatim}
Just over 20\% faster! Remember- the best way to make code fast is to make it \emph{do less}. If you can cache something (as we are with \texttt{bits\_8} and \texttt{bits\_6}), you can avoid recomputing it frequently.

\vspace{0.5cm}

\label{mapcoresBase64}
Another option would be to observe that both instances of \comb{mapdown} are performing large, entirely parallel operations. Kerf has an extremely handy facility for improving performance in these situations called \comb{mapcores}. This combinator will automatically distribute work across multiple CPU cores and then gather the results. All we have to do is replace \comb{mapdown} with \comb{mapcores}:
\begin{Verbatim}
def to_base64_cores(s) \{
	bin: flatten \{[x] (floor x / bits_8) % 2\} mapcores int s
	pad: (6 - count bin) % 6
	bip: bin join take(pad, 0)
	enc: b64[\{[x] sum x * bits_6\} mapcores 6 ngram bip]
	return enc join take(pad / 2, \textasciigrave"=")
\}
\end{Verbatim}

On a humble 2 core laptop, this tweak allows our program to run in \emph{five percent the original runtime!} Your mileage in other applications may vary. \comb{mapcores} has some overhead, so if you're working with very small datasets it could slow down execution.
\begin{Verbatim}
KeRF> \typed{to_base64_cores data;}
    188 ms
KeRF> \typed{to_base64_cores "ABCDABCDABCD";}
    3 ms
KeRF> \typed{to_base64_fast "ABCDABCDABCD";}
    2 ms
\end{Verbatim}

\pagebreak
For the sake of completeness, let's briefly discuss transforming base64 encoded data back into its original form. If we ignore padding, we can use a very similar approach to our encoder. Before we could simply obtain the ASCII values of characters by using \prim{int}, but this time around we need to use \prim{search} to look up each character in the \texttt{b64} table. The rest is familiar: convert to binary, \prim{flatten} and re-slice with \prim{ngram}, convert back to ASCII indices.
\begin{Verbatim}
def from_base64_simple(s) \{
	ind: s search mapleft b64
	bin: flatten \{[x] (floor x / bits_6) % 2\} mapcores i
	enc: \{[x] sum x * bits_8\} mapcores 8 ngram b
	return char enc
\}
\end{Verbatim}

If the input string contains the padding character \texttt{=}, \prim{search} will return NAN:
\begin{Verbatim}
KeRF> \typed{"Foo=" search mapleft b64}
  [5, 40, 40, NAN]
\end{Verbatim}

We can count how many padding characters (if any) were found with \primu{count\_null}{countNull}. Then we can convert the NANs to 0 for the rest of processing by cleverly employing \prim{msum}.
\begin{Verbatim}
KeRF> \typed{count_null [5, 40, 40, NAN]}
  1
KeRF> \typed{1 msum [3, 7, NAN, 15, NAN]}
  [3, 7, 0, 15, 0]
\end{Verbatim}

When we're done handling padding and performing the normal conversion process, all that remains is to \prim{drop} the padding characters from the end of the result:
\begin{Verbatim}
def from_base64(s) \{
	ind: s search mapleft b64
	pad: count_null ind
	inp: floor 1 msum ind
	bin: flatten \{[x] (floor x / bits_6) % 2\} mapcores inp
	enc: \{[x] sum x * bits_8\} mapcores 8 ngram bin
	return drop(-pad, char enc)
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{from_base64("QSBzdHJpbg==")}
  "A strin"
KeRF> \typed{from_base64("QSBzdHJpbmc=")}
  "A string"
KeRF> \typed{from_base64("QSBzdHJpbmcu")}
  "A string.
\end{Verbatim}

We've written a program which performs a reasonably complex format conversion without any explicit loops or conditionals. The logic is uniform, easy to follow and easy to test. Kerf's \comb{mapcores} provided us with a painless drop-in replacement for \comb{mapdown} which takes advantage of the inherent parallelism in our code.

\pagebreak
\subsection{HTTP Fetching}
KeRF is designed for processing and analyzing data. Many websites exist today which expose access to interesting datasets via an HTTP (HyperText Transfer Protocol) interface. Let's look at HTTP and the performance implications of different styles of data import. We will also take this as an opportunity to explore calling out to C functions using Kerf's Foreign Function Interface.

\vspace{0.5cm}

We will use \url{https://www.quandl.com} for our examples. Quandl provides a wide variety of financial and economic datasets, many of which are available free of charge. Creating an account with Quandl and using credentials with API requests increases the number of queries you are allowed to perform daily, but the system is usable without any form of registration.

\vspace{0.5cm}

In an HTTP transaction, a client makes a \emph{request} for a resource, and the server provides a \emph{response}. Requests have an associated \emph{verb}, which indicates what the client wishes the server to do. The most basic type of request verb is \texttt{GET}- a request for the retrieval of a named resource, indicated by a URL. The response will contain a \emph{response code} indicating success or a class of failure which occurred, and sometimes a \emph{payload}. HTTP is stateless: each request-response pair is an independent transaction, and requests must include all context necessary for processing.

\vspace{0.5cm}

The simplest way to perform an HTTP request is via the Unix \texttt{curl} utility. By using the \prim{shell} function, we can invoke \texttt{curl} from Kerf. In this example, using the \texttt{.json} suffix on the URL instructs Quandl to produce a response in the JSON format, which we can easily parse. \prim{shell} breaks input on newlines, so it is necessary to join these back together via \prim{implode}. The \texttt{-s} option prevents \texttt{curl} from printing information about its download progress, which is not relevant for us.

\begin{Verbatim}
KeRF> \typed{url: "https://www.quandl.com/api/v3/datasets/WIKI/AAPL/data.json?rows=10";}
KeRF> \typed{d: kerf_from_json implode(\textasciigrave"\textbackslash{}n", shell "curl -s "#url#" -X GET");}
\end{Verbatim}

It may also be a good idea to use the \texttt{-o} flag option with \texttt{curl}, which makes it write the response to a temporary file for later retrieval:

\begin{Verbatim}
>curl -s -o tempfile.dat https://url.com/path -X GET
\end{Verbatim}

The response contains a great deal of potentially useful metadata. We can obtain column names:
\begin{Verbatim}
KeRF> \typed{d["dataset_data"]["column_names"]}
  ["Date", "Open", "High", "Low", "Close", "Volume", "Ex-Dividend", "Split Ratio", "Adj. Open",
   "Adj. High", "Adj. Low", "Adj. Close", "Adj. Volume"]
\end{Verbatim}

The data itself is represented in a row-oriented fashion:
\begin{Verbatim}
KeRF> \typed{2 first d["dataset_data"]["data"]}
  [["2015-12-08", 117.52, 118.6, 116.86, 118.23, 34086875.0, 0.0, 1.0, 117.52, 118.6, 116.86,
118.23, 34086875.0], 
 ["2015-12-07", 118.98, 119.86, 117.81, 118.28, 31801965.0, 0.0, 1.0, 118.98, 119.86, 117.81,
118.28, 31801965.0]]
\end{Verbatim}

\pagebreak
To build a table, we can combine the column headings with the \prim{transpose} of the row data and use the \prim{table} function:
\begin{Verbatim}
KeRF> \typed{d_data: d["dataset_data"]["data"];}
KeRF> \typed{d_cols: d["dataset_data"]["column_names"];}
KeRF> \typed{t: table(d_cols, transpose d_data);}
KeRF> \typed{SELECT Date, Open, High, Low FROM t}

┌──────────┬──────┬──────┬──────┐
│Date      │Open  │High  │Low   │
├──────────┼──────┼──────┼──────┤
│2015-12-08│117.52│ 118.6│116.86│
│2015-12-07│118.98│119.86│117.81│
│2015-12-04│115.29│119.25│115.11│
│2015-12-03│116.55│116.79│114.22│
│2015-12-02│117.05│118.11│116.08│
│2015-12-01│118.75│118.81│116.86│
│2015-11-30│117.99│119.41│117.75│
│2015-11-27│118.29│118.41│ 117.6│
│       ...│   ...│   ...│   ...│
└──────────┴──────┴──────┴──────┘
\end{Verbatim}

An alternative to using \prim{table} would be the slightly more verbose INSERT INTO:
\begin{Verbatim}
t: INSERT INTO \{\{\}\} VALUES map(d_cols, transpose d_data)
\end{Verbatim}

Bringing everything together, we can write a simple helper function for fetching Quandl datasets and loading them into a table, permitting any kind of further querying we like:

\begin{Verbatim}
def quandl_table(query) \{
	url:  "https://www.quandl.com/api/v3/"#query
	resp: kerf_from_json implode(\textasciigrave"\textbackslash{}n", shell "curl -s "#url#" -X GET")
	cols: resp["dataset_data"]["column_names"]
	data: resp["dataset_data"]["data"]
	return table(cols, transpose data)
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{SELECT Date, Volume FROM quandl_table "datasets/WIKI/AAPL/data.json?rows=10"}

┌──────────┬──────────┐
│Date      │Volume    │
├──────────┼──────────┤
│2015-12-08│34086875.0│
│2015-12-07│31801965.0│
│2015-12-04│56351301.0│
│2015-12-03│40935107.0│
│2015-12-02│32793916.0│
│2015-12-01│34501246.0│
│2015-11-30│37074611.0│
│2015-11-27│13038955.0│
│       ...│       ...│
└──────────┴──────────┘
\end{Verbatim}

\pagebreak
If we load the entire dataset instead of limiting the result to the first 10 rows, we get 8824 rows and the payload is roughly 1.2mb. Our \texttt{quandl\_table} routine takes somewhere around 3 seconds to run on an average laptop. Let's dig in and try to identify any performance bottlenecks by using Kerf's nanosecond-accuracy timer:

\begin{Verbatim}
def itemize(f) \{
	start: now()
	ticks: f(\{\})
	timespans:  map(xkeys ticks, start stamp_diff mapback ticks)
	display timespans
	display sum xvals timespans
	display timespans / (sum xvals timespans)
\}

def benchmark_json(ticks) \{
	d: shell "curl -s https://www.quandl.com/api/v3/datasets/WIKI/AAPL/data.json -X GET"
	ticks["curl"]: now()

	j: kerf_from_json implode(\textasciigrave"\textbackslash{}n", d)
	ticks["parse"]: now()
	
	cols: j["dataset_data"]["column_names"]
	data: j["dataset_data"]["data"]
	t: table(cols, transpose data);
	ticks["build"]: now()

	return ticks
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{itemize(benchmark_json)}
{curl:5463299000, parse:3175040000, build:6035000}
8644374000
{curl:0.632006, parse:0.367296, build:0.000698142}
\end{Verbatim}

As you can see, the time spent in \prim{shell} and \texttt{curl} is dominant, and represents room for improvement. Parsing the JSON also takes a significant amount of time, and \texttt{INSERT INTO} is nearly instantaneous. Quandl can also emit data in a CSV format. How does this compare?

\begin{Verbatim}
def benchmark_csv(ticks) \{
	shell "curl -s -o t.csv https://www.quandl.com/api/v3/datasets/WIKI/AAPL/data.csv -X GET"
	ticks["curl"]: now()
	
	t: read_table_from_csv("t.csv", "SFFFFFFFFFFFF", 1)
	ticks["build"]: now()
	
	return ticks
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{itemize(benchmark_csv)}
{curl:7386948000, build:73101000}
7460049000
{curl:0.990201, build:0.009799}
\end{Verbatim}

In this run, we're about 15 percent faster overall, with nearly all our time spent in \prim{shell} and \texttt{curl}. This isn't surprising, as CSV is a much simpler file format with less structure than JSON. Clearly, if you're working with large amounts of tabular data, CSV files are more efficient.

\pagebreak
Is there another approach? Let's try writing a dynamic library in C which extends Kerf with the IO capabilities we want. By leveraging \texttt{libcurl}, we should be able to write a simple routine which performs an HTTP GET for a specified resource and parses the result in JSON. By removing the overhead of interacting with \texttt{stdio} or the filesystem it may be possible to improve performance over using the \texttt{curl} command-line utility. For general information about dynamic libraries in Kerf, see \hyperref[sec:ffi]{\textbf{FFI}}.

\vspace{0.5cm}

For this project we will need to work with Kerf strings. A \texttt{KERF} structure represents strings with a type of \texttt{KERF\_CHARVEC}, and stores an \emph{unterminated} string in the ``\texttt{g}'' field. Here's a C function which takes a Kerf string and prints out some information about it:

\begin{Verbatim}
KERF string_info(KERF str) \{
	printf("type was \%d\textbackslash{}n",        str->t);
	printf("length was \%d\textbackslash{}n",      (int)str->n);
	printf("first char was \%c\textbackslash{}n",  str->g[0]);
	printf("string was '\%.*s'\textbackslash{}n",  (int)query->n, query->g);
	return 0;
\}
\end{Verbatim}

For the sake of brevity, examples here will contain a minimum of error checking. They are intended to convey concepts rather than to be ideal production code. In practice when you write C functions to use with Kerf you will want to add code to verify the types of arguments you accept and print meaningful error messages if the function is invoked incorrectly.

\vspace{0.5cm}

We can produce our own strings by using \ffi{kerf\_api\_new\_charvec}{kerfApiNewCharvec}, but this copies a complete C string into a KERF structure. For more control, you can instead use \ffi{kerf\_api\_new\_kerf}{kerfApiNewKerf} to allocate an appropriately typed and sized buffer and write into it at your convenience.

\vspace{0.5cm}

On the following page is a complete C program which can be called from Kerf to perform an HTTP GET of an arbitrary URL. For the sake of simplicity, it assumes that responses will be less than 2mb and preallocates space in a KERF structure for this response text.

\vspace{0.5cm}

Ensure that the \texttt{kerf\_api.h} header file, which should be included along with the Kerf binary, is accessible, and install \texttt{libcurl} if necessary. Compile the example as follows:

\begin{Verbatim}
>cc -m64 -flat_namespace -undefined suppress -dynamiclib curly.c -lcurl -o curly.dylib
\end{Verbatim}

The \texttt{-m64} option requests code be generated for a 64-bit architecture. The \texttt{-flat\_namespace} and \texttt{-undefined suppress} flags are present for accessing Kerf's dylib API, as the Kerf binary itself supplies those symbols. The \texttt{-lcurl} flag instructs the linker to reference \texttt{libcurl}.

\pagebreak
\begin{Verbatim}
#include <stdlib.h>
#include <string.h>
#include <curl/curl.h>
#include "kerf_api.h"

#define MAX_PAYLOAD 2097152 \comment{// 2mb}

static size_t write_data(void *data, size_t size, size_t nmemb, void *destination) \{
	KERF payload = (KERF)destination;
	size_t towrite = size*nmemb;
	\comment{// abort if the payload is larger than our preallocated buffer}
	if ((payload->n) + towrite >= MAX_PAYLOAD) \{ return 0; \}
	memcpy((payload->g) + (payload->n), data, towrite);
	payload->n += towrite;
	return towrite;
\}

KERF http_get(KERF url) \{
	\comment{// copy provided url into a null-terminated c string}
	char* url_terminated = malloc((url->n)+1);
	strncpy(url_terminated, url->g, url->n);
	url_terminated[url->n] = '\textbackslash0';

	\comment{// preallocate a fixed size buffer for the result}
	KERF payload = kerf_api_new_kerf(KERF_CHARVEC, MAX_PAYLOAD);
	payload->n = 0;
	
	\comment{// instruct libcurl to fetch the URL and block for it}
	CURL *curl_handle;
	curl_global_init(CURL_GLOBAL_ALL);
	curl_handle = curl_easy_init();
	curl_easy_setopt(curl_handle, CURLOPT_URL, url_terminated);
	curl_easy_setopt(curl_handle, CURLOPT_NOPROGRESS, 1L);
	curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, write_data);
	curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, payload);
	curl_easy_perform(curl_handle);
	curl_easy_cleanup(curl_handle);

	return payload;
\}
\end{Verbatim}

\pagebreak
After all that work, let's see how our results compare with the previous approaches:

\begin{Verbatim}
http_get: dlload("curly.dylib", "http_get", 1)

def benchmark_raw(ticks) \{
	d: http_get("https://www.quandl.com/api/v3/datasets/WIKI/AAPL/data.json")
	ticks["curl"]: now()
	
	j: kerf_from_json d
	ticks["parse"]: now()
	
	cols: j["dataset_data"]["column_names"]
	data: j["dataset_data"]["data"]
	t: table(cols, transpose data);
	ticks["build"]: now()
	
	return ticks
\}
\end{Verbatim}
\begin{Verbatim}
KeRF> \typed{itemize(benchmark_raw)}
{curl:6428259000, parse:3004744000, build:5596000}
9438599000
{curl:0.681061, parse:0.318346, build:0.000592885}
\end{Verbatim}

It's actually \emph{slower}! Fetching data over a network will vary wildly in performance, and there simply isn't much we can control here. There's a valuable lesson here, though- by profiling before trying alternatives, we maintain a clear view of what our ``optimizations'' are getting us. In this case, it seems that dropping into C doesn't pay off, but now we better understand how to do it when necessary. The only way to know for sure whether this approach is appropriate for your application is to try it and take measurements.

\pagebreak
\subsection{Kerf IPC with Python}\label{sec:pythonkip}

Kerf has a built-in Inter-Process Communication (IPC) protocol which is described in \hyperref[sec:netio]{\textbf{Network I/O}}. In this section we will look at the internal structure of this protocol as described in \hyperref[sec:kipspec]{\textbf{The Kerf IPC Protocol}} and how to interface with it using the Python programming language. Python is chosen for its general popularity, but this information will be general enough that you can apply it to any other language of your preference. Using the IPC interface we will proceed to build a simple application which uses Kerf as an in-memory database.

\vspace{0.5cm}

TCP, the Transmission Control Protocol, is the basis of most internet communication. It provides a bi-directional, fault-tolerant byte stream between a client and server. A TCP server listens for client connections on a specific \emph{port}, which often identifies the intended purpose of a particular TCP connection. For example, HTTP traffic is generally served on port 80. Many simultaneous connections may be active on any particular port.

\vspace{0.5cm}

In the following discussion, we will build some Python functions for communicating via KIP. Explanations will use Python 3.5, the stable release version of the language at the time of writing. For information about version differences, consult \url{http://www.python.org}.

\vspace{0.5cm}

To open a TCP channel with a remote server, we can use the \texttt{socket} module from the standard library. Creating a connection handle with \texttt{socket.AF\_INET} and \texttt{socket.SOCK\_STREAM} indicates that we want an IPV4 TCP client channel. (Intuitive, no?) For easy testing purposes we will connect to \texttt{localhost}, the IP loopback device, looking for a locally-running Kerf instance which was set up to listen as a server on port 10101:
\begin{Verbatim}
handle = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
handle.connect(("localhost", 10101))

\comment{# work with the connection handle here...}

handle.close()
\end{Verbatim}

When reading data from the connection handle, \texttt{recv} will return however many bytes happened to be transmitted in the last TCP packet, which may or may not be the number of bytes we'd like to read. The simple solution to this clumsiness is to write a helper routine which will continue blocking and reading until we have accumulated a desired number of bytes:

\begin{Verbatim}
def recv_n(handle, wanted):
	data = b""
	while(len(data) < wanted):
		data += handle.recv(wanted - len(data))
	return data
\end{Verbatim}

Now we're ready to write the meat of our program. In general, we want to JSON encode some data, build a KIP header based on this payload, transmit both, wait to read a response header, and then finally use that information to read the response payload and unpack it from JSON. From the Python standard library we'll need the \texttt{json} module for JSON encoding and decoding, the \texttt{struct} module for packing and unpacking the KIP header structure, and the \texttt{math} module for doing some of the header size calculations.

\pagebreak
The \texttt{json.dumps} method encodes an input string as JSON. To get a byte buffer, Python 3 requires us to explicitly encode the resulting JSON string. UTF-8 is an appropriate encoding. Constructing the header requires us to calculate a shard size, which is based on the $log_{2}$ of the payload size. The \texttt{socket.htonl} method is used to convert the wire size into network byte order (big-endian) rather than the default (on an x86 machine, little-endian).
\begin{Verbatim}
code       = json.dumps([string, args]).encode("UTF-8")
shard_size = int(math.ceil(math.log(len(code)+16, 2)))
wire_size  = int(2**shard_size)
wire_net   = socket.htonl(wire_size)
padding    = wire_size - (len(code)+16)
\end{Verbatim}

The \texttt{struct.pack} method provides a convenient way to assemble all our various-sized fields together into a byte buffer. The format string provided uses \texttt{x} to indicate padding bytes, \texttt{b} to indicate a signed byte and \texttt{I} to indicate an unsigned 32-bit integer. Hardcoding execution, response and display types, we can arrive at something like the following to send the header, payload and padding:
\begin{Verbatim}
packing = "xxxxbbbxxxxxIbxxbIIxxxx"
packed = struct.pack(packing, 4, 1, 0, wire_net, shard_size, -1, 1, len(code))
handle.send(packed)
handle.send(code)
handle.send(bytes(padding * [0]))
\end{Verbatim}

Now we wait for a response and unpack the result header. A KIP header is precisely 32 bytes, so we perform a blocking read using our \texttt{recv\_n} helper method. \texttt{struct.unpack} is an inversion of \texttt{struct.pack}, and can share the same format string. The only data we actually need from the header is the payload size and the wire size, which allow us to calculate how many padding bytes should be discarded. \texttt{socket.ntohl} reverses \texttt{socket.htonl}, converting network byte order into a usable native byte order.

\begin{Verbatim}
data     = recv_n(handle, 32)
header   = struct.unpack(packing, data)
totality = 16 + socket.ntohl(header[3]) \comment{# wire size + 16}
size     = header[7]                    \comment{# payload size}
payload  = recv_n(handle, size)
recv_n(handle, totality - (size + 32))
\end{Verbatim}

All that remains is to decode our payload bytes as UTF-8 and decode the JSON into a useful result:
\begin{Verbatim}
json.loads(payload.decode("UTF-8"))
\end{Verbatim}

\pagebreak
All together now, \texttt{kerf\_ipc.py}:
\begin{Verbatim}
import socket, json, struct, math

def recv_n(handle, wanted):
	\comment{# block for n bytes}
	data = b""
	while(len(data) < wanted):
		data += handle.recv(wanted - len(data))
	return data

def sync_send(handle, string, *args):
	\comment{# calculate header information}
	code       = json.dumps([string, args]).encode("UTF-8")
	shard_size = int(math.ceil(math.log(len(code)+16, 2)))
	wire_size  = int(2**shard_size)
	wire_net   = socket.htonl(wire_size)
	padding    = wire_size - (len(code)+16)

	\comment{# send the header, payload and padding}
	packing = "xxxxbbbxxxxxIbxxbIIxxxx"
	packed = struct.pack(packing, 4, 1, 0, wire_net, shard_size, -1, 1, len(code))
	handle.send(packed)
	handle.send(code)
	handle.send(bytes(padding * [0]))

	\comment{# parse out the response}
	data     = recv_n(handle, 32)
	header   = struct.unpack(packing, data)
	totality = 16 + socket.ntohl(header[3]) \comment{# wire size + 16}
	size     = header[7]                    \comment{# payload size}
	payload  = recv_n(handle, size)
	recv_n(handle, totality - (size + 32))

	return json.loads(payload.decode("UTF-8"))

\end{Verbatim}

Let's see a simple example of these routines in action. First, start up a Kerf instance waiting for IPC traffic:
\begin{Verbatim}
> \typed{./kerf -q -p 10101}
KeRF>
\end{Verbatim}

Then run a little Python script:
\begin{Verbatim}
import socket, kerf_ipc
handle = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
handle.connect(("localhost", 10101))
print(kerf_ipc.sync_send(handle, "range 2+3"))
handle.close()
\end{Verbatim}
\begin{Verbatim}
> \typed{python3.5 demo.py}
[0, 1, 2, 3, 4]
>
\end{Verbatim}
Two entirely different languages cooperating hand in hand- beautiful!

\subsubsection{HudsucKerf By Proxy}
With these new abilities in hand, one nifty thing we can do is use Python to construct user interfaces for Kerf applications. Imagine describing a simple product and inventory tracking system in Kerf (call it \texttt{hudsuc.kerf}):

\begin{Verbatim}
widgets: \{\{id, name, price, weight\}\}
orders:  \{\{id, widget_id, quantity, time\}\}

def new_widget(name, price, weight) \{
	INSERT INTO widgets VALUES (count(widgets), name, price, weight);
\}

def get_widgets() \{
	return SELECT * FROM widgets;
\}
\end{Verbatim}

We can interact with this database directly via the Kerf REPL, but perhaps we want fancier custom displays and menus. It's possible to do this directly with Kerf and dynamic libraries, as we described in some earlier examples. Alternatively, maybe using Python is easier for your application:

\begin{Verbatim}
import socket, kerf_ipc
db = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
db.connect(("localhost", 10101))

def c_quit():
	db.close()
	exit(0)

def c_idea():
	name   = input("product name: ")
	price  = input("price:        ")
	weight = input("weight:       ")
	kerf_ipc.sync_send(db, "new_widget(\$1, \$2, \$3)", name, price, weight)
	print("great idea, boss!")

def c_widgets():
	w = kerf_ipc.sync_send(db, "get_widgets()")
	print("price\textbackslash{}tname")
	print("-----\textbackslash{}t----------")
	for row in range(len(w["name"])):
		print(w["price"][row] + "\textbackslash{}t"+w["name"][row])

commands = \{"quit": c_quit, "widgets": c_widgets, "idea": c_idea\}

print("Idea Management Gizmo v0.1")
print("(c) 1959 HudsucKerf Industries")
while True:
	commands[input("> ")]()
\end{Verbatim}

Notice how easily we can call Kerf procedures from Python (and how much more pleasant they are to write than SQL stored procedures!), separating database storage and reporting logic from the frontend application. If your program needs persistent storage, it would be a simple matter to make Kerf use memory-mapped IO to automatically serialize tables to disk.

\pagebreak
Let's see a quick command-line session:
\begin{Verbatim}
> \typed{kerf -q -p 10101 hudsuc.kerf}
KeRF> \typed{widgets}

┌──┬────┬─────┬──────┐
│id│name│price│weight│
├──┼────┼─────┼──────┤
└──┴────┴─────┴──────┘

KeRF>
server: new connection from ::ffff:127.0.0.1 on socket 6
\end{Verbatim}
\begin{Verbatim}
> \typed{python3.5 hudsuc.py}
Inventory Management Gizmo v0.1
(c) 1959 HudsucKerf Industries
> \typed{idea}
product name: \typed{extruded plastic dingus}
price:        \typed{1.79}
weight:       \typed{2.5}
great idea, boss!
> \typed{idea}
product name: \typed{bendy straw}
price:        \typed{0.05}
weight:       \typed{0.01}
great idea, boss!
> \typed{widgets}
price	name
-----	----------
1.79	extruded plastic dingus
0.05	bendy straw
> \typed{quit}
\end{Verbatim}

Obviously, this is just scratching the surface of what becomes possible. You could build graphical UIs, service many concurrent users, interface with or expose web APIs, and much more.

\end{document}
